<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bug Hunt PS1</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: rgba(18, 24, 36, 0.8);
      --stroke: #2a3548;
      --accent: #ffb347;
      --accent-2: #6ee7b7;
      --hp: #ff6b8f;
      --text: #e8edf5;
      --muted: #9ca3af;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: "Inter", "Segoe UI", sans-serif;
      overflow: hidden;
    }
    #hud {
      position: absolute; inset: 0;
      pointer-events: none;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      padding: 12px;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 10px;
      padding: 10px 12px;
      pointer-events: auto;
      backdrop-filter: blur(8px);
    }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .col { display: flex; flex-direction: column; gap: 6px; }
    .stat-label { color: var(--muted); font-size: 12px; }
    .stat-value { font-size: 18px; font-weight: 700; }
    .hp-bar { width: 160px; height: 10px; background: #2d1a24; border: 1px solid #3f2633; border-radius: 6px; }
    .hp-fill { height: 100%; background: var(--hp); border-radius: 6px; }
    .btn {
      padding: 9px 12px;
      border-radius: 8px;
      border: 1px solid var(--stroke);
      background: #151c2c;
      color: var(--text);
      cursor: pointer;
      font-weight: 700;
    }
    .btn.primary { background: var(--accent); color: #0a0a0a; }
    .btn.warn { background: var(--hp); color: #0a0a0a; }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }
    #log { max-height: 140px; overflow-y: auto; font-size: 12px; color: var(--muted); }
    #instructions { position: absolute; bottom: 14px; right: 14px; width: 260px; }
    #overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.65); display: none; align-items: center; justify-content: center; font-size: 32px; }
    #overlay.active { display: flex; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="hud">
    <div class="top-bar">
      <div class="panel col">
        <div class="row">
          <div class="col">
            <span class="stat-label">Health</span>
            <div class="hp-bar"><div id="hp-fill" class="hp-fill" style="width:100%"></div></div>
            <span class="stat-value" id="hp-text">10 / 10</span>
          </div>
          <div class="col">
            <span class="stat-label">Points</span>
            <span class="stat-value" id="points">0</span>
            <span class="stat-label">Move</span>
            <span class="stat-value" id="move">0</span>
          </div>
        </div>
        <div class="row" style="gap:8px;">
          <span class="stat-label">Bugs</span>
          <span style="color:#f9865b;">S:<span id="b-s">0</span></span>
          <span style="color:#5cbef4;">M:<span id="b-m">0</span></span>
          <span style="color:#c777ff;">L:<span id="b-l">0</span></span>
        </div>
      </div>
      <div class="panel col" style="min-width:160px; text-align:center;">
        <span class="stat-label">Day</span>
        <span class="stat-value" id="day">1 / 3</span>
        <span class="stat-label">Timer</span>
        <span class="stat-value" id="timer">2:00</span>
      </div>
      <div class="panel col" style="gap:8px; min-width:260px;">
        <div class="row" style="gap:8px;">
          <button class="btn primary" id="btn-start">Start</button>
          <button class="btn" id="btn-roll" disabled>Roll Move</button>
          <button class="btn" id="btn-pause" disabled>Pause</button>
          <button class="btn warn" id="btn-new">New</button>
        </div>
        <div id="log"></div>
      </div>
    </div>
    <div id="instructions" class="panel">
      <strong>How to Play</strong>
      <ul style="padding-left:16px; line-height:1.4; font-size:12px;">
        <li>Roll movement, click a tile to move</li>
        <li>Enter bug tile to fight (S 4+, M 5+, L 6+; L needs 2 hits)</li>
        <li>Roll 1-3 = take 1 damage</li>
        <li>At 0 HP you respawn at Camp</li>
        <li>3 Days. Highest points wins.</li>
      </ul>
    </div>
    <div id="overlay"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
  (() => {
    // =====================
    // CONFIG
    // =====================
    const CONFIG = {
      GRID: 9,
      CELL: 1.2,
      DAY: 120,
      DAYS: 3,
      HP: 10,
      BUGS: {
        S: { count: 10, target: 4, points: 1, hits: 1, color: 0xf9865b },
        M: { count: 6, target: 5, points: 2, hits: 1, color: 0x5cbef4 },
        L: { count: 4, target: 6, points: 5, hits: 2, color: 0xc777ff }
      },
      TERRAIN: {
        CAMP: { cost: 0, color: 0x5ba36a },
        TRAIL: { cost: 1, color: 0x444f60 },
        THICKET: { cost: 2, color: 0x32424f },
        BOG: { cost: 3, color: 0x233038 }
      }
    };

    // =====================
    // STATE
    // =====================
    const state = {
      day: 1,
      time: CONFIG.DAY,
      running: false,
      paused: false,
      lastTick: null,
      player: { hp: CONFIG.HP, points: 0, move: 0, pos: {x:0,z:0}, bugs:{S:0,M:0,L:0} },
      tiles: [],
      bugs: new Map(),
      reachable: new Set(),
      combat: { active: false, id: null },
    };

    // =====================
    // THREE SETUP
    // =====================
    const canvas = document.getElementById('game');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0e14);
    scene.fog = new THREE.Fog(0x0b0e14, 18, 48);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 100);
    const camTarget = new THREE.Vector3(0,0,0);
    camera.position.set(12, 12, 12);
    camera.lookAt(camTarget);

    // PS1-ish wobble: round camera position slightly
    function ps1Snap(vec){
      const snap = 200; // smaller -> more wobble
      vec.x = Math.round(vec.x * snap)/snap;
      vec.y = Math.round(vec.y * snap)/snap;
      vec.z = Math.round(vec.z * snap)/snap;
    }

    const hemi = new THREE.HemisphereLight(0x7ad2f7, 0x2a3a2a, 0.65);
    scene.add(hemi);
    const ambient = new THREE.AmbientLight(0x2a3340, 0.8);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xfff0d2, 0.8);
    dir.position.set(8,12,6);
    dir.castShadow = true;
    dir.shadow.mapSize.width = 1024;
    dir.shadow.mapSize.height = 1024;
    scene.add(dir);

    // =====================
    // GEOMETRY / MATERIALS
    // =====================
    const tileGeo = new THREE.BoxGeometry(CONFIG.CELL, 0.2, CONFIG.CELL);
    const matCache = new Map();
    function tileMat(color){
      if(matCache.has(color)) return matCache.get(color);
      const m = new THREE.MeshLambertMaterial({ color, flatShading:true });
      matCache.set(color,m); return m;
    }

    const playerMat = new THREE.MeshLambertMaterial({ color: 0x6ee7b7, flatShading:true });
    const skinMat = new THREE.MeshLambertMaterial({ color: 0xf5d0a9, flatShading:true });
    const spearMat = new THREE.MeshLambertMaterial({ color: 0x8b5a2b, flatShading:true });
    const spearTipMat = new THREE.MeshLambertMaterial({ color: 0xdedede, flatShading:true });

    const bugMatSmall = new THREE.MeshLambertMaterial({ color: CONFIG.BUGS.S.color, flatShading:true });
    const bugMatMed   = new THREE.MeshLambertMaterial({ color: CONFIG.BUGS.M.color, flatShading:true });
    const bugMatLarge = new THREE.MeshLambertMaterial({ color: CONFIG.BUGS.L.color, flatShading:true });

    // Groups for instance management
    const tileGroup = new THREE.Group();
    const bugGroup = new THREE.Group();
    scene.add(tileGroup);
    scene.add(bugGroup);

    // simple ground to keep depth cues visible under fog
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(80, 80),
      new THREE.MeshLambertMaterial({ color: 0x111722, side: THREE.DoubleSide })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.11;
    ground.receiveShadow = true;
    scene.add(ground);

    // Player mesh
    const player = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.7,0.3), playerMat);
    body.position.y = 0.6; body.castShadow = true;
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), skinMat);
    head.position.y = 1.1; head.castShadow = true;
    const spear = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,1.2,5), spearMat);
    spear.position.set(0.35,0.8,0);
    spear.rotation.z = Math.PI/2;
    const tip = new THREE.Mesh(new THREE.ConeGeometry(0.09,0.2,5), spearTipMat);
    tip.position.set(0.95,0.8,0);
    tip.rotation.z = Math.PI/2;
    player.add(body, head, spear, tip);
    scene.add(player);

    // =====================
    // MAP
    // =====================
    function clearGroup(g){ while(g.children.length){ g.remove(g.children[0]); } }

    function buildMap(){
      clearGroup(tileGroup);
      state.tiles = [];
      const half = Math.floor(CONFIG.GRID/2);
      for(let x=-half;x<=half;x++){
        for(let z=-half;z<=half;z++){
          let terrain;
          if(x===0 && z===0) terrain='CAMP';
          else {
            const r=Math.random();
            if(r<0.5) terrain='TRAIL';
            else if(r<0.8) terrain='THICKET';
            else terrain='BOG';
          }
          const tile = { x, z, terrain, bugId:null };
          state.tiles.push(tile);
          const mesh = new THREE.Mesh(tileGeo, tileMat(CONFIG.TERRAIN[terrain].color));
          mesh.position.set(x*CONFIG.CELL, 0, z*CONFIG.CELL);
          mesh.receiveShadow = true;
          mesh.userData = { type:'tile', x, z };
          tileGroup.add(mesh);
        }
      }
    }

    function key(x,z){ return `${x},${z}`; }
    function getTile(x,z){ return state.tiles.find(t=>t.x===x && t.z===z); }

    function placeBugs(){
      clearGroup(bugGroup);
      state.bugs.clear();
      state.tiles.forEach(t=>t.bugId=null);
      const open = state.tiles.filter(t=>!(t.x===0 && t.z===0));
      shuffle(open);
      let id=0;
      for(const [size,cfg] of Object.entries(CONFIG.BUGS)){
        for(let i=0;i<cfg.count && open.length;i++){
          const tile=open.pop();
          const bug={ id:`bug_${id++}`, size, target:cfg.target, points:cfg.points, hits:cfg.hits, hitsLeft:cfg.hits, x:tile.x, z:tile.z };
          state.bugs.set(bug.id, bug);
          tile.bugId = bug.id;
          const mesh = createBugMesh(bug);
          mesh.position.set(tile.x*CONFIG.CELL, 0.15, tile.z*CONFIG.CELL);
          mesh.userData = { type:'bug', id:bug.id };
          bugGroup.add(mesh);
        }
      }
      updateBugCounts();
    }

    function createBugMesh(bug){
      const mat = bug.size==='S'?bugMatSmall:bug.size==='M'?bugMatMed:bugMatLarge;
      const g = new THREE.Group();
      const s = bug.size==='S'?0.18:bug.size==='M'?0.24:0.33;
      const body = new THREE.Mesh(new THREE.SphereGeometry(s, 6, 6), mat);
      body.castShadow=true;
      g.add(body);
      // simple legs
      for(let i=0;i<4;i++){
        const leg = new THREE.Mesh(new THREE.ConeGeometry(s*0.25, s*0.6, 4), mat);
        const ang = (Math.PI/2)*i + Math.PI/4;
        leg.position.set(Math.cos(ang)*s*0.6, -s*0.1, Math.sin(ang)*s*0.6);
        leg.rotation.x = Math.PI/2;
        g.add(leg);
      }
      return g;
    }

    // =====================
    // MOVEMENT / REACHABLE
    // =====================
    function computeReachable(){
      state.reachable.clear();
      if(state.player.move<=0 || state.combat.active) return;
      const start = state.player.pos;
      const queue=[{x:start.x,z:start.z,cost:0}];
      const best=new Map([[key(start.x,start.z),0]]);
      while(queue.length){
        const cur=queue.shift();
        for(const [dx,dz] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=cur.x+dx, nz=cur.z+dz;
          const tile=getTile(nx,nz); if(!tile) continue;
          const cost=cur.cost + CONFIG.TERRAIN[tile.terrain].cost;
          if(cost<=state.player.move && (!best.has(key(nx,nz)) || best.get(key(nx,nz))>cost)){
            best.set(key(nx,nz),cost);
            queue.push({x:nx,z:nz,cost});
            if(!(nx===start.x && nz===start.z)) state.reachable.add(key(nx,nz));
          }
        }
      }
    }

    function moveTo(x,z){
      if(!state.reachable.has(key(x,z))) return;
      const tile=getTile(x,z); if(!tile) return;
      const cost = CONFIG.TERRAIN[tile.terrain].cost;
      state.player.move -= cost;
      state.player.pos = {x,z};
      log(`Moved to ${tile.terrain} (cost ${cost})`);
      if(tile.terrain==='CAMP' && state.player.hp<CONFIG.HP){
        const healed = CONFIG.HP - state.player.hp;
        state.player.hp = CONFIG.HP;
        log(`Healed +${healed} HP at Camp`);
      }
      if(tile.bugId){ startCombat(tile.bugId); }
      else { computeReachable(); }
      updateUI();
    }

    function rollMove(){
      if(!state.running || state.paused || state.combat.active) return;
      const roll = Math.floor(Math.random()*6)+1;
      state.player.move = roll;
      log(`Rolled ${roll} movement`);
      computeReachable();
      updateUI();
    }

    // =====================
    // COMBAT
    // =====================
    function startCombat(id){
      const bug=state.bugs.get(id); if(!bug) return;
      state.combat={active:true,id};
      state.player.move=0;
      log(`Engaged ${bug.size} bug (hit ${bug.target}+)`);
    }

    function rollAttack(){
      if(!state.combat.active || !state.running || state.paused) return;
      const bug=state.bugs.get(state.combat.id); if(!bug) return;
      const roll=Math.floor(Math.random()*6)+1;
      if(roll>=bug.target){
        bug.hitsLeft--;
        log(`Hit! (${bug.hitsLeft} left)`);
        if(bug.hitsLeft<=0){
          log(`Defeated ${bug.size} +${bug.points}pts`);
          state.player.points += bug.points;
          state.player.bugs[bug.size]++;
          const tile=getTile(bug.x,bug.z); if(tile) tile.bugId=null;
          state.bugs.delete(bug.id);
          endCombat();
          updateBugCounts();
        }
      } else {
        if(roll<=3){
          state.player.hp--;
          log(`Stung! -1 HP (${state.player.hp})`);
          if(state.player.hp<=0){
            log('KO! Back to camp');
            state.player.hp=CONFIG.HP;
            state.player.pos={x:0,z:0};
            endCombat();
          }
        } else {
          log('Miss!');
        }
      }
      updateUI();
    }

    function endCombat(){
      state.combat={active:false,id:null};
      state.reachable.clear();
      computeReachable();
    }

    // =====================
    // GAME FLOW
    // =====================
    function startGame(){
      state.day=1;
      state.time=CONFIG.DAY;
      state.running=false;
      state.paused=false;
      state.player={ hp:CONFIG.HP, points:0, move:0, pos:{x:0,z:0}, bugs:{S:0,M:0,L:0} };
      state.combat={active:false,id:null};
      state.reachable.clear();
      buildMap();
      placeBugs();
      logClear();
      log('Welcome to Bug Hunt PS1');
      updateUI();
      draw();
    }

    function startDay(){
      if(state.running) return;
      state.running=true;
      state.paused=false;
      state.lastTick=null;
      document.getElementById('btn-start').disabled=true;
      document.getElementById('btn-roll').disabled=false;
      document.getElementById('btn-pause').disabled=false;
      log(`Day ${state.day} started!`);
      requestAnimationFrame(loop);
    }

    function loop(ts){
      if(!state.running) return;
      if(state.lastTick===null) state.lastTick=ts;
      const dt=(ts-state.lastTick)/1000;
      state.lastTick=ts;
      if(!state.paused){
        state.time -= dt;
        if(state.time<=0){ endDay(); return; }
      }
      animatePlayer(ts);
      animateBugs(ts);
      draw();
      updateUI();
      requestAnimationFrame(loop);
    }

    function endDay(){
      state.running=false;
      if(state.day>=CONFIG.DAYS){ endGame(); return; }
      state.day++;
      state.time=CONFIG.DAY;
      state.player.move=0;
      if(state.combat.active) endCombat();
      placeBugs();
      showOverlay(`Day ${state.day}`);
      document.getElementById('btn-start').disabled=false;
      document.getElementById('btn-roll').disabled=true;
      document.getElementById('btn-pause').disabled=true;
      log(`Day ${state.day} ready.`);
    }

    function endGame(){
      state.running=false;
      showOverlay(`Final Score\n${state.player.points} pts`);
      log('Hunt complete!');
      document.getElementById('btn-start').disabled=true;
      document.getElementById('btn-roll').disabled=true;
      document.getElementById('btn-pause').disabled=true;
    }

    // =====================
    // RENDER
    // =====================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function draw(){
      // subtle PS1 snap
      ps1Snap(camera.position);
      camera.lookAt(camTarget);
      renderer.render(scene, camera);
    }

    function animatePlayer(ts){
      const t = ts*0.002;
      player.position.set(state.player.pos.x*CONFIG.CELL, 0.1 + Math.sin(t)*0.05, state.player.pos.z*CONFIG.CELL);
      player.rotation.y = Math.sin(t*0.5)*0.1;
    }

    function animateBugs(ts){
      const t=ts*0.002;
      bugGroup.children.forEach((m,i)=>{
        m.position.y = 0.1 + Math.sin(t + i)*0.05;
        m.rotation.y += 0.005;
      });
    }

    // =====================
    // INPUT
    // =====================
    renderer.domElement.addEventListener('click', (e)=>{
      if(!state.running || state.paused || state.combat.active) return;
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(tileGroup.children, false);
      if(intersects.length){
        const hit = intersects[0].object.userData;
        moveTo(hit.x, hit.z);
      }
    });

    document.addEventListener('keydown', (e)=>{
      if(e.code==='Space'){ e.preventDefault(); if(!state.running) startDay(); else rollMove(); }
      if(e.code==='KeyR'){ rollAttack(); }
      if(e.code==='KeyP'){ state.paused=!state.paused; log(state.paused?'Paused':'Resumed'); }
    });

    document.getElementById('btn-start').onclick=startDay;
    document.getElementById('btn-roll').onclick=rollMove;
    document.getElementById('btn-pause').onclick=()=>{ state.paused=!state.paused; log(state.paused?'Paused':'Resumed'); };
    document.getElementById('btn-new').onclick=startGame;

    // =====================
    // UI
    // =====================
    function updateUI(){
      const hpPct = state.player.hp / CONFIG.HP * 100;
      document.getElementById('hp-fill').style.width = hpPct+'%';
      document.getElementById('hp-text').textContent = `${state.player.hp} / ${CONFIG.HP}`;
      document.getElementById('points').textContent = state.player.points;
      document.getElementById('move').textContent = state.player.move;
      document.getElementById('day').textContent = `${state.day} / ${CONFIG.DAYS}`;
      const m=Math.max(0,Math.floor(state.time/60));
      const s=Math.max(0,Math.floor(state.time%60)).toString().padStart(2,'0');
      document.getElementById('timer').textContent = `${m}:${s}`;
      document.getElementById('btn-roll').disabled = !state.running || state.paused || state.combat.active || state.player.move>0;
      // bug counts
      updateBugCounts();
    }

    function updateBugCounts(){
      let sCnt=0,mCnt=0,lCnt=0;
      state.bugs.forEach(b=>{ if(b.size==='S') sCnt++; else if(b.size==='M') mCnt++; else lCnt++; });
      document.getElementById('b-s').textContent=sCnt;
      document.getElementById('b-m').textContent=mCnt;
      document.getElementById('b-l').textContent=lCnt;
    }

    // =====================
    // OVERLAY / LOG
    // =====================
    function showOverlay(text){
      const el=document.getElementById('overlay');
      el.textContent=text;
      el.classList.add('active');
      setTimeout(()=>el.classList.remove('active'), 1500);
    }

    function log(msg){
      const box=document.getElementById('log');
      const el=document.createElement('div');
      el.textContent = `[${clock()}] ${msg}`;
      box.prepend(el);
      while(box.children.length>40) box.lastChild.remove();
    }
    function logClear(){ document.getElementById('log').innerHTML=''; }
    function clock(){
      const t=Math.max(0, Math.floor(state.time));
      const m=Math.floor(t/60); const s=(t%60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }

    // =====================
    // UTIL
    // =====================
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j]],arr[i]; } return arr; }

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // =====================
    // START
    // =====================
    startGame();
  })();
  </script>
</body>
</html>
