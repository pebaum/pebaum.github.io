<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bug Hunt: Festival Rush (Web Prototype)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Manrope:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #080c1a;
      --panel: #0f1628;
      --panel-strong: #121c30;
      --text: #e8edf5;
      --muted: #9da9bd;
      --accent: #f7b500;
      --accent-2: #5ee0b5;
      --stroke: #1f2d44;
      --hex-trail: #18263b;
      --hex-thicket: #132132;
      --hex-bog: #102020;
      --hex-camp: #1d2f44;
      --bug-s: #f9865b;
      --bug-m: #5cbef4;
      --bug-l: #c777ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, #0e1630, #070b18 55%), radial-gradient(circle at 80% 0%, #12213d, transparent 40%), #05070f;
      color: var(--text);
      font-family: "Space Grotesk", "Manrope", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
    }
    a { color: var(--accent-2); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .page { max-width: 1400px; margin: 0 auto; padding: 20px 18px 28px; }
    .hero {
      background: linear-gradient(135deg, #0e1426, #0c111e);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 16px 18px;
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
      box-shadow: 0 18px 40px rgba(0,0,0,0.35);
    }
    .hero h1 { margin: 0 0 4px; font-size: 24px; letter-spacing: 0.5px; }
    .hero p { margin: 0; color: var(--muted); line-height: 1.5; }
    .hero .tags { display: flex; flex-wrap: wrap; gap: 8px; margin: 10px 0 0; }
    .tag {
      border: 1px solid var(--stroke);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      background: rgba(255,255,255,0.02);
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 12px;
    }
    label { display: flex; flex-direction: column; gap: 6px; font-size: 13px; color: var(--muted); }
    input {
      background: #0c1624;
      border: 1px solid var(--stroke);
      border-radius: 10px;
      padding: 10px 12px;
      color: var(--text);
      font: inherit;
    }
    button {
      background: linear-gradient(135deg, #f6b100, #f77e1b);
      color: #0b0a0a;
      font-weight: 700;
      border: none;
      border-radius: 12px;
      padding: 12px 14px;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.2s ease;
      box-shadow: 0 12px 24px rgba(247, 177, 0, 0.22);
    }
    button.secondary {
      background: #182236;
      color: var(--text);
      box-shadow: none;
      border: 1px solid var(--stroke);
    }
    button:active { transform: translateY(1px); }
    main.layout {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 14px;
      margin-top: 16px;
    }
    .board-shell {
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.28);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .board-head {
      display: grid;
      grid-template-columns: auto auto 1fr auto;
      gap: 10px;
      align-items: center;
    }
    .badge {
      background: #10192c;
      color: var(--accent);
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      font-weight: 700;
      letter-spacing: 0.5px;
    }
    .timer {
      font-size: 24px;
      font-weight: 700;
      color: #f2f5ff;
      padding: 8px 12px;
      background: #111b30;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      min-width: 110px;
      text-align: center;
    }
    .board-status {
      display: flex;
      align-items: center;
      gap: 14px;
      color: var(--muted);
      font-size: 14px;
      flex-wrap: wrap;
    }
    .board {
      background: radial-gradient(circle at 40% 30%, rgba(94,224,181,0.1), transparent 55%), #0a0f19;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 6px;
      min-height: 620px;
      position: relative;
    }
    #board {
      width: 100%;
      height: 100%;
    }
    .board-caption {
      color: var(--muted);
      font-size: 13px;
      padding: 4px 6px 0;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.22);
    }
  .panel h3 {
      margin: 0 0 8px;
      font-size: 16px;
      letter-spacing: 0.25px;
    }
    .report {
      background: #0c1323;
      border: 1px solid var(--stroke);
      border-radius: 10px;
      padding: 10px;
      white-space: pre-wrap;
      font-family: "Manrope", system-ui, sans-serif;
      font-size: 13px;
      color: var(--text);
      min-height: 120px;
    }
    .stack { display: flex; flex-direction: column; gap: 10px; }
    .players { display: flex; flex-direction: column; gap: 8px; }
    .player-row {
      border: 1px solid var(--stroke);
      border-radius: 10px;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      background: #10192c;
      cursor: pointer;
      transition: border-color 0.15s ease, transform 0.1s ease;
    }
    .player-row:hover { border-color: var(--accent-2); transform: translateY(-1px); }
    .player-row.active { border-color: var(--accent); box-shadow: 0 10px 22px rgba(247,177,0,0.14); }
    .player-meta { color: var(--muted); font-size: 13px; display: flex; gap: 10px; flex-wrap: wrap; }
    .stat { padding: 2px 8px; border-radius: 8px; border: 1px solid var(--stroke); }
    .log {
      max-height: 220px;
      overflow-y: auto;
      font-size: 13px;
      color: var(--muted);
      background: #0c1323;
    }
    .log-entry { margin-bottom: 6px; line-height: 1.35; }
    .rules small { color: var(--muted); }
    .rule-list { padding-left: 16px; color: var(--text); }
    .rule-list li { margin-bottom: 6px; }
    .actions { display: flex; flex-wrap: wrap; gap: 8px; }
    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: #10182b;
      border: 1px solid var(--stroke);
      color: var(--muted);
      font-size: 12px;
    }
    .hex { stroke: #1b283c; stroke-width: 1.2; fill: #0c1424; transition: fill 0.15s ease, stroke 0.15s ease; }
    .hex.t-trail { fill: var(--hex-trail); }
    .hex.t-thicket { fill: var(--hex-thicket); }
    .hex.t-bog { fill: var(--hex-bog); }
    .hex.t-camp { fill: var(--hex-camp); stroke: #2b3f5e; }
    .hex.reachable { stroke: var(--accent-2); fill: rgba(94,224,181,0.15); cursor: pointer; }
    .hex.active { stroke: var(--accent); stroke-width: 2.2; }
    .hex.blocked { fill: rgba(120,53,15,0.35); }
    .bug circle { stroke: #0a0f18; stroke-width: 1.8; }
    .bug text { fill: #0c0d0f; font-weight: 700; }
    .bug-s circle { fill: var(--bug-s); }
    .bug-m circle { fill: var(--bug-m); }
    .bug-l circle { fill: var(--bug-l); }
    .player-token { stroke: #0b0e17; stroke-width: 1.6; }
    .player-token text { fill: #0b0b0b; font-weight: 800; }
    .player-1 { fill: #f7b500; }
    .player-2 { fill: #5ee0b5; }
    .player-3 { fill: #6ba7ff; }
    .player-4 { fill: #ff6b8f; }
    .fight-box {
      border: 1px dashed var(--stroke);
      padding: 10px;
      border-radius: 10px;
      background: #0f182a;
    }
    .fight-box h4 { margin: 0 0 6px; }
    .dice {
      display: inline-flex;
      justify-content: center;
      align-items: center;
      width: 38px;
      height: 38px;
      border-radius: 10px;
      background: #0a111f;
      border: 1px solid var(--stroke);
      font-weight: 700;
      font-size: 16px;
      margin-right: 6px;
    }
    .mini {
      font-size: 12px;
      color: var(--muted);
    }
    @media (max-width: 1080px) {
      main.layout { grid-template-columns: 1fr; }
      .hero { grid-template-columns: 1fr; }
      .board { min-height: 520px; }
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="hero">
      <div>
        <h1>Bug Hunt: Festival Rush</h1>
        <p>A rethink of the tabletop festival into a fast, browser-playable hex chase. Three timed Days, no turns, hunt bugs, protect your HP, and rack up tokens before the horn ends each Day.</p>
        <div class="tags">
          <span class="tag">Hex real-time</span>
          <span class="tag">3 Day sprint</span>
          <span class="tag">Sting on 1</span>
          <span class="tag">Size gates: 4+/5+/6+</span>
        </div>
      </div>
      <div class="controls">
        <label>Players (1-4)
          <input type="number" id="playerCount" min="1" max="4" value="2">
        </label>
        <label>Player names (comma separated)
          <input type="text" id="playerNames" value="Ash,Bee">
        </label>
        <label>Map radius (hex rings)
          <input type="number" id="radiusInput" min="3" max="6" value="4">
        </label>
        <label>Day length (seconds)
          <input type="number" id="dayLength" min="60" max="420" step="15" value="120">
        </label>
        <label>Bug mix S / M / L
          <input type="text" id="bugMix" value="10 / 6 / 4">
        </label>
        <div class="actions">
          <button id="newGame">Generate Map</button>
          <button class="secondary" id="resetBtn">Reset Scores</button>
        </div>
      </div>
    </header>

    <main class="layout">
      <section class="board-shell">
        <div class="board-head">
          <div class="badge" id="dayBadge">Day 1 / 3</div>
          <div class="timer" id="timer">03:00</div>
          <div class="board-status" id="boardStatus"></div>
          <div class="actions">
            <button id="startBtn">Start / Resume Day</button>
            <button class="secondary" id="pauseBtn">Pause</button>
            <button class="secondary" id="advanceBtn">Advance Day</button>
            <button class="secondary" id="autoBtn">Auto-play: Off</button>
          </div>
        </div>
        <div class="board" id="boardWrap">
          <svg id="board" role="img" aria-label="Bug Hunt map"></svg>
          <div class="board-caption" id="boardCaption">Roll movement, then click a highlighted hex. Enter a bug to fight.</div>
        </div>
      </section>

      <section class="stack">
        <div class="panel">
          <h3>Actions</h3>
          <div class="pill" id="turnInfo">Ready</div>
          <div class="actions" style="margin-top:8px;">
            <button class="secondary" id="rollMove">Roll Movement</button>
            <button class="secondary" id="endMove">Drop Movement</button>
          </div>
          <div class="fight-box" id="fightBox"></div>
        </div>

        <div class="panel">
          <h3>Hunters</h3>
          <div class="players" id="players"></div>
        </div>

        <div class="panel rules">
          <h3>Rethought Loop</h3>
          <ul class="rule-list">
            <li>3 timed Days; all Hunters act while the timer runs. No turns.</li>
            <li>Roll d6 for movement. Spend points to enter hexes (cost 1/2/3). Entering a bug ends remaining movement.</li>
            <li>Fight on the bug hex: roll d6 until you beat its gate (S 4+, M 5+, L 6+). Large needs 2 total hits to capture.</li>
            <li>Damage on low rolls: 1-3 always costs 1 HP. HP starts at 10. At 0 you pop back to Camp at full HP.</li>
            <li>Points: Small 1, Medium 2, Large 5. Highest total after Day 3 wins.</li>
            <li>Between Days the board re-pours bugs; scores carry over.</li>
          </ul>
          <small>House rules are easy tweaks: change bug mix, day length, or sting values in the header controls and regenerate.</small>
        </div>

        <div class="panel log" id="log"></div>

        <div class="panel">
          <h3>Simulation & Report</h3>
          <div class="actions" style="margin-bottom:8px;">
            <button class="secondary" id="simRun">Run full simulation</button>
            <button class="secondary" id="simClear">Clear report</button>
          </div>
          <div class="report" id="simReport">Run a full 3-day sim to auto-play all hunters and see a narrative summary here.</div>
        </div>
      </section>
    </main>
  </div>

  <script>
    const HEX_SIZE = 36;
    const BUG_LIBRARY = {
      S: [
        { name: "Needle Mite", type: "Flying", target: 4, sting: 1, points: 1 },
        { name: "Amber Ant", type: "Ground", target: 4, sting: 1, points: 1 },
        { name: "Glow Gnat", type: "Flying", target: 4, sting: 1, points: 1 },
        { name: "Grub Scout", type: "Ground", target: 4, sting: 1, points: 1 }
      ],
      M: [
        { name: "Spine Bee", type: "Flying", target: 5, sting: 2, points: 2 },
        { name: "Orb Spider", type: "Ground", target: 5, sting: 2, points: 2 },
        { name: "Verdant Beetle", type: "Armored", target: 5, sting: 2, points: 2 }
      ],
      L: [
        { name: "Husk Scorpion", type: "Armored", target: 6, sting: 3, points: 5 },
        { name: "Crown Centipede", type: "Armored", target: 6, sting: 3, points: 5 },
        { name: "Queen Hornet", type: "Flying", target: 6, sting: 3, points: 5 }
      ]
    };

    const terrainTable = {
      trail: { label: "Trail", cost: 1 },
      thicket: { label: "Thicket", cost: 2 },
      bog: { label: "Bog", cost: 3 },
      camp: { label: "Camp", cost: 0 }
    };

    const state = {
      config: {
        radius: 4,
        daySeconds: 120,
        bugCounts: { S: 10, M: 6, L: 4 },
        days: 3
      },
      cells: new Map(),
      centers: new Map(),
      bugs: new Map(),
      players: [],
      day: 1,
      timer: { running: false, remaining: 180, id: null },
      activePlayer: null,
      reachable: new Map(),
      fights: {},
      lastMoveRoll: null,
      logs: [],
      auto: { enabled: false, timer: null, intervalMs: 1500 },
      stats: { players: {} }
    };

    const boardEl = document.getElementById("board");
    const logEl = document.getElementById("log");
    const playersEl = document.getElementById("players");
    const fightBox = document.getElementById("fightBox");
    const turnInfo = document.getElementById("turnInfo");
    const timerEl = document.getElementById("timer");
    const dayBadge = document.getElementById("dayBadge");
    const boardStatus = document.getElementById("boardStatus");
    const boardCaption = document.getElementById("boardCaption");

    function coordKey(q, r) { return q + "," + r; }

    function axialToPixel(q, r) {
      const x = HEX_SIZE * Math.sqrt(3) * (q + r / 2);
      const y = HEX_SIZE * 1.5 * r;
      return { x, y };
    }

    function hexPoints(cx, cy, size) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 180 * (60 * i - 30);
        pts.push((cx + size * Math.cos(angle)).toFixed(2) + "," + (cy + size * Math.sin(angle)).toFixed(2));
      }
      return pts.join(" ");
    }

    function randomTerrain() {
      const roll = Math.random();
      if (roll < 0.55) return "trail";
      if (roll < 0.82) return "thicket";
      return "bog";
    }

    function buildGrid(radius) {
      const cells = new Map();
      for (let q = -radius; q <= radius; q++) {
        for (let r = -radius; r <= radius; r++) {
          const s = -q - r;
          if (Math.abs(s) > radius) continue;
          const key = coordKey(q, r);
          const terrain = (q === 0 && r === 0) ? "camp" : randomTerrain();
          cells.set(key, { key, q, r, terrain, bugId: null });
        }
      }
      return cells;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    let bugIdCounter = 1;
    function createBug(size) {
      const pool = BUG_LIBRARY[size];
      const base = pool[Math.floor(Math.random() * pool.length)];
      return { ...base, id: "B" + (bugIdCounter++), size };
    }

    function placeBugs() {
      state.bugs.clear();
      state.cells.forEach(cell => { cell.bugId = null; });
      const openCells = Array.from(state.cells.values()).filter(c => c.terrain !== "camp");
      shuffle(openCells);
      const counts = state.config.bugCounts;
      const want = [
        ...Array(counts.S).fill("S"),
        ...Array(counts.M).fill("M"),
        ...Array(counts.L).fill("L")
      ];
      shuffle(want);
      for (let i = 0; i < want.length && i < openCells.length; i++) {
        const cell = openCells[i];
        const bug = createBug(want[i]);
        bug.cell = cell.key;
        state.bugs.set(bug.id, bug);
        cell.bugId = bug.id;
      }
    }

    function createPlayers(count, names) {
      state.players = [];
      state.stats.players = {};
      for (let i = 0; i < count; i++) {
        const name = names[i] ? names[i].trim() : "Hunter " + (i + 1);
        state.players.push({
          id: "P" + (i + 1),
          name: name || ("Hunter " + (i + 1)),
          q: 0,
          r: 0,
          hp: 10,
          maxHp: 10,
          score: 0,
          movement: 0,
          knocked: false
        });
        state.stats.players["P" + (i + 1)] = {
          fights: 0,
          hits: 0,
          misses: 0,
          lowRolls: 0,
          damageTaken: 0,
          kos: 0,
          bugs: { S: 0, M: 0, L: 0 }
        };
      }
      state.activePlayer = state.players[0]?.id || null;
    }

    function resetTimer() {
      clearInterval(state.timer.id);
      state.timer.id = null;
      state.timer.remaining = state.config.daySeconds;
      state.timer.running = false;
      updateTimerUI();
    }

    function newGame() {
      bugIdCounter = 1;
      const playerCount = Math.min(4, Math.max(1, parseInt(document.getElementById("playerCount").value, 10) || 1));
      const names = document.getElementById("playerNames").value.split(",");
      const radius = Math.min(6, Math.max(3, parseInt(document.getElementById("radiusInput").value, 10) || 4));
      const daySeconds = Math.min(420, Math.max(60, parseInt(document.getElementById("dayLength").value, 10) || 180));
      const mixParts = document.getElementById("bugMix").value.split("/");
      const cleanNum = str => Math.max(0, parseInt(str.replace(/[^0-9]/g, ""), 10) || 0);
      const counts = { S: cleanNum(mixParts[0] || "10"), M: cleanNum(mixParts[1] || "6"), L: cleanNum(mixParts[2] || "4") };

      state.config.radius = radius;
      state.config.daySeconds = daySeconds;
      state.config.bugCounts = counts;

      state.cells = buildGrid(radius);
      state.centers = new Map();
      state.cells.forEach(cell => state.centers.set(cell.key, axialToPixel(cell.q, cell.r)));
      placeBugs();
      createPlayers(playerCount, names);
      state.day = 1;
      state.fights = {};
      state.reachable.clear();
      state.logs = [];
      resetTimer();
      stopAuto();
      log("New festival created. Radius " + radius + ", day length " + daySeconds + "s. Bugs S/M/L: " + counts.S + "/" + counts.M + "/" + counts.L + ".");
      render();
    }

    function log(msg) {
      const stamp = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
      state.logs.unshift("[" + stamp + "] " + msg);
      state.logs = state.logs.slice(0, 80);
      logEl.innerHTML = state.logs.map(l => "<div class='log-entry'>" + l + "</div>").join("");
      logEl.scrollTop = 0;
    }

    function updateTimerUI() {
      const m = Math.floor(state.timer.remaining / 60).toString().padStart(2, "0");
      const s = (state.timer.remaining % 60).toString().padStart(2, "0");
      timerEl.textContent = m + ":" + s;
      dayBadge.textContent = "Day " + state.day + " / " + state.config.days;
    }

    function startDay() {
      if (state.timer.running) return;
      if (state.timer.remaining <= 0) state.timer.remaining = state.config.daySeconds;
      state.timer.running = true;
      boardCaption.textContent = "Day " + state.day + " is live. Move every Hunter while the clock runs.";
      state.timer.id = setInterval(() => {
        state.timer.remaining -= 1;
        updateTimerUI();
        if (state.timer.remaining <= 0) {
          endDay("Time up!");
        }
      }, 1000);
      log("Day " + state.day + " started.");
      render();
    }

    function pauseDay() {
      if (!state.timer.running) return;
      clearInterval(state.timer.id);
      state.timer.id = null;
      state.timer.running = false;
      log("Paused with " + state.timer.remaining + "s left.");
      render();
    }

    function endDay(reason) {
      clearInterval(state.timer.id);
      state.timer.id = null;
      state.timer.running = false;
      state.timer.remaining = 0;
      state.reachable.clear();
      state.fights = {};
      boardCaption.textContent = "Day " + state.day + " ended. " + reason;
      log("Day " + state.day + " ended. " + reason);
      render();
    }

    function advanceDay() {
      if (state.day >= state.config.days) {
        log("Festival is already over. Highest points wins.");
        return;
      }
      clearInterval(state.timer.id);
      state.timer.id = null;
      state.timer.running = false;
      state.day += 1;
      state.players.forEach(p => { p.movement = 0; });
      state.reachable.clear();
      state.fights = {};
      state.timer.remaining = state.config.daySeconds;
      placeBugs();
      boardCaption.textContent = "Day " + state.day + " ready. Roll when the horn sounds.";
      log("Advanced to Day " + state.day + ". Bugs re-poured.");
      render();
    }

    function neighborKeys(cell) {
      const dirs = [
        [1, 0], [0, 1], [-1, 1],
        [-1, 0], [0, -1], [1, -1]
      ];
      const keys = [];
      for (const [dq, dr] of dirs) {
        const key = coordKey(cell.q + dq, cell.r + dr);
        if (state.cells.has(key)) keys.push(key);
      }
      return keys;
    }

    function computeReachable(player) {
      const reachable = new Map();
      const startKey = coordKey(player.q, player.r);
      const maxCost = player.movement;
      const queue = [{ key: startKey, spent: 0 }];
      reachable.set(startKey, 0);
      while (queue.length) {
        const { key, spent } = queue.shift();
        const cell = state.cells.get(key);
        for (const nKey of neighborKeys(cell)) {
          const neighbor = state.cells.get(nKey);
          const step = terrainTable[neighbor.terrain].cost;
          const cost = spent + step;
          if (cost > maxCost) continue;
          if (!reachable.has(nKey) || cost < reachable.get(nKey)) {
            reachable.set(nKey, cost);
            queue.push({ key: nKey, spent: cost });
          }
        }
      }
      reachable.delete(startKey);
      return reachable;
    }

    function computePaths(startKey) {
      const dist = new Map([[startKey, 0]]);
      const prev = new Map();
      const frontier = [startKey];
      while (frontier.length) {
        frontier.sort((a, b) => dist.get(a) - dist.get(b));
        const key = frontier.shift();
        const cell = state.cells.get(key);
        for (const nKey of neighborKeys(cell)) {
          const step = terrainTable[state.cells.get(nKey).terrain].cost;
          const nextCost = dist.get(key) + step;
          if (!dist.has(nKey) || nextCost < dist.get(nKey)) {
            dist.set(nKey, nextCost);
            prev.set(nKey, key);
            frontier.push(nKey);
          }
        }
      }
      return { dist, prev };
    }

    function pathFromPrev(prev, targetKey, startKey) {
      const path = [];
      let cur = targetKey;
      while (cur && cur !== startKey) {
        path.push(cur);
        cur = prev.get(cur);
      }
      path.reverse();
      return path;
    }

    function findNearestBug(player) {
      const startKey = coordKey(player.q, player.r);
      const { dist, prev } = computePaths(startKey);
      let best = null;
      state.bugs.forEach(bug => {
        const cost = dist.get(bug.cell);
        if (cost === undefined) return;
        if (bugInFight(bug.id)) return;
        if (!best || cost < best.cost) {
          best = { bug, cost };
        }
      });
      if (!best) return null;
      const path = pathFromPrev(prev, best.bug.cell, startKey);
      return { bug: best.bug, path, cost: best.cost };
    }

    function setActivePlayer(id) {
      state.activePlayer = id;
      state.reachable.clear();
      state.lastMoveRoll = null;
      render();
    }

    function activePlayerObj() {
      return state.players.find(p => p.id === state.activePlayer) || null;
    }

    function rollMove() {
      const player = activePlayerObj();
      if (!player) return;
      if (state.timer.remaining <= 0) {
        log("Start the Day before rolling movement.");
        return;
      }
      if (state.fights[player.id]) {
        log(player.name + " is mid-fight; resolve it first.");
        return;
      }
      const roll = 1 + Math.floor(Math.random() * 6);
      player.movement = roll;
      state.lastMoveRoll = roll;
      state.reachable = computeReachable(player);
      log(player.name + " rolled " + roll + " movement.");
      render();
    }

    function autoRoll(player) {
      const roll = 1 + Math.floor(Math.random() * 6);
      player.movement = roll;
      if (state.activePlayer === player.id) {
        state.lastMoveRoll = roll;
        state.reachable = computeReachable(player);
      }
      log(player.name + " auto-rolled " + roll + " movement.");
    }

    function endMovement() {
      const player = activePlayerObj();
      if (!player) return;
      player.movement = 0;
      state.reachable.clear();
      state.lastMoveRoll = null;
      render();
    }

    function handleCellClick(key) {
      const player = activePlayerObj();
      if (!player || player.movement <= 0) return;
      if (!state.reachable.has(key)) return;
      const cost = state.reachable.get(key);
      player.q = parseInt(key.split(",")[0], 10);
      player.r = parseInt(key.split(",")[1], 10);
      player.movement = Math.max(0, player.movement - cost);
      state.reachable = computeReachable(player);
      const cell = state.cells.get(key);
      if (player.q === 0 && player.r === 0) healIfCamp(player);
      if (cell.bugId && !bugInFight(cell.bugId)) {
        player.movement = 0;
        state.reachable.clear();
        startFight(player, state.bugs.get(cell.bugId));
      }
      render();
    }

    function bugInFight(bugId) {
      return Object.values(state.fights).some(f => f.bugId === bugId);
    }

    function startFight(player, bug) {
      if (bugInFight(bug.id)) return;
      const hitsNeeded = bug.size === "L" ? 2 : 1;
      state.fights[player.id] = { playerId: player.id, bugId: bug.id, hits: 0, hitsNeeded };
      const ps = state.stats.players[player.id];
      if (ps) ps.fights += 1;
      log(player.name + " engages a " + bug.name + " (size " + bug.size + ", target " + bug.target + "+, sting " + bug.sting + ").");
      render();
    }

    function resolveFight(playerId) {
      const fight = state.fights[playerId] || null;
      if (!fight) return;
      const player = state.players.find(p => p.id === fight.playerId);
      const bug = state.bugs.get(fight.bugId);
      if (!player || !bug) {
        delete state.fights[playerId];
        render();
        return;
      }
      const roll = 1 + Math.floor(Math.random() * 6);
      let msg = player.name + " rolls " + roll + " vs " + bug.name + ". ";
      if (roll <= 3) {
        player.hp -= 1;
        msg += "Rolled low (1-3), lose 1 HP (" + player.hp + " HP left).";
        const ps = state.stats.players[player.id];
        if (ps) { ps.lowRolls += 1; ps.damageTaken += 1; }
        if (player.hp <= 0) {
          msg += " Knocked out, returns to Camp.";
          handleKO(player);
        }
      } else if (roll >= bug.target) {
        const ps = state.stats.players[player.id];
        fight.hits += 1;
        msg += "Hit! (" + fight.hits + "/" + fight.hitsNeeded + ") ";
        if (fight.hits >= fight.hitsNeeded) {
          player.score += bug.points;
          if (ps) { ps.hits += 1; ps.bugs[bug.size] += 1; }
          const cell = state.cells.get(bug.cell);
          if (cell) cell.bugId = null;
          state.bugs.delete(bug.id);
          msg += "Captured for " + bug.points + " pts.";
          delete state.fights[playerId];
        }
      } else {
        msg += "Miss, keep rolling.";
        const ps = state.stats.players[player.id];
        if (ps) ps.misses += 1;
      }
      log(msg);
      render();
    }

    function handleKO(player) {
      player.hp = player.maxHp;
      player.q = 0;
      player.r = 0;
      player.movement = 0;
      delete state.fights[player.id];
      state.reachable.clear();
      const ps = state.stats.players[player.id];
      if (ps) ps.kos += 1;
    }

    function healIfCamp(player, silent=false) {
      if (player.q === 0 && player.r === 0 && player.hp < player.maxHp) {
        player.hp = player.maxHp;
        if (!silent) log(player.name + " returns to Camp and fully heals.");
        render();
      }
    }

    function autoAct(player) {
      const fight = state.fights[player.id];
      if (fight) {
        resolveFight(player.id);
        return;
      }
      if (state.timer.remaining <= 0 || !state.timer.running) return;
      if (player.movement <= 0) {
        autoRoll(player);
      }
      if (player.movement <= 0) return;
      const startKey = coordKey(player.q, player.r);
      const target = findNearestBug(player);
      if (!target || target.path.length === 0) return;
      let remaining = player.movement;
      for (const stepKey of target.path) {
        const stepCost = terrainTable[state.cells.get(stepKey).terrain].cost;
        if (remaining < stepCost) break;
        const [q, r] = stepKey.split(",").map(Number);
        player.q = q; player.r = r;
        remaining -= stepCost;
        if (player.q === 0 && player.r === 0) healIfCamp(player, true);
        const cell = state.cells.get(stepKey);
        if (cell.bugId && !bugInFight(cell.bugId)) {
          player.movement = 0;
          state.reachable.clear();
          startFight(player, state.bugs.get(cell.bugId));
          render();
          return;
        }
      }
      player.movement = remaining;
      if (state.activePlayer === player.id) {
        state.reachable = computeReachable(player);
      }
      render();
    }

    function startAuto() {
      if (state.auto.timer) clearInterval(state.auto.timer);
      state.auto.enabled = true;
      state.auto.timer = setInterval(() => {
        if (!state.auto.enabled) return;
        state.players.forEach(p => autoAct(p));
      }, state.auto.intervalMs);
      log("Auto-play on (" + (state.auto.intervalMs / 1000) + "s cadence).");
      render();
    }

    function stopAuto() {
      if (state.auto.timer) {
        clearInterval(state.auto.timer);
        state.auto.timer = null;
      }
      state.auto.enabled = false;
      log("Auto-play off.");
      render();
    }

    function generateReport(narrative) {
      const lines = [];
      lines.push("Festival sim summary (" + state.config.days + " days, radius " + state.config.radius + ")");
      if (narrative && narrative.length) {
        lines.push("");
        narrative.forEach(n => lines.push("- " + n));
      }
      lines.push("");
      const leaderboard = [...state.players].sort((a, b) => b.score - a.score);
      leaderboard.forEach((p, idx) => {
        const ps = state.stats.players[p.id] || {};
        lines.push((idx + 1) + ". " + p.name + " — " + p.score + " pts (S:" + (ps.bugs?.S || 0) + " M:" + (ps.bugs?.M || 0) + " L:" + (ps.bugs?.L || 0) + ")");
        lines.push("   Fights " + (ps.fights || 0) + " | Hits " + (ps.hits || 0) + " | Misses " + (ps.misses || 0) + " | Low rolls " + (ps.lowRolls || 0) + " | DMG taken " + (ps.damageTaken || 0) + " | KOs " + (ps.kos || 0));
      });
      lines.push("");
      lines.push("Bug targeting logic: Hunters pathfind to the nearest reachable bug by movement cost, skipping bugs already claimed in another fight.");
      document.getElementById("simReport").textContent = lines.join("\n");
    }

    function runSimulation() {
      stopAuto();
      clearInterval(state.timer.id);
      state.timer.id = null;
      state.timer.running = false;
      const narrative = [];
      newGame(); // reset board/stats per current inputs
      const step = 0.5; // seconds per sim tick
      state.timer.running = true;
      while (state.day <= state.config.days) {
        state.timer.remaining = state.config.daySeconds;
        let guardDay = 0;
        narrative.push("Day " + state.day + " start (HP: " + state.players.map(p => p.name + " " + p.hp).join(", ") + ")");
        while (state.timer.remaining > 0 && guardDay < 20000) {
          state.players.forEach(p => autoAct(p));
          state.timer.remaining = Math.max(0, state.timer.remaining - step);
          guardDay++;
        }
        narrative.push("Day " + state.day + " end scores: " + state.players.map(p => p.name + " " + p.score + "pts").join(", "));
        endDay("Sim timer");
        if (state.day >= state.config.days) break;
        advanceDay();
        state.timer.running = true;
      }
      state.timer.running = false;
      state.timer.remaining = 0;
      generateReport(narrative);
    }

    function renderBoard() {
      if (!state.cells.size) return;
      const xs = [];
      const ys = [];
      state.centers.forEach(pt => { xs.push(pt.x); ys.push(pt.y); });
      const minX = Math.min(...xs) - HEX_SIZE * 1.2;
      const maxX = Math.max(...xs) + HEX_SIZE * 1.2;
      const minY = Math.min(...ys) - HEX_SIZE * 1.2;
      const maxY = Math.max(...ys) + HEX_SIZE * 1.2;
      const width = maxX - minX;
      const height = maxY - minY;
      boardEl.setAttribute("viewBox", [minX, minY, width, height].join(" "));
      let cellMarkup = "";
      let bugMarkup = "";
      let playerMarkup = "";
      const active = activePlayerObj();
      state.cells.forEach(cell => {
        const center = state.centers.get(cell.key);
        const isReachable = state.reachable.has(cell.key);
        const isActive = active && cell.q === active.q && cell.r === active.r;
        const classes = ["hex", "t-" + cell.terrain];
        if (isReachable) classes.push("reachable");
        if (isActive) classes.push("active");
        if (cell.bugId && bugInFight(cell.bugId)) classes.push("blocked");
        cellMarkup += "<polygon data-key=\"" + cell.key + "\" class=\"" + classes.join(" ") + "\" points=\"" + hexPoints(center.x, center.y, HEX_SIZE - 2) + "\"></polygon>";
        if (cell.bugId) {
          const bug = state.bugs.get(cell.bugId);
          const radius = HEX_SIZE * 0.55;
          const bugClass = bug.size === "S" ? "bug-s" : bug.size === "M" ? "bug-m" : "bug-l";
          bugMarkup += "<g class=\"bug " + bugClass + "\" transform=\"translate(" + (center.x) + "," + (center.y) + ")\">" +
            "<circle r=\"" + radius + "\"></circle>" +
            "<text text-anchor=\"middle\" dominant-baseline=\"middle\" font-size=\"" + (HEX_SIZE * 0.7) + "\" y=\"-2\">" + bug.size + "</text>" +
            "<text text-anchor=\"middle\" dominant-baseline=\"middle\" font-size=\"" + (HEX_SIZE * 0.32) + "\" y=\"" + (HEX_SIZE * 0.45) + "\">" + bug.target + "+/" + bug.points + "pt</text>" +
          "</g>";
        }
      });

      state.players.forEach((p, idx) => {
        const center = state.centers.get(coordKey(p.q, p.r));
        if (!center) return;
        const colorClass = "player-" + (idx + 1);
        playerMarkup += "<g class=\"player-token " + colorClass + "\" transform=\"translate(" + center.x + "," + center.y + ")\">" +
          "<rect x=\"" + (-HEX_SIZE * 0.45) + "\" y=\"" + (-HEX_SIZE * 0.45) + "\" rx=\"8\" ry=\"8\" width=\"" + (HEX_SIZE * 0.9) + "\" height=\"" + (HEX_SIZE * 0.9) + "\"></rect>" +
          "<text text-anchor=\"middle\" dominant-baseline=\"middle\" font-size=\"" + (HEX_SIZE * 0.4) + "\" y=\"-2\">" + (idx + 1) + "</text>" +
          "<text text-anchor=\"middle\" dominant-baseline=\"middle\" font-size=\"" + (HEX_SIZE * 0.25) + "\" y=\"" + (HEX_SIZE * 0.35) + "\">" + p.hp + "hp</text>" +
        "</g>";
      });

      boardEl.innerHTML = "<g>" + cellMarkup + "</g><g>" + bugMarkup + "</g><g>" + playerMarkup + "</g>";
    }

    function renderPlayers() {
      playersEl.innerHTML = state.players.map((p, idx) => {
        const activeClass = p.id === state.activePlayer ? "active" : "";
        return "<div class=\"player-row " + activeClass + "\" data-player=\"" + p.id + "\">" +
          "<div>" +
            "<div><strong>" + p.name + "</strong></div>" +
            "<div class=\"player-meta\">" +
              "<span class=\"stat\">HP " + p.hp + "/" + p.maxHp + "</span>" +
              "<span class=\"stat\">Score " + p.score + "</span>" +
              "<span class=\"stat\">Pos " + p.q + "," + p.r + "</span>" +
              "<span class=\"stat\">Move " + p.movement + "</span>" +
            "</div>" +
          "</div>" +
          "<div class=\"pill\">P" + (idx + 1) + "</div>" +
        "</div>";
      }).join("");
    }

    function renderFightBox() {
      const fightEntries = Object.values(state.fights)
        .map(f => {
          const player = state.players.find(p => p.id === f.playerId);
          const bug = state.bugs.get(f.bugId);
          if (!player || !bug) return null;
          return { player, bug };
        })
        .filter(Boolean);

      if (!fightEntries.length) {
        fightBox.innerHTML = "<p class=\"mini\">Enter a bug hex to start a fight. Size gates: S 4+, M 5+, L 6+ (Large needs 2 hits). Rolling 1-3 costs you 1 HP. Walk to Camp (0,0) to fully heal.</p>";
        return;
      }

      fightBox.innerHTML = fightEntries.map(({ player, bug }) => {
        return "<div style=\"margin-bottom:10px; border-bottom:1px dashed var(--stroke); padding-bottom:8px;\">" +
          "<h4>Fight: " + player.name + " vs " + bug.name + "</h4>" +
          "<div class=\"player-meta\" style=\"margin-bottom:8px;\">" +
            "<span class=\"stat\">Target " + bug.target + "+</span>" +
            "<span class=\"stat\">Sting " + bug.sting + "</span>" +
            "<span class=\"stat\">Value " + bug.points + "pt</span>" +
          "</div>" +
          "<div class=\"actions\">" +
            "<button data-fightroll=\"" + player.id + "\">Roll (" + player.name + ")</button>" +
            "<button class=\"secondary\" data-campheal=\"" + player.id + "\">Full heal (Camp only)</button>" +
          "</div>" +
        "</div>";
      }).join("");
    }

    function renderStatus() {
      const player = activePlayerObj();
      const fight = player ? state.fights[player.id] : null;
      let status = [];
      if (player) status.push("Active: " + player.name);
      if (state.lastMoveRoll) status.push("Move roll: " + state.lastMoveRoll);
      if (player && player.movement > 0) status.push("Movement left: " + player.movement);
      if (fight) status.push("Fight in progress");
      if (state.auto.enabled) status.push("Auto");
      boardStatus.textContent = status.join(" • ");
      turnInfo.textContent = status.join(" • ") || "Ready";
    }

    function render() {
      updateTimerUI();
      renderBoard();
      renderPlayers();
      renderFightBox();
      renderStatus();
    }

    document.getElementById("newGame").addEventListener("click", newGame);
    document.getElementById("resetBtn").addEventListener("click", () => {
      state.players.forEach(p => { p.score = 0; p.hp = p.maxHp; p.q = 0; p.r = 0; p.movement = 0; });
      log("Scores and positions reset.");
      render();
    });
    document.getElementById("startBtn").addEventListener("click", startDay);
    document.getElementById("pauseBtn").addEventListener("click", pauseDay);
    document.getElementById("advanceBtn").addEventListener("click", advanceDay);
    document.getElementById("autoBtn").addEventListener("click", () => {
      if (state.auto.enabled) {
        stopAuto();
      } else {
        startAuto();
      }
      document.getElementById("autoBtn").textContent = "Auto-play: " + (state.auto.enabled ? "On" : "Off");
    });
    document.getElementById("rollMove").addEventListener("click", rollMove);
    document.getElementById("endMove").addEventListener("click", endMovement);
    document.getElementById("simRun").addEventListener("click", runSimulation);
    document.getElementById("simClear").addEventListener("click", () => {
      document.getElementById("simReport").textContent = "Report cleared. Run a full sim to regenerate.";
    });

    boardEl.addEventListener("click", (e) => {
      const key = e.target.getAttribute("data-key");
      if (!key) return;
      handleCellClick(key);
    });

    playersEl.addEventListener("click", (e) => {
      const card = e.target.closest("[data-player]");
      if (!card) return;
      setActivePlayer(card.getAttribute("data-player"));
    });

    fightBox.addEventListener("click", (e) => {
      const rollId = e.target.getAttribute("data-fightroll");
      if (rollId) {
        resolveFight(rollId);
        return;
      }
      const healId = e.target.getAttribute("data-campheal");
      if (healId) {
        const player = state.players.find(p => p.id === healId);
        if (player) healIfCamp(player);
      }
    });

    newGame();
  </script>
</body>
</html>
