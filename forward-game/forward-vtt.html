<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Forward ‚Äî Playtest Table + Inline Editor (Self‚ÄëContained)</title>
  <style>
    :root {
      color-scheme: light dark;
      --border: rgba(127,127,127,.35);
      --muted: rgba(127,127,127,.75);
      --panel: rgba(127,127,127,.08);
      --panel2: rgba(127,127,127,.12);
      --focus: rgba(0, 120, 212, .35);
      --card-bg: rgba(255,255,255,.92);
      --card-fg: rgba(0,0,0,.92);
      --table-bg: rgba(127,127,127,.06);
      --shadow: 0 8px 20px rgba(0,0,0,.18);
      --radius: 10px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      --card-w: 140px;
      --card-h: 196px;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --card-bg: rgba(15,15,15,.92);
        --card-fg: rgba(255,255,255,.92);
        --shadow: 0 10px 26px rgba(0,0,0,.45);
      }
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: var(--sans);
    }

    body {
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }

    header h1 {
      font-size: 14px;
      margin: 0;
      font-weight: 600;
      letter-spacing: .2px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }

    button {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      background: transparent;
      cursor: pointer;
      font: inherit;
    }

    button:hover { background: var(--panel2); }

    button:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }

    .file {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px dashed var(--border);
      border-radius: 8px;
      padding: 4px 8px;
    }

    .file label {
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }

    .file input { font-size: 12px; max-width: 240px; }

    main {
      display: grid;
      grid-template-columns: 1fr;
      height: calc(100vh - 52px - 52px);
      min-height: 420px;
    }

    .drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.28);
      display: none;
      z-index: 50;
    }

    .drawer {
      position: fixed;
      top: 52px;
      right: 0;
      bottom: 0;
      width: 360px;
      max-width: 92vw;
      background: var(--card-bg);
      border-left: 1px solid var(--border);
      transform: translateX(100%);
      transition: transform 160ms ease;
      z-index: 60;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .drawer.open {
      transform: translateX(0);
    }

    .drawer.open + .drawer-backdrop {
      display: block;
    }

    .drawer .panel-head {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .drawer .panel-head h2 {
      margin: 0;
      font-size: 12px;
      letter-spacing: .2px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .drawer .panel-body {
      padding: 10px 12px;
      overflow: auto;
      min-width: 0;
      flex: 1;
    }

    .panel .panel-head {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel .panel-head h2 {
      margin: 0;
      font-size: 12px;
      letter-spacing: .2px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .panel .panel-body {
      padding: 10px 12px;
      overflow: auto;
      min-width: 0;
      flex: 1;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    .search {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    input[type="text"], textarea, select {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      background: transparent;
      font: inherit;
      min-width: 0;
    }

    textarea {
      resize: vertical;
      min-height: 90px;
      font-family: var(--sans);
    }

    .list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 8px;
    }

    .card-row {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px;
      background: rgba(127,127,127,.06);
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: start;
    }

    .card-row .title {
      font-weight: 600;
      font-size: 13px;
      line-height: 1.2;
      margin-bottom: 3px;
    }

    .card-row .meta {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.2;
    }

    .card-row .actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .card-row button {
      padding: 4px 8px;
      font-size: 12px;
    }

    .stack {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: rgba(127,127,127,.06);
      display: grid;
      grid-template-columns: 54px 1fr;
      gap: 10px;
      align-items: center;
    }

    .stack .thumb {
      width: 54px;
      height: 76px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: repeating-linear-gradient(
        45deg,
        rgba(127,127,127,.14),
        rgba(127,127,127,.14) 10px,
        rgba(127,127,127,.06) 10px,
        rgba(127,127,127,.06) 20px
      );
      box-shadow: 0 6px 16px rgba(0,0,0,.18);
      position: relative;
    }

    .stack .count {
      position: absolute;
      right: 6px;
      bottom: 6px;
      font-family: var(--mono);
      font-size: 11px;
      color: var(--card-fg);
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.18);
      padding: 1px 6px;
      border-radius: 999px;
    }

    .stack .name {
      font-weight: 700;
      font-size: 13px;
      line-height: 1.15;
      margin-bottom: 2px;
    }

    .stack .sub {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.2;
      margin-bottom: 8px;
    }

    .stack .buttons {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    details {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(127,127,127,.06);
      padding: 8px;
      margin-top: 10px;
    }

    summary {
      cursor: pointer;
      user-select: none;
      font-size: 12px;
      color: var(--muted);
      outline: none;
    }

    .workspace {
      position: relative;
      background: var(--table-bg);
      overflow: hidden;
    }

    .table {
      position: absolute;
      inset: 0;
    }

    .table-grid {
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(to right, rgba(127,127,127,.08) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(127,127,127,.08) 1px, transparent 1px);
      background-size: 40px 40px;
      pointer-events: none;
    }

    .table-help {
      position: absolute;
      left: 12px;
      bottom: 12px;
      font-size: 12px;
      color: var(--muted);
      background: rgba(127,127,127,.10);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      max-width: 520px;
      line-height: 1.35;
    }

    .table-help code { font-family: var(--mono); font-size: 11px; }

    .card {
      position: absolute;
      width: var(--card-w);
      height: var(--card-h);
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--card-fg);
      box-shadow: var(--shadow);
      user-select: none;
      overflow: hidden;
      transform-origin: center center;
      touch-action: none;
    }

    .card.selected {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }

    .card .inner {
      padding: 10px 10px 8px;
      height: 100%;
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 6px;
    }

    .card .top {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: baseline;
    }

    .card .num {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
    }

    .card .type {
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      max-width: 110px;
    }

    .card .title {
      font-weight: 700;
      font-size: 13px;
      line-height: 1.15;
    }

    .card .loc {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.1;
    }

    .card .body {
      font-size: 11px;
      line-height: 1.25;
      overflow: hidden;
      white-space: pre-wrap;
      border-top: 1px solid rgba(127,127,127,.25);
      padding-top: 6px;
    }

    .card .foot {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      color: var(--muted);
      font-size: 10px;
    }

    .card.back {
      background: repeating-linear-gradient(
        45deg,
        rgba(127,127,127,.14),
        rgba(127,127,127,.14) 10px,
        rgba(127,127,127,.06) 10px,
        rgba(127,127,127,.06) 20px
      );
      color: transparent;
    }

    .card.back .inner {
      opacity: 0;
    }

    .tabs {
      display: flex;
      gap: 6px;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
    }

    .tab {
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 12px;
      background: transparent;
      cursor: pointer;
    }

    .tab.active {
      background: rgba(127,127,127,.14);
      border-style: solid;
    }

    .form {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .row2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .field label {
      display: block;
      font-size: 11px;
      color: var(--muted);
      margin: 0 0 4px;
    }

    .statusline {
      font-size: 12px;
      color: var(--muted);
      padding: 6px 12px;
      border-top: 1px solid var(--border);
      background: rgba(127,127,127,.06);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .kbd {
      font-family: var(--mono);
      font-size: 11px;
      padding: 1px 5px;
      border: 1px solid var(--border);
      border-bottom-width: 2px;
      border-radius: 6px;
      background: rgba(127,127,127,.08);
    }

    .danger { border-color: rgba(200,80,80,.6); }

    /* Combat footer bar */
    .combat-footer {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 8px 16px;
      border-top: 1px solid var(--border);
      background: var(--card-bg);
      font-size: 12px;
      flex-wrap: wrap;
    }

    .combat-footer .trackers {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .combat-footer .tracker {
      display: flex;
      align-items: center;
      gap: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px 8px;
    }

    .combat-footer .tracker-label {
      font-weight: 600;
      font-size: 11px;
      color: var(--muted);
    }

    .combat-footer .tracker-value {
      font-family: var(--mono);
      font-size: 14px;
      font-weight: 700;
      min-width: 24px;
      text-align: center;
    }

    .combat-footer .tracker-btn {
      padding: 2px 6px;
      font-size: 12px;
      line-height: 1;
      border-radius: 4px;
    }

    .combat-footer .dice-area {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-left: auto;
    }

    .combat-footer .roll-btn {
      padding: 6px 12px;
      font-weight: 600;
    }

    .combat-footer .roll-result {
      font-family: var(--mono);
      font-size: 18px;
      font-weight: 700;
      min-width: 28px;
      text-align: center;
      padding: 4px 8px;
      border-radius: 6px;
      background: var(--panel2);
    }

    .combat-footer .combat-log {
      flex: 1;
      min-width: 200px;
      max-width: 400px;
      height: 32px;
      overflow: hidden;
      font-size: 11px;
      color: var(--muted);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 8px;
      background: var(--panel);
    }

    .combat-footer .combat-log-inner {
      display: flex;
      flex-direction: column-reverse;
      gap: 2px;
    }

    .combat-footer .log-entry {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tracker-health .tracker-value { color: #e55; }
    .tracker-resolve .tracker-value { color: #5a5; }
    .tracker-dread .tracker-value { color: #a5a; }
    .tracker-grace .tracker-value { color: #5af; }

    @media (max-width: 760px) {
      .workspace { min-height: 520px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Forward ‚Äî VTT + Inline Editor</h1>

    <div class="toolbar">
      <span class="file">
        <label for="cardsFile">Cards CSV</label>
        <input id="cardsFile" type="file" accept=".csv,text/csv" />
      </span>

      <span class="file">
        <label for="rulesFile">Rules</label>
        <input id="rulesFile" type="file" accept=".md,.txt,text/plain,text/markdown" />
      </span>

      <button id="autoSetup">Auto Setup (Rules)</button>
      <button id="exportState">Export State (JSON)</button>
      <button id="exportCards">Export Cards (CSV)</button>
      <button id="clearState" class="danger">Reset Local State</button>
    </div>
  </header>

  <main>
    <section class="workspace" aria-label="Tabletop">
      <div id="table" class="table" tabindex="0" aria-label="Playtest table"></div>
      <div class="table-grid" aria-hidden="true"></div>
      <div class="table-help">
        <div><b>Controls</b></div>
        <div>Drag to move. Double‚Äëclick to flip. Click to select. Press <span class="kbd">Delete</span> to remove selected. Press <span class="kbd">F</span> to flip, <span class="kbd">R</span> to rotate 90¬∞, <span class="kbd">E</span> to edit.</div>
        <div style="margin-top:6px">All edits persist in <code>localStorage</code> until you export/reset.</div>
      </div>
    </section>
  </main>

  <!-- Combat Footer Bar -->
  <footer class="combat-footer">
    <div class="trackers">
      <div class="tracker tracker-health">
        <button class="tracker-btn" data-tracker="health" data-delta="-1">‚àí</button>
        <span class="tracker-label">HP</span>
        <span class="tracker-value" id="trackerHealth">20</span>
        <button class="tracker-btn" data-tracker="health" data-delta="1">+</button>
      </div>
      <div class="tracker tracker-resolve">
        <button class="tracker-btn" data-tracker="resolve" data-delta="-1">‚àí</button>
        <span class="tracker-label">Resolve</span>
        <span class="tracker-value" id="trackerResolve">0</span>
        <button class="tracker-btn" data-tracker="resolve" data-delta="1">+</button>
      </div>
      <div class="tracker tracker-dread">
        <button class="tracker-btn" data-tracker="dread" data-delta="-1">‚àí</button>
        <span class="tracker-label">Dread</span>
        <span class="tracker-value" id="trackerDread">0</span>
        <button class="tracker-btn" data-tracker="dread" data-delta="1">+</button>
      </div>
      <div class="tracker tracker-grace">
        <button class="tracker-btn" data-tracker="grace" data-delta="-1">‚àí</button>
        <span class="tracker-label">Grace</span>
        <span class="tracker-value" id="trackerGrace">0</span>
        <button class="tracker-btn" data-tracker="grace" data-delta="1">+</button>
      </div>
    </div>

    <div class="combat-log" id="combatLog">
      <div class="combat-log-inner" id="combatLogInner"></div>
    </div>

    <div class="dice-area">
      <button class="roll-btn" id="rollPlayer">üé≤ Player</button>
      <span class="roll-result" id="rollPlayerResult">‚Äì</span>
      <button class="roll-btn" id="rollEnemy">üé≤ Enemy</button>
      <span class="roll-result" id="rollEnemyResult">‚Äì</span>
      <button class="roll-btn" id="rollBoth">‚öîÔ∏è Both</button>
    </div>
  </footer>

  <aside id="editorDrawer" class="drawer" aria-label="Editor drawer" aria-hidden="true">
    <div class="panel-head">
      <h2>Editor</h2>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
        <button id="closeEditor">Close (E)</button>
      </div>
    </div>

    <div class="tabs" role="tablist" aria-label="Editor tabs">
      <button class="tab active" id="tabCard" role="tab" aria-selected="true">Selected Card</button>
      <button class="tab" id="tabRules" role="tab" aria-selected="false">Rules</button>
    </div>

    <div class="panel-body">
      <div id="cardEditor" class="form" aria-label="Card editor">
        <div class="hint">Select a card on the table, then press <span class="kbd">E</span> to edit it. Edits change the underlying card (all instances update).</div>

        <div class="row2">
          <div class="field">
            <label>Card Number</label>
            <input id="edNumber" type="text" disabled />
          </div>
          <div class="field">
            <label>Type</label>
            <input id="edType" type="text" placeholder="e.g. Beast, Terror, Rest" />
          </div>
        </div>

        <div class="field">
          <label>Title</label>
          <input id="edTitle" type="text" placeholder="Card title" />
        </div>

        <div class="field">
          <label>Associated Location</label>
          <input id="edLoc" type="text" placeholder="e.g. Home Village Termina" />
        </div>

        <div class="field">
          <label>Flavor Text</label>
          <textarea id="edFlavor" placeholder="Flavor text"></textarea>
        </div>

        <div class="field">
          <label>Rules Text</label>
          <textarea id="edRules" placeholder="Rules text"></textarea>
        </div>

        <div class="field">
          <label>Image Source Idea</label>
          <textarea id="edImage" placeholder="Image prompt / source idea"></textarea>
        </div>

        <div style="display:flex; gap:8px; align-items:center;">
          <button id="saveCard">Save Card</button>
          <button id="revertCard">Revert Unsaved</button>
        </div>
      </div>

      <div id="rulesEditor" class="form" style="display:none" aria-label="Rules editor">
        <div class="hint">This is plain text (Markdown allowed, but not rendered here). Import from rules.md and edit inline.</div>
        <div class="field">
          <label>Rules Text</label>
          <textarea id="edRulesDoc" style="min-height: 360px" placeholder="Paste rules here, or import a .md file"></textarea>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="saveRules">Save Rules</button>
          <button id="exportRules">Export Rules (TXT)</button>
        </div>
      </div>
    </div>

    <div id="editorStatus" class="statusline">No selection.</div>
  </aside>
  <div id="drawerBackdrop" class="drawer-backdrop" aria-hidden="true"></div>

  <script>
    "use strict";

    // --- Storage keys ---
    const STORAGE_KEY = "forward_vtt_state_v1";

    // --- App state ---
    /** @type {{ cardsByNumber: Record<string, any>, cardOrder: string[], rulesText: string, instances: any[], piles: Record<string, any>, zones: any[], activeDomain: string, selectedInstanceId: string | null, zTop: number }} */
    let state = {
      cardsByNumber: {},
      cardOrder: [],
      rulesText: "",
      instances: [],
      piles: {},
      zones: [],
      activeDomain: "",
      selectedInstanceId: null,
      zTop: 1,
      // Tracker values
      trackers: {
        health: 20,
        resolve: 0,
        dread: 0,
        grace: 0,
      },
      combatLog: [],
    };

    // Combat reference table (from rules)
    const COMBAT_TABLE = {
      1: { name: "Miss", damage: 0, block: false, desc: "Deal 0" },
      2: { name: "Parry", damage: 0, block: true, desc: "Block all incoming" },
      3: { name: "Hit", damage: 1, block: false, desc: "Deal 1 + ATK" },
      4: { name: "Hit", damage: 1, block: false, desc: "Deal 1 + ATK" },
      5: { name: "Critical", damage: 2, block: false, desc: "Deal 2 + ATK" },
      6: { name: "Counter", damage: 1, block: true, desc: "Block all & deal 1" },
    };

    // --- Elements ---
    const el = {
      table: document.getElementById("table"),
      cardsFile: document.getElementById("cardsFile"),
      rulesFile: document.getElementById("rulesFile"),
      autoSetup: document.getElementById("autoSetup"),

      exportState: document.getElementById("exportState"),
      exportCards: document.getElementById("exportCards"),
      clearState: document.getElementById("clearState"),

      editorDrawer: document.getElementById("editorDrawer"),
      drawerBackdrop: document.getElementById("drawerBackdrop"),
      closeEditor: document.getElementById("closeEditor"),

      tabCard: document.getElementById("tabCard"),
      tabRules: document.getElementById("tabRules"),
      cardEditor: document.getElementById("cardEditor"),
      rulesEditor: document.getElementById("rulesEditor"),

      edNumber: document.getElementById("edNumber"),
      edType: document.getElementById("edType"),
      edTitle: document.getElementById("edTitle"),
      edLoc: document.getElementById("edLoc"),
      edFlavor: document.getElementById("edFlavor"),
      edRules: document.getElementById("edRules"),
      edImage: document.getElementById("edImage"),
      saveCard: document.getElementById("saveCard"),
      revertCard: document.getElementById("revertCard"),

      edRulesDoc: document.getElementById("edRulesDoc"),
      saveRules: document.getElementById("saveRules"),
      exportRules: document.getElementById("exportRules"),

      editorStatus: document.getElementById("editorStatus"),

      // Combat footer elements
      trackerHealth: document.getElementById("trackerHealth"),
      trackerResolve: document.getElementById("trackerResolve"),
      trackerDread: document.getElementById("trackerDread"),
      trackerGrace: document.getElementById("trackerGrace"),
      combatLog: document.getElementById("combatLog"),
      combatLogInner: document.getElementById("combatLogInner"),
      rollPlayer: document.getElementById("rollPlayer"),
      rollEnemy: document.getElementById("rollEnemy"),
      rollBoth: document.getElementById("rollBoth"),
      rollPlayerResult: document.getElementById("rollPlayerResult"),
      rollEnemyResult: document.getElementById("rollEnemyResult"),
    };

    // --- Utilities ---
    function nowId() {
      return "i_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function getCardSize() {
      const cs = getComputedStyle(document.documentElement);
      const w = parseInt(cs.getPropertyValue("--card-w"), 10) || 140;
      const h = parseInt(cs.getPropertyValue("--card-h"), 10) || 196;
      return { w, h };
    }

    function getInstanceBoxForRotation(rot) {
      const { w, h } = getCardSize();
      const r = ((rot || 0) % 360 + 360) % 360;
      const sideways = r % 180 !== 0;
      return sideways ? { w: h, h: w } : { w, h };
    }

    function getActiveRowSlotPositions() {
      const { w: cardW } = getCardSize();
      const gap = 60;

      const deckZ = (state.zones || []).find(z => z.id === "zone:activeDeck");
      const discardZ = (state.zones || []).find(z => z.id === "zone:activeDiscard");

      const deckX = deckZ?.x ?? 540;
      const deckY = deckZ?.y ?? 232;
      const deckH = deckZ?.h ?? 92;
      const discardX = discardZ?.x ?? (deckX + 200);
      const discardW = discardZ?.w ?? 180;

      const centerX = (deckX + (discardX + discardW)) / 2;
      const rowY = deckY + deckH + 96;

      const totalW = 3 * cardW + 2 * gap;
      const startX = Math.round(centerX - totalW / 2);

      return [
        { x: startX, y: rowY },
        { x: startX + cardW + gap, y: rowY },
        { x: startX + 2 * (cardW + gap), y: rowY },
      ];
    }

    function downloadText(filename, text, mime = "text/plain") {
      const blob = new Blob([text], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function escapeCsvValue(value) {
      const s = (value ?? "").toString();
      if (/[\n\r",]/.test(s)) return '"' + s.replace(/"/g, '""') + '"';
      return s;
    }

    // RFC4180-ish CSV parser supporting quoted fields + newlines in quotes.
    function parseCsv(text) {
      const rows = [];
      let row = [];
      let field = "";
      let inQuotes = false;

      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        const next = text[i + 1];

        if (inQuotes) {
          if (c === '"' && next === '"') {
            field += '"';
            i++;
            continue;
          }
          if (c === '"') {
            inQuotes = false;
            continue;
          }
          field += c;
          continue;
        }

        if (c === '"') {
          inQuotes = true;
          continue;
        }

        if (c === ",") {
          row.push(field);
          field = "";
          continue;
        }

        if (c === "\n") {
          row.push(field);
          field = "";
          rows.push(row);
          row = [];
          continue;
        }

        if (c === "\r") {
          // ignore
          continue;
        }

        field += c;
      }

      row.push(field);
      rows.push(row);
      return rows;
    }

    function normalizeHeader(header) {
      return (header ?? "")
        .toString()
        .trim()
        .toLowerCase()
        .replace(/\s+/g, " ")
        .replace(/[^a-z0-9_ ]/g, "")
        .replace(/ /g, "_");
    }

    // Supports both cardlist.csv and cardlist_all.csv header orders.
    function csvRowsToCards(rows) {
      if (!rows.length) return { cardsByNumber: {}, cardOrder: [] };
      const header = rows[0].map(normalizeHeader);
      const idx = (name) => header.indexOf(name);

      // expected normalized names
      const iNumber = idx("card_number");
      const iType = idx("type");
      const iTitle = idx("title");
      const iLoc = idx("associated_location");
      const iFlavor = idx("flavor_text");
      const iRules = idx("rules_text");
      const iImage = idx("image_source_idea");

      const cardsByNumber = {};
      const cardOrder = [];

      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        if (!row || row.length === 0) continue;

        const number = (row[iNumber] ?? "").toString().trim();
        if (!number) continue;

        const card = {
          number,
          type: (row[iType] ?? "").toString(),
          title: (row[iTitle] ?? "").toString(),
          location: (row[iLoc] ?? "").toString(),
          flavor: (row[iFlavor] ?? "").toString(),
          rules: (row[iRules] ?? "").toString(),
          imageIdea: (row[iImage] ?? "").toString(),
        };

        cardsByNumber[number] = card;
        cardOrder.push(number);
      }

      // stable numeric sort if possible
      cardOrder.sort((a, b) => (parseInt(a, 10) || 0) - (parseInt(b, 10) || 0));
      return { cardsByNumber, cardOrder };
    }

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch {
        // ignore
      }
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return;
        state = {
          cardsByNumber: parsed.cardsByNumber ?? {},
          cardOrder: parsed.cardOrder ?? [],
          rulesText: parsed.rulesText ?? "",
          instances: parsed.instances ?? [],
          piles: parsed.piles ?? {},
          zones: parsed.zones ?? [],
          activeDomain: parsed.activeDomain ?? "",
          selectedInstanceId: parsed.selectedInstanceId ?? null,
          zTop: parsed.zTop ?? 1,
        };
      } catch {
        // ignore
      }
    }

    function setStatus(text) {
      el.editorStatus.textContent = text;
    }

    function getSelectedInstance() {
      if (!state.selectedInstanceId) return null;
      return state.instances.find(i => i.id === state.selectedInstanceId) ?? null;
    }

    function bringToFront(instance) {
      state.zTop = (state.zTop || 1) + 1;
      instance.z = state.zTop;
    }

    // --- Rendering ---

    function escapeHtmlText(s) {
      return (s ?? "").toString()
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function escapeHtmlAttr(s) {
      return escapeHtmlText(s).replace(/"/g, "&quot;");
    }

    function getDomainPileIds() {
      const piles = state.piles || {};
      return Object.keys(piles).filter(k => k.startsWith("domain:"));
    }

    function getDomainNamesFromPiles() {
      return getDomainPileIds().map(id => id.slice("domain:".length));
    }

    function getActiveDomain() {
      const domains = getDomainNamesFromPiles();
      if (state.activeDomain && domains.includes(state.activeDomain)) return state.activeDomain;
      if (domains.includes("Home Village Termina")) return "Home Village Termina";
      return domains[0] || "";
    }

    function setActiveDomain(domain) {
      state.activeDomain = domain;

      // Keep the active deck zone pointed at the current domain pile.
      const z = (state.zones || []).find(z => z.id === "zone:activeDeck");
      if (z) {
        z.pileId = domain ? `domain:${domain}` : "";
        z.subtitle = domain || "";
      }

      // Also move the visible title card (Location) into the exploration area if present.
      if (domain) {
        const titleCard = state.cardOrder
          .map(n => state.cardsByNumber[n])
          .find(c => (c?.type || "").toLowerCase().includes("location") && (c?.title || "").trim() === domain);
        if (titleCard) {
          // Remove any existing active title.
          state.instances = (state.instances || []).filter(i => i.role !== "activeTitle");

          const deckZ = (state.zones || []).find(z => z.id === "zone:activeDeck");
          const discardZ = (state.zones || []).find(z => z.id === "zone:activeDiscard");
          const { h: cardH } = getCardSize();
          const deckX = deckZ?.x ?? 540;
          const deckW = deckZ?.w ?? 180;
          const discardX = discardZ?.x ?? (deckX + 220);
          const discardW = discardZ?.w ?? 180;
          const groupCenterX = (deckX + (discardX + discardW)) / 2;
          const { w: cardW } = getCardSize();
          const titleX = Math.round(groupCenterX - cardW / 2);
          const titleY = (deckZ?.y ?? 232) - cardH - 16;
          state.instances.push({
            id: nowId(),
            cardNumber: titleCard.number,
            x: titleX,
            y: titleY,
            z: ++state.zTop,
            faceUp: true,
            rot: 0,
            role: "activeTitle",
          });
        }
      }

      saveState();
      renderTable();
      setStatus(domain ? `Active domain set to ${domain}.` : "Active domain cleared.");
    }

    function drawFromPileId(pileId, options = {}) {
      const pile = state.piles?.[pileId];
      if (!pile?.cards?.length) {
        setStatus(`${pile?.name || pileId}: empty.`);
        return;
      }

      const cardNumber = pile.cards.shift();
      const faceUp = options.faceUp ?? (pile.faceUp !== false);
      const x = options.x ?? 760;
      const y = options.y ?? 420;

      const inst = {
        id: nowId(),
        cardNumber,
        x: Math.round(x),
        y: Math.round(y),
        z: ++state.zTop,
        faceUp,
        rot: 0,
        ...(options.extra ?? {}),
      };

      state.instances.push(inst);
      state.selectedInstanceId = inst.id;
      saveState();
      renderTable();
      renderEditors();
      const c = state.cardsByNumber[cardNumber];
      setStatus(`Drew #${cardNumber}${c?.title ? " ‚Äî " + c.title : ""}.`);
    }

    function refillActiveRow() {
      const domain = getActiveDomain();
      if (!domain) {
        alert("No active domain pile found. Run Auto Setup (Rules) first.");
        return;
      }

      const pileId = `domain:${domain}`;
      const slotPos = getActiveRowSlotPositions();

      const existing = new Set((state.instances || []).filter(i => i.activeRowSlot !== undefined).map(i => i.activeRowSlot));
      for (let s = 0; s < 3; s++) {
        if (existing.has(s)) continue;
        drawFromPileId(pileId, {
          faceUp: false,
          x: slotPos[s].x,
          y: slotPos[s].y,
          extra: { activeRowSlot: s },
        });
      }
    }

    // (Left panel stacks/library removed ‚Äî table zones are the play interface.)

    function renderTable() {
      el.table.innerHTML = "";

      const { w: cardW, h: cardH } = getCardSize();

      // Render zones/piles first (so cards appear above them).
      for (const z of (state.zones || [])) {
        const zoneDiv = document.createElement("div");
        zoneDiv.dataset.zoneId = z.id;
        zoneDiv.style.position = "absolute";
        zoneDiv.style.left = (z.x || 0) + "px";
        zoneDiv.style.top = (z.y || 0) + "px";
        zoneDiv.style.width = (z.w || 160) + "px";
        zoneDiv.style.height = (z.h || 110) + "px";
        zoneDiv.style.border = "1px dashed var(--border)";
        zoneDiv.style.borderRadius = "12px";
        zoneDiv.style.background = "rgba(127,127,127,.06)";
        zoneDiv.style.padding = "8px";
        zoneDiv.style.boxSizing = "border-box";
        zoneDiv.style.zIndex = "0";
        zoneDiv.style.pointerEvents = "auto";
        zoneDiv.style.overflow = "hidden";

        const pile = (state.piles || {})[z.pileId];
        const count = pile?.cards?.length ?? 0;
        const subtitle = z.subtitle ? `<div style="font-size:11px;color:var(--muted);line-height:1.15;">${escapeHtmlText(z.subtitle)}</div>` : "";

        const isDomainZone = (z.id || "").startsWith("zone:domain:");
        const controls = z.pileId ? `
          <div style="display:flex;gap:6px;align-items:center;flex:0 0 auto;flex-wrap:wrap;">
            <button data-zone-action="draw" data-zone="${escapeHtmlAttr(z.id)}" style="padding:4px 8px;font-size:12px;">Draw</button>
            <button data-zone-action="shuffle" data-zone="${escapeHtmlAttr(z.id)}" style="padding:4px 8px;font-size:12px;">Shuffle</button>
          </div>
        ` : "";

        zoneDiv.innerHTML = isDomainZone ? `
          <div style="display:flex;justify-content:space-between;gap:8px;align-items:flex-start;">
            <div style="flex:1 1 auto;min-width:0;">
              <div style="font-size:12px;font-weight:700;line-height:1.15;overflow-wrap:anywhere;">${escapeHtmlText(z.name || "Zone")}</div>
              ${subtitle}
              <div style="font-size:11px;color:var(--muted);font-family:var(--mono);">${z.pileId ? `${count} cards` : ""}</div>
            </div>
          </div>
          ${controls ? `<div style="margin-top:8px;">${controls}</div>` : ""}
        ` : `
          <div style="display:flex;justify-content:space-between;gap:8px;align-items:flex-start;">
            <div style="flex:1 1 auto;min-width:0;">
              <div style="font-size:12px;font-weight:700;line-height:1.15;overflow-wrap:anywhere;">${escapeHtmlText(z.name || "Zone")}</div>
              ${subtitle}
              <div style="font-size:11px;color:var(--muted);font-family:var(--mono);">${z.pileId ? `${count} cards` : ""}</div>
            </div>
            ${controls}
          </div>
        `;

        zoneDiv.querySelectorAll("button[data-zone-action]").forEach(btn => {
          btn.addEventListener("click", () => {
            const action = btn.getAttribute("data-zone-action");
            const zoneId = btn.getAttribute("data-zone");
            if (!zoneId) return;
            if (action === "draw") drawFromZone(zoneId);
            if (action === "shuffle") shuffleZone(zoneId);
          });
        });

        // Drag-to-move zones (domain stacks + active deck/discard).
        zoneDiv.addEventListener("pointerdown", (e) => {
          if (e.button !== 0) return;
          // Don't start a drag when clicking the Draw/Shuffle buttons.
          if (e.target && e.target.closest && e.target.closest("button")) return;

          e.preventDefault();
          const startX = e.clientX;
          const startY = e.clientY;
          const startLeft = z.x || 0;
          const startTop = z.y || 0;

          zoneDiv.setPointerCapture(e.pointerId);

          const onMove = (ev) => {
            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;
            z.x = clamp(startLeft + dx, -6000, 6000);
            z.y = clamp(startTop + dy, -6000, 6000);
            zoneDiv.style.left = z.x + "px";
            zoneDiv.style.top = z.y + "px";
          };

          const onUp = (ev) => {
            zoneDiv.releasePointerCapture(ev.pointerId);
            zoneDiv.removeEventListener("pointermove", onMove);
            zoneDiv.removeEventListener("pointerup", onUp);
            saveState();
          };

          zoneDiv.addEventListener("pointermove", onMove);
          zoneDiv.addEventListener("pointerup", onUp);
        });

        el.table.appendChild(zoneDiv);
      }

      // Sort by z for deterministic layering.
      const instances = [...state.instances].sort((a, b) => (a.z || 0) - (b.z || 0));
      for (const inst of instances) {
        const card = state.cardsByNumber[inst.cardNumber];
        if (!card) continue;

        const div = document.createElement("div");
        div.className = "card" + (inst.faceUp ? "" : " back") + (inst.id === state.selectedInstanceId ? " selected" : "");
        div.style.left = (inst.x || 10) + "px";
        div.style.top = (inst.y || 10) + "px";
        div.style.zIndex = String(inst.z || 1);
        const rot = (inst.rot || 0) % 360;
        div.style.transform = `rotate(${rot}deg)`;
        const box = getInstanceBoxForRotation(rot);
        div.style.width = box.w + "px";
        div.style.height = box.h + "px";
        div.dataset.instanceId = inst.id;

        const bodyText = ((card.flavor || "") + (card.rules ? (card.flavor ? "\n\n" : "") + card.rules : "")).trim();

        div.innerHTML = `
          <div class="inner">
            <div class="top">
              <div class="type">${escapeHtmlText(card.type || "")}</div>
              <div class="num">#${escapeHtmlText(card.number)}</div>
            </div>
            <div>
              <div class="title">${escapeHtmlText(card.title || "")}</div>
              <div class="loc">${escapeHtmlText(card.location || "")}</div>
            </div>
            <div class="body">${escapeHtmlText(bodyText)}</div>
            <div class="foot">
              <span>${inst.faceUp ? "Face up" : "Face down"}</span>
              <span>${rot ? `Rot ${rot}¬∞` : ""}</span>
            </div>
          </div>
        `;

        bindCardInteractions(div, inst);
        el.table.appendChild(div);
      }
    }

    function getZoneById(zoneId) {
      return (state.zones || []).find(z => z.id === zoneId) ?? null;
    }

    function shuffleZone(zoneId) {
      const z = getZoneById(zoneId);
      if (!z?.pileId) return;
      const pile = state.piles?.[z.pileId];
      if (!pile?.cards?.length) return;
      shuffleInPlace(pile.cards);
      saveState();
      renderTable();
      setStatus(`Shuffled ${z.name}.`);
    }

    function drawFromZone(zoneId) {
      const z = getZoneById(zoneId);
      if (!z?.pileId) return;
      const pile = state.piles?.[z.pileId];
      if (!pile?.cards?.length) {
        setStatus(`${z.name}: empty.`);
        return;
      }
      const cardNumber = pile.cards.shift();
      const faceUp = pile.faceUp !== false;

      const spawnX = (z.x || 0) + (z.w || 160) + 20;
      const spawnY = (z.y || 0);
      const inst = {
        id: nowId(),
        cardNumber,
        x: Math.round(spawnX),
        y: Math.round(spawnY),
        z: ++state.zTop,
        faceUp,
        rot: 0,
      };
      state.instances.push(inst);
      state.selectedInstanceId = inst.id;
      saveState();
      renderTable();
      renderEditors();
      const c = state.cardsByNumber[cardNumber];
      setStatus(`Drew #${cardNumber}${c?.title ? " ‚Äî " + c.title : ""} from ${z.name}.`);
    }

    // --- Interaction: table cards ---
    function bindCardInteractions(div, inst) {
      // select + bring to front
      div.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        // Important: don't re-render here (it destroys this element mid-drag).
        selectInstanceNoRerender(inst.id, div);
        bringToFront(inst);
        div.style.zIndex = String(inst.z || 1);

        const startX = e.clientX;
        const startY = e.clientY;
        const startLeft = inst.x || 0;
        const startTop = inst.y || 0;

        div.setPointerCapture(e.pointerId);

        const onMove = (ev) => {
          const dx = ev.clientX - startX;
          const dy = ev.clientY - startY;
          inst.x = clamp(startLeft + dx, -6000, 6000);
          inst.y = clamp(startTop + dy, -6000, 6000);
          div.style.left = inst.x + "px";
          div.style.top = inst.y + "px";
        };

        const onUp = (ev) => {
          div.releasePointerCapture(ev.pointerId);
          div.removeEventListener("pointermove", onMove);
          div.removeEventListener("pointerup", onUp);
          saveState();
        };

        div.addEventListener("pointermove", onMove);
        div.addEventListener("pointerup", onUp);
      });

      div.addEventListener("dblclick", (e) => {
        e.preventDefault();
        inst.faceUp = !inst.faceUp;
        bringToFront(inst);
        saveState();
        renderTable();
      });

      // right-click basic menu via confirm (simple, no custom UI)
      div.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        selectInstance(inst.id);
        const action = prompt("Card action: type one of flip | rotate | delete", "flip");
        if (!action) return;
        const a = action.trim().toLowerCase();
        if (a === "flip") flipSelected();
        else if (a === "rotate") rotateSelected();
        else if (a === "delete") deleteSelected();
      });
    }

    function selectInstance(id) {
      state.selectedInstanceId = id;
      const inst = getSelectedInstance();
      if (!inst) {
        setStatus("No selection.");
        renderEditors();
        saveState();
        renderTable();
        return;
      }

      const card = state.cardsByNumber[inst.cardNumber];
      const title = card?.title ? ` ‚Äî ${card.title}` : "";
      setStatus(`Selected #${inst.cardNumber}${title}`);
      renderEditors();
      saveState();
      renderTable();
    }

    function selectInstanceNoRerender(id, clickedEl = null) {
      state.selectedInstanceId = id;
      const inst = getSelectedInstance();
      if (!inst) {
        setStatus("No selection.");
        renderEditors();
        saveState();
        return;
      }

      const card = state.cardsByNumber[inst.cardNumber];
      const title = card?.title ? ` ‚Äî ${card.title}` : "";
      setStatus(`Selected #${inst.cardNumber}${title}`);
      renderEditors();
      saveState();

      // Update selection styling without rebuilding the DOM.
      el.table.querySelectorAll(".card.selected").forEach(n => n.classList.remove("selected"));
      if (clickedEl) clickedEl.classList.add("selected");
    }

    function deleteSelected() {
      const inst = getSelectedInstance();
      if (!inst) return;
      state.instances = state.instances.filter(i => i.id !== inst.id);
      state.selectedInstanceId = null;
      saveState();
      renderTable();
      renderEditors();
      setStatus("Deleted selected card instance.");
    }

    function flipSelected() {
      const inst = getSelectedInstance();
      if (!inst) return;
      inst.faceUp = !inst.faceUp;
      bringToFront(inst);
      saveState();
      renderTable();
    }

    function rotateSelected() {
      const inst = getSelectedInstance();
      if (!inst) return;
      const oldRot = (inst.rot || 0) % 360;
      const newRot = (oldRot + 90) % 360;

      const oldBox = getInstanceBoxForRotation(oldRot);
      const newBox = getInstanceBoxForRotation(newRot);

      // Keep the visual center stable when width/height swap.
      const cx = (inst.x || 0) + oldBox.w / 2;
      const cy = (inst.y || 0) + oldBox.h / 2;
      inst.x = Math.round(cx - newBox.w / 2);
      inst.y = Math.round(cy - newBox.h / 2);
      inst.rot = newRot;
      bringToFront(inst);
      saveState();
      renderTable();
    }

    // --- Editor rendering ---
    function renderEditors() {
      const inst = getSelectedInstance();
      const card = inst ? state.cardsByNumber[inst.cardNumber] : null;

      if (!card) {
        el.edNumber.value = "";
        el.edType.value = "";
        el.edTitle.value = "";
        el.edLoc.value = "";
        el.edFlavor.value = "";
        el.edRules.value = "";
        el.edImage.value = "";
      } else {
        el.edNumber.value = card.number || "";
        el.edType.value = card.type || "";
        el.edTitle.value = card.title || "";
        el.edLoc.value = card.location || "";
        el.edFlavor.value = card.flavor || "";
        el.edRules.value = card.rules || "";
        el.edImage.value = card.imageIdea || "";
      }

      el.edRulesDoc.value = state.rulesText || "";
    }

    // --- Spawn cards ---
    function spawnCard(cardNumber) {
      const card = state.cardsByNumber[cardNumber];
      if (!card) return;

      const rect = el.table.getBoundingClientRect();
      const x = rect.width ? rect.width / 2 - 90 : 200;
      const y = rect.height ? rect.height / 2 - 126 : 200;

      const inst = {
        id: nowId(),
        cardNumber: cardNumber,
        x: Math.round(x + (Math.random() * 30 - 15)),
        y: Math.round(y + (Math.random() * 30 - 15)),
        z: ++state.zTop,
        faceUp: true,
        rot: 0,
      };

      state.instances.push(inst);
      state.selectedInstanceId = inst.id;
      saveState();
      renderTable();
      renderEditors();
      setStatus(`Spawned #${cardNumber}${card.title ? " ‚Äî " + card.title : ""}`);
    }

    // --- Import/export workflows ---
    async function readFileAsText(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onerror = () => reject(new Error("Failed to read file"));
        r.onload = () => resolve((r.result ?? "").toString());
        r.readAsText(file);
      });
    }

    async function importCardsFile(file) {
      const text = await readFileAsText(file);
      const rows = parseCsv(text);
      const { cardsByNumber, cardOrder } = csvRowsToCards(rows);

      state.cardsByNumber = cardsByNumber;
      state.cardOrder = cardOrder;

      // Drop any pile references that no longer exist.
      state.piles = state.piles ?? {};
      for (const pileId of Object.keys(state.piles)) {
        const pile = state.piles[pileId];
        if (!pile || !Array.isArray(pile.cards)) continue;
        pile.cards = pile.cards.filter(n => !!state.cardsByNumber[n]);
      }

      state.zones = Array.isArray(state.zones) ? state.zones : [];

      // Drop any instances that reference missing card numbers.
      state.instances = state.instances.filter(i => !!state.cardsByNumber[i.cardNumber]);
      if (state.selectedInstanceId && !state.instances.some(i => i.id === state.selectedInstanceId)) {
        state.selectedInstanceId = null;
      }

      saveState();
      renderTable();
      renderEditors();
      setStatus(`Imported ${cardOrder.length} cards from CSV.`);
    }

    async function tryAutoLoadDefaults() {
      // Only auto-load if we have nothing yet.
      if (state.cardOrder?.length) return;
      if (!(location.protocol === "http:" || location.protocol === "https:")) return;

      try {
        const [cardsRes, rulesRes] = await Promise.all([
          fetch("./cards/cardlist.csv", { cache: "no-store" }),
          fetch("./rules/rules.md", { cache: "no-store" }),
        ]);

        if (cardsRes.ok) {
          const csv = await cardsRes.text();
          const rows = parseCsv(csv);
          const { cardsByNumber, cardOrder } = csvRowsToCards(rows);
          state.cardsByNumber = cardsByNumber;
          state.cardOrder = cardOrder;
        }

        if (rulesRes.ok) {
          state.rulesText = await rulesRes.text();
        }

        state.piles = state.piles ?? {};
        state.zones = state.zones ?? [];

        saveState();
        renderTable();
        renderEditors();

        if (state.cardOrder.length) {
          setStatus(`Auto-loaded ${state.cardOrder.length} cards from ./cards/cardlist.csv`);
        }
      } catch {
        // ignore; manual import still works
      }
    }

    function autoSetupFromRules() {
      if (!state.cardOrder?.length) {
        alert("Cards not loaded yet. If you're using the local server, reload the page to auto-load, or import cardlist.csv manually.");
        return;
      }

      // Identify domains via Location-type cards.
      const domainTitleCards = state.cardOrder
        .map(n => state.cardsByNumber[n])
        .filter(c => c && (c.type || "").toLowerCase().includes("location"));

      const domainNames = [];
      const seen = new Set();
      for (const c of domainTitleCards) {
        const name = (c.title || c.location || "").trim();
        if (!name || seen.has(name)) continue;
        seen.add(name);
        domainNames.push(name);
      }

      const preferred = [
        "Home Village Termina",
        "Forgotten Shrine",
        "Darkwood Brume",
        "Bannered City Valthria",
        "Amara Rot Glade",
        "Sirocco Wastes",
        "Frozen Gaol",
        "The Caelith Spiremaze",
        "The Nightsea Expanse",
      ];

      const ordered = [];
      for (const p of preferred) if (seen.has(p)) ordered.push(p);
      for (const d of domainNames) if (!ordered.includes(d)) ordered.push(d);

      // Build piles per domain: all cards whose Associated_Location matches domain name (excluding the Location title card).
      state.piles = {};
      for (const domain of ordered) {
        const pileId = `domain:${domain}`;
        const stationNumbers = state.cardOrder
          .map(n => state.cardsByNumber[n])
          .filter(c => c && (c.location || "").trim() === domain)
          .filter(c => !(c.type || "").toLowerCase().includes("location"))
          .map(c => c.number);

        shuffleInPlace(stationNumbers);
        state.piles[pileId] = { name: domain, cards: stationNumbers, faceUp: false };
      }

      // Active exploration piles.
      const activeDomain = ordered.includes("Home Village Termina") ? "Home Village Termina" : (ordered[0] || "");
      state.activeDomain = activeDomain;
      const activeDeckPileId = activeDomain ? `domain:${activeDomain}` : "";
      const activeDiscardId = "active:discard";
      state.piles[activeDiscardId] = { name: "Active Discard", cards: [], faceUp: true };

      // Clear table and lay out core cards.
      state.instances = [];
      state.selectedInstanceId = null;
      state.zTop = 1;

      const spawnByExactTitle = (title, x, y) => {
        const card = state.cardOrder.map(n => state.cardsByNumber[n]).find(c => (c?.title || "").trim() === title);
        if (!card) return;
        state.instances.push({
          id: nowId(),
          cardNumber: card.number,
          x,
          y,
          z: ++state.zTop,
          faceUp: true,
          rot: 0,
        });
      };

      const { w: cardW, h: cardH } = getCardSize();
      const vw = window.innerWidth || 1440;

      // Zones: world map (left) + exploration piles (center) + status area (right).
      // Domain stacks are laid out as a true diamond (staggered rows), aligned to a shared center.
      const baseX = 24;
      const baseY = 88;
      const zoneW = cardW;
      const zoneH = cardH;
      const gapX = 12;
      const gapY = 20;
      const dx = zoneW + gapX;
      const dy = zoneH + gapY;
      const centerX = baseX + dx; // centers the 3-wide middle row at baseX..baseX+2*dx

      const diamondRows = [
        ["The Nightsea Expanse"],
        ["Frozen Gaol", "The Caelith Spiremaze"],
        ["Darkwood Brume", "Amara Rot Glade", "Sirocco Wastes"],
        ["Forgotten Shrine", "Bannered City Valthria"],
        ["Home Village Termina"],
      ];

      const domainToXY = new Map();
      for (let row = 0; row < diamondRows.length; row++) {
        const names = diamondRows[row];
        const y = baseY + row * dy;

        if (names.length === 1) {
          domainToXY.set(names[0], { x: Math.round(centerX), y: Math.round(y) });
          continue;
        }

        if (names.length === 2) {
          domainToXY.set(names[0], { x: Math.round(centerX - dx / 2), y: Math.round(y) });
          domainToXY.set(names[1], { x: Math.round(centerX + dx / 2), y: Math.round(y) });
          continue;
        }

        // 3-wide row
        domainToXY.set(names[0], { x: Math.round(centerX - dx), y: Math.round(y) });
        domainToXY.set(names[1], { x: Math.round(centerX), y: Math.round(y) });
        domainToXY.set(names[2], { x: Math.round(centerX + dx), y: Math.round(y) });
      }

      state.zones = [];
      for (const domain of preferred) {
        if (!seen.has(domain)) continue;
        const pos = domainToXY.get(domain);
        if (!pos) continue;
        state.zones.push({
          id: `zone:domain:${domain}`,
          name: domain,
          subtitle: "Domain stack",
          x: pos.x,
          y: pos.y,
          w: zoneW,
          h: zoneH,
          pileId: `domain:${domain}`,
        });
      }

      // Any unexpected domains (shouldn't happen with your current set) go beneath.
      for (const domain of ordered) {
        if (preferred.includes(domain)) continue;
        state.zones.push({
          id: `zone:domain:extra:${domain}`,
          name: domain,
          subtitle: "Domain stack",
          x: baseX,
          y: baseY + 5 * dy,
          w: zoneW,
          h: zoneH,
          pileId: `domain:${domain}`,
        });
      }

      // Exploration area (center): title card centered over deck+discard; deck + discard beneath; active row below.
      const exploreTitleY = 60;
      const explorePileY = exploreTitleY + cardH + 16;
      const explorePileH = 92;

      // Active deck/discard zones are shown as landscape "cards".
      const activePileW = cardH;
      const activePileH = cardW;
      const activePileGap = 32;

      const activeDeckX = 560;
      const activeDiscardX = activeDeckX + activePileW + activePileGap;
      const exploreGroupCenterX = (activeDeckX + (activeDiscardX + activePileW)) / 2;
      const exploreTitleX = Math.round(exploreGroupCenterX - cardW / 2);

      state.zones.push({
        id: "zone:activeDeck",
        name: "Active Deck",
        subtitle: activeDomain ? activeDomain : "",
        x: activeDeckX,
        y: explorePileY,
        w: activePileW,
        h: activePileH,
        pileId: activeDeckPileId,
      });

      state.zones.push({
        id: "zone:activeDiscard",
        name: "Active Discard",
        subtitle: "",
        x: activeDiscardX,
        y: explorePileY,
        w: activePileW,
        h: activePileH,
        pileId: activeDiscardId,
      });

      // Status area (right): player + trackers and space for items/equipment/snares.
      const statusCol1 = Math.max(1000, vw - (2 * cardW + 84));
      const statusCol2 = statusCol1 + cardW + 24;
      const statusY1 = 60;
      const statusY2 = statusY1 + cardH + 44;
      const statusY3 = statusY2 + cardH + 44;

      spawnByExactTitle("Player", statusCol1, statusY1);
      spawnByExactTitle("Health", statusCol2, statusY1);
      spawnByExactTitle("Resolve // Dread", statusCol1, statusY2);
      spawnByExactTitle("Grace", statusCol2, statusY2);
      spawnByExactTitle("Status", statusCol1, statusY3);
      spawnByExactTitle("Combat Reference", statusCol2, statusY3);

      // Active domain title card (above active deck).
      if (activeDomain) {
        const titleCard = state.cardOrder
          .map(n => state.cardsByNumber[n])
          .find(c => (c?.type || "").toLowerCase().includes("location") && (c?.title || "").trim() === activeDomain);
        if (titleCard) {
          state.instances.push({
            id: nowId(),
            cardNumber: titleCard.number,
            x: exploreTitleX,
            y: exploreTitleY,
            z: ++state.zTop,
            faceUp: true,
            rot: 0,
            role: "activeTitle",
          });
        }
      }

      // Deal 3 face-down station cards into the active row (below deck/discard).
      const slots = getActiveRowSlotPositions();
      for (let s = 0; s < slots.length; s++) {
        const pos = slots[s];
        const n = activeDeckPileId ? state.piles[activeDeckPileId]?.cards?.shift() : null;
        if (!n) break;
        state.instances.push({
          id: nowId(),
          cardNumber: n,
          x: pos.x,
          y: pos.y,
          z: ++state.zTop,
          faceUp: false,
          rot: 0,
          activeRowSlot: s,
        });
      }

      saveState();
      renderTable();
      renderEditors();
      setStatus("Auto setup complete: domains shuffled; Termina active with 3 face-down cards.");
    }

    async function importRulesFile(file) {
      const text = await readFileAsText(file);
      state.rulesText = text;
      saveState();
      renderEditors();
      setStatus(`Imported rules (${text.length} chars).`);
    }

    function exportState() {
      const payload = {
        exportedAt: new Date().toISOString(),
        version: 1,
        state,
      };
      downloadText("forward-vtt-state.json", JSON.stringify(payload, null, 2), "application/json");
    }

    function exportCardsCsv() {
      const header = [
        "Card Number",
        "Type",
        "Title",
        "Associated_Location",
        "Flavor_Text",
        "Rules_Text",
        "Image_Source_Idea",
      ];

      const lines = [header.map(escapeCsvValue).join(",")];
      for (const n of state.cardOrder) {
        const c = state.cardsByNumber[n];
        if (!c) continue;
        lines.push([
          c.number,
          c.type,
          c.title,
          c.location,
          c.flavor,
          c.rules,
          c.imageIdea,
        ].map(escapeCsvValue).join(","));
      }

      downloadText("forward-cards-edited.csv", lines.join("\n"), "text/csv");
    }

    function exportRulesText() {
      downloadText("forward-rules-edited.txt", state.rulesText || "", "text/plain");
    }

    function resetLocalState() {
      if (!confirm("Reset local state? This clears cards, rules, and the tabletop (localStorage).")) return;
      localStorage.removeItem(STORAGE_KEY);
      state = {
        cardsByNumber: {},
        cardOrder: [],
        rulesText: "",
        instances: [],
        piles: {},
        zones: [],
        activeDomain: "",
        selectedInstanceId: null,
        zTop: 1,
        trackers: { health: 20, resolve: 0, dread: 0, grace: 0 },
        combatLog: [],
      };
      renderTable();
      renderEditors();
      renderTrackers();
      setStatus("Local state reset.");
    }

    // --- Tracker and Combat Functions ---
    function renderTrackers() {
      const t = state.trackers || { health: 20, resolve: 0, dread: 0, grace: 0 };
      el.trackerHealth.textContent = t.health;
      el.trackerResolve.textContent = t.resolve;
      el.trackerDread.textContent = t.dread;
      el.trackerGrace.textContent = t.grace;
    }

    function adjustTracker(name, delta) {
      state.trackers = state.trackers || { health: 20, resolve: 0, dread: 0, grace: 0 };
      const limits = {
        health: { min: 0, max: 99 },
        resolve: { min: 0, max: 4 },
        dread: { min: 0, max: 4 },
        grace: { min: 0, max: 3 },
      };
      const lim = limits[name] || { min: 0, max: 99 };
      state.trackers[name] = clamp((state.trackers[name] || 0) + delta, lim.min, lim.max);

      // Check for death or max dread
      if (name === "health" && state.trackers.health <= 0) {
        addCombatLog("üíÄ Health reached 0 ‚Äî DEFEAT!");
      }
      if (name === "dread" && state.trackers.dread >= 4) {
        addCombatLog("üò± Dread maxed out ‚Äî DEFEAT!");
      }

      saveState();
      renderTrackers();
    }

    function addCombatLog(message) {
      state.combatLog = state.combatLog || [];
      const time = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      state.combatLog.push({ time, message });
      if (state.combatLog.length > 50) state.combatLog.shift();
      saveState();
      renderCombatLog();
    }

    function renderCombatLog() {
      const log = state.combatLog || [];
      el.combatLogInner.innerHTML = log.slice(-5).reverse().map(e =>
        `<div class="log-entry"><span style="color:var(--muted)">[${e.time}]</span> ${escapeHtmlText(e.message)}</div>`
      ).join("");
    }

    function roll1d6() {
      return Math.floor(Math.random() * 6) + 1;
    }

    function getCombatResult(roll) {
      return COMBAT_TABLE[roll] || COMBAT_TABLE[1];
    }

    function rollPlayerDice() {
      const roll = roll1d6();
      const result = getCombatResult(roll);
      el.rollPlayerResult.textContent = roll;
      addCombatLog(`üé≤ Player rolled ${roll} ‚Üí ${result.name} (${result.desc})`);
      return { roll, result };
    }

    function rollEnemyDice() {
      const roll = roll1d6();
      const result = getCombatResult(roll);
      el.rollEnemyResult.textContent = roll;
      addCombatLog(`üé≤ Enemy rolled ${roll} ‚Üí ${result.name} (${result.desc})`);
      return { roll, result };
    }

    function rollBothDice() {
      const p = roll1d6();
      const e = roll1d6();
      const pRes = getCombatResult(p);
      const eRes = getCombatResult(e);
      el.rollPlayerResult.textContent = p;
      el.rollEnemyResult.textContent = e;
      addCombatLog(`‚öîÔ∏è Combat: Player ${p} (${pRes.name}) vs Enemy ${e} (${eRes.name})`);
      return { player: { roll: p, result: pRes }, enemy: { roll: e, result: eRes } };
    }

    // --- Keyboard shortcuts ---
    function onKeyDown(e) {
      // Don‚Äôt hijack typing in inputs.
      const t = e.target;
      if (t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable)) return;

      if (e.key === "Delete" || e.key === "Backspace") {
        deleteSelected();
      } else if (e.key.toLowerCase() === "f") {
        flipSelected();
      } else if (e.key.toLowerCase() === "r") {
        rotateSelected();
      } else if (e.key.toLowerCase() === "e") {
        toggleDrawer();
      } else if (e.key === "Escape") {
        if (isDrawerOpen()) {
          closeDrawer();
          return;
        }
        state.selectedInstanceId = null;
        saveState();
        renderTable();
        renderEditors();
        setStatus("No selection.");
      }
    }

    // --- Card editor events ---
    let editorSnapshot = null;

    function takeEditorSnapshot() {
      editorSnapshot = {
        type: el.edType.value,
        title: el.edTitle.value,
        loc: el.edLoc.value,
        flavor: el.edFlavor.value,
        rules: el.edRules.value,
        image: el.edImage.value,
      };
    }

    function restoreEditorSnapshot() {
      if (!editorSnapshot) return;
      el.edType.value = editorSnapshot.type;
      el.edTitle.value = editorSnapshot.title;
      el.edLoc.value = editorSnapshot.loc;
      el.edFlavor.value = editorSnapshot.flavor;
      el.edRules.value = editorSnapshot.rules;
      el.edImage.value = editorSnapshot.image;
    }

    function saveCardEdits() {
      const inst = getSelectedInstance();
      if (!inst) return;
      const card = state.cardsByNumber[inst.cardNumber];
      if (!card) return;

      card.type = el.edType.value;
      card.title = el.edTitle.value;
      card.location = el.edLoc.value;
      card.flavor = el.edFlavor.value;
      card.rules = el.edRules.value;
      card.imageIdea = el.edImage.value;

      saveState();
      renderTable();
      setStatus(`Saved edits to #${card.number}${card.title ? " ‚Äî " + card.title : ""}`);
      takeEditorSnapshot();
    }

    function saveRulesEdits() {
      state.rulesText = el.edRulesDoc.value;
      saveState();
      setStatus("Saved rules edits.");
    }

    function setTab(which) {
      if (which === "card") {
        el.tabCard.classList.add("active");
        el.tabRules.classList.remove("active");
        el.tabCard.setAttribute("aria-selected", "true");
        el.tabRules.setAttribute("aria-selected", "false");
        el.cardEditor.style.display = "grid";
        el.rulesEditor.style.display = "none";
      } else {
        el.tabRules.classList.add("active");
        el.tabCard.classList.remove("active");
        el.tabRules.setAttribute("aria-selected", "true");
        el.tabCard.setAttribute("aria-selected", "false");
        el.cardEditor.style.display = "none";
        el.rulesEditor.style.display = "grid";
      }
    }

    function isDrawerOpen() {
      return el.editorDrawer.classList.contains("open");
    }

    function openDrawer(preferredTab = null) {
      el.editorDrawer.classList.add("open");
      el.editorDrawer.setAttribute("aria-hidden", "false");
      el.drawerBackdrop.setAttribute("aria-hidden", "false");

      if (preferredTab) setTab(preferredTab);

      // Focus the first useful field.
      if (preferredTab === "rules") {
        el.edRulesDoc?.focus();
      } else {
        el.edTitle?.focus();
      }
    }

    function closeDrawer() {
      el.editorDrawer.classList.remove("open");
      el.editorDrawer.setAttribute("aria-hidden", "true");
      el.drawerBackdrop.setAttribute("aria-hidden", "true");
    }

    function toggleDrawer() {
      if (isDrawerOpen()) {
        closeDrawer();
        return;
      }

      const inst = getSelectedInstance();
      if (inst) openDrawer("card");
      else openDrawer("rules");
    }

    // --- Boot ---
    function boot() {
      loadState();

      // Ensure optional fields exist on older saved states.
      state.piles = state.piles ?? {};
      state.zones = state.zones ?? [];
      state.activeDomain = state.activeDomain ?? "";

      // Ensure zTop is at least max instance z.
      const maxZ = state.instances.reduce((m, i) => Math.max(m, i.z || 0), 0);
      state.zTop = Math.max(state.zTop || 1, maxZ || 1);

      renderTable();
      renderEditors();

      // Auto-load ./cards/cardlist.csv and ./rules/rules.md when served via local server.
      // (This won‚Äôt run for file:// URLs and won‚Äôt overwrite existing local state.)
      tryAutoLoadDefaults();

      if (state.cardOrder.length) {
        setStatus(`Ready. Loaded ${state.cardOrder.length} cards from local state.`);
      } else {
        setStatus("Ready. Import your cardlist CSV to begin.");
      }

      el.closeEditor.addEventListener("click", () => closeDrawer());
      el.drawerBackdrop.addEventListener("click", () => closeDrawer());

      el.cardsFile.addEventListener("change", async () => {
        const file = el.cardsFile.files?.[0];
        if (!file) return;
        try {
          await importCardsFile(file);
        } catch (err) {
          alert("Failed to import cards CSV. Make sure you selected cardlist.csv or cardlist_all.csv.");
        } finally {
          el.cardsFile.value = "";
        }
      });

      el.rulesFile.addEventListener("change", async () => {
        const file = el.rulesFile.files?.[0];
        if (!file) return;
        try {
          await importRulesFile(file);
        } catch {
          alert("Failed to import rules file.");
        } finally {
          el.rulesFile.value = "";
        }
      });

      el.exportState.addEventListener("click", exportState);
      el.exportCards.addEventListener("click", exportCardsCsv);
      el.clearState.addEventListener("click", resetLocalState);
      el.autoSetup.addEventListener("click", autoSetupFromRules);

      el.tabCard.addEventListener("click", () => setTab("card"));
      el.tabRules.addEventListener("click", () => setTab("rules"));

      el.saveCard.addEventListener("click", saveCardEdits);
      el.revertCard.addEventListener("click", () => restoreEditorSnapshot());

      el.saveRules.addEventListener("click", saveRulesEdits);
      el.exportRules.addEventListener("click", exportRulesText);

      document.addEventListener("keydown", onKeyDown);

      takeEditorSnapshot();

      // Clicking empty table clears selection.
      el.table.addEventListener("pointerdown", (e) => {
        if (e.target === el.table) {
          state.selectedInstanceId = null;
          saveState();
          renderTable();
          renderEditors();
          setStatus("No selection.");
        }
      });

      // --- Combat footer event listeners ---
      // Tracker +/- buttons
      document.querySelectorAll(".tracker-btn").forEach(btn => {
        btn.addEventListener("click", () => {
          const tracker = btn.dataset.tracker;
          const delta = parseInt(btn.dataset.delta, 10) || 0;
          if (tracker) adjustTracker(tracker, delta);
        });
      });

      // Dice roll buttons
      el.rollPlayer.addEventListener("click", rollPlayerDice);
      el.rollEnemy.addEventListener("click", rollEnemyDice);
      el.rollBoth.addEventListener("click", rollBothDice);
    }

    boot();
  </script>
</body>
</html>