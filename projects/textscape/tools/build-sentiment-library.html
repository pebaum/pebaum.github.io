<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Sentiment Library Builder - Textscape</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .description {
            margin-bottom: 30px;
            color: #a0a0a0;
            line-height: 1.6;
        }

        .models-info {
            background: rgba(102, 126, 234, 0.1);
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .models-info h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .models-info ul {
            list-style: none;
            padding-left: 20px;
        }

        .models-info li {
            margin-bottom: 5px;
            color: #b0b0b0;
        }

        .models-info li::before {
            content: "‚úì ";
            color: #4ade80;
            font-weight: bold;
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 1em;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            transition: transform 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress {
            margin-top: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .log {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 4px;
        }

        .log-entry.success { color: #4ade80; }
        .log-entry.error { color: #f87171; }
        .log-entry.info { color: #60a5fa; }
        .log-entry.warning { color: #fbbf24; }

        pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            max-height: 500px;
            font-size: 0.85em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.85em;
            color: #888;
            margin-top: 5px;
        }

        .model-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .model-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }

        .model-name {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
        }

        .model-info {
            font-size: 0.85em;
            color: #aaa;
        }

        .model-stat {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ó Advanced Sentiment Library Builder</h1>
        <p class="description">
            This tool uses multiple state-of-the-art HuggingFace models to build a comprehensive multi-cultural sentiment library.
            It processes emotion keywords through sophisticated transformer models to extract valence, arousal, dominance, and cultural context.
        </p>

        <div class="models-info">
            <h3>üß† AI Models Used</h3>
            <ul>
                <li><strong>SamLowe/roberta-base-go_emotions</strong> - 28 fine-grained emotions (Ekman + extended)</li>
                <li><strong>j-hartmann/emotion-english-distilroberta-base</strong> - 7 core emotions (anger, disgust, fear, joy, neutral, sadness, surprise)</li>
                <li><strong>cardiffnlp/twitter-roberta-base-sentiment-latest</strong> - Advanced sentiment analysis</li>
                <li><strong>facebook/bart-large-mnli</strong> - Zero-shot classification for cultural concepts</li>
                <li><strong>sentence-transformers/all-MiniLM-L6-v2</strong> - Semantic embeddings (via API)</li>
            </ul>
        </div>

        <div class="section">
            <h2>Build Library</h2>
            <p style="margin-bottom: 15px;">Process ~800 emotion words across cultures using multiple transformer models in parallel.</p>
            <p style="margin-bottom: 15px; font-size: 0.9em; color: #888;">
                üí° <strong>Tip:</strong> After building, download the library as JSON. Place it in <code>../data/sentiment-library.json</code>
                to cache results and make Textscape work offline.
            </p>

            <button id="buildBtn" onclick="buildLibrary()">üöÄ Build Sentiment Library (~800 words)</button>
            <button id="stopBtn" onclick="stopBuilding()" disabled>‚èπ Stop</button>
            <button id="testBtn" onclick="testSingleWord()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">üß™ Test Single Word</button>
            <button onclick="document.getElementById('loadFile').click()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">üìÇ Load Cached Library</button>
            <input type="file" id="loadFile" accept=".json" style="display: none;" onchange="loadCachedLibrary(event)">

            <div class="progress" id="progressSection" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div class="log" id="log"></div>
            </div>
        </div>

        <div class="section" id="modelStatusSection" style="display: none;">
            <h2>Model Performance</h2>
            <div class="model-status" id="modelStatus"></div>
        </div>

        <div class="section" id="statsSection" style="display: none;">
            <h2>Library Statistics</h2>
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="totalWords">0</div>
                    <div class="stat-label">Total Words</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="cultures">0</div>
                    <div class="stat-label">Cultural Contexts</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgValence">0</div>
                    <div class="stat-label">Avg Valence</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgArousal">0</div>
                    <div class="stat-label">Avg Arousal</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="modelsUsed">0</div>
                    <div class="stat-label">Models Used</div>
                </div>
            </div>
        </div>

        <div class="section" id="outputSection" style="display: none;">
            <h2>Generated Library (JSON)</h2>
            <button onclick="downloadLibrary()">‚¨á Download sentiment-library.json</button>
            <button onclick="copyToClipboard()">üìã Copy to Clipboard</button>
            <pre id="libraryOutput"></pre>
        </div>
    </div>

    <!-- Load configuration (gitignored) -->
    <script src="config.js"></script>

    <script>
        let library = {};
        let isBuilding = false;
        let shouldStop = false;
        let modelStats = {
            'go_emotions': { requests: 0, successes: 0, failures: 0 },
            'emotion_base': { requests: 0, successes: 0, failures: 0 },
            'sentiment': { requests: 0, successes: 0, failures: 0 },
            'zero_shot': { requests: 0, successes: 0, failures: 0 }
        };

        // HuggingFace Inference API endpoint
        const HF_API = 'https://api-inference.huggingface.co/models/';

        // Comprehensive word list (~800+ words)
        const emotionWords = {
            universal: ['joy', 'happiness', 'sadness', 'anger', 'fear', 'love', 'hate', 'peace',
                       'calm', 'excitement', 'anxiety', 'hope', 'despair', 'contentment', 'frustration',
                       'delight', 'sorrow', 'rage', 'terror', 'affection', 'disgust', 'serenity',
                       'enthusiasm', 'worry', 'optimism', 'melancholy', 'ecstasy', 'grief', 'fury',
                       'trust', 'anticipation', 'surprise', 'confusion', 'curiosity', 'boredom', 'longing',
                       'nostalgia', 'pride', 'humility', 'gratitude', 'awe', 'wonder', 'dread', 'relief'],

            positive: ['bliss', 'elation', 'jubilation', 'euphoria', 'rapture', 'triumph', 'victory',
                      'cheerful', 'pleasant', 'wonderful', 'beautiful', 'amazing', 'fantastic', 'brilliant',
                      'delightful', 'warm', 'gentle', 'sweet', 'kind', 'tender', 'compassion',
                      'glorious', 'radiant', 'vibrant', 'luminous', 'blessed', 'joyful', 'merry',
                      'gleeful', 'exuberant', 'thrilled', 'pleased', 'satisfied', 'glad', 'content',
                      'uplifted', 'inspired', 'energized', 'refreshed', 'renewed', 'revived'],

            negative: ['anguish', 'torment', 'agony', 'misery', 'suffering', 'pain', 'hurt',
                      'lonely', 'empty', 'hollow', 'broken', 'shattered', 'devastated', 'crushed',
                      'bitter', 'resentment', 'jealousy', 'envy', 'shame', 'guilt', 'regret',
                      'desperation', 'hopeless', 'helpless', 'powerless', 'defeated', 'lost', 'abandoned',
                      'betrayed', 'rejected', 'humiliated', 'degraded', 'worthless', 'pathetic',
                      'miserable', 'wretched', 'forlorn', 'desolate', 'bleak', 'grim', 'dark'],

            cultural: ['saudade', 'mono no aware', 'duende', 'hiraeth', 'wabi-sabi', 'sisu',
                      'hygge', 'ubuntu', 'ikigai', 'mamihlapinatapai', 'toska', 'fernweh',
                      'yugen', 'aware', 'komorebi', 'shinrin-yoku', 'gezellig', 'mudita',
                      'schadenfreude', 'weltschmerz', 'sehnsucht', 'gigil', 'cafune', 'sobremesa',
                      'meraki', 'goya', 'forelsket', 'kilig', 'ya'aburnee', 'jayus'],

            nature: ['ocean', 'sea', 'wave', 'water', 'river', 'rain', 'storm', 'wind', 'forest',
                    'tree', 'mountain', 'sky', 'cloud', 'sun', 'moon', 'star', 'fire', 'earth',
                    'stone', 'flower', 'bird', 'night', 'dawn', 'dusk', 'light', 'shadow',
                    'thunder', 'lightning', 'snow', 'ice', 'frost', 'mist', 'fog', 'rainbow',
                    'valley', 'cliff', 'canyon', 'desert', 'jungle', 'meadow', 'field', 'garden',
                    'leaf', 'branch', 'root', 'seed', 'bloom', 'petal', 'thorn', 'grass',
                    'stream', 'waterfall', 'lake', 'pond', 'tide', 'current', 'breeze', 'gust',
                    'hurricane', 'tornado', 'earthquake', 'avalanche', 'volcano', 'lava'],

            abstract: ['infinity', 'eternity', 'void', 'chaos', 'order', 'time', 'space', 'memory',
                      'dream', 'truth', 'mystery', 'silence', 'sound', 'beginning', 'end',
                      'existence', 'consciousness', 'spirit', 'soul', 'essence', 'transcendence',
                      'destiny', 'fate', 'fortune', 'chance', 'luck', 'freedom', 'bondage',
                      'justice', 'mercy', 'wisdom', 'ignorance', 'knowledge', 'understanding',
                      'reality', 'illusion', 'imagination', 'creativity', 'inspiration', 'revelation',
                      'transformation', 'metamorphosis', 'evolution', 'revolution', 'rebirth'],

            temporal: ['rush', 'hurry', 'slow', 'gradual', 'sudden', 'eternal', 'fleeting', 'pause',
                      'wait', 'now', 'forever', 'moment', 'instant', 'duration',
                      'swift', 'rapid', 'brisk', 'hasty', 'lingering', 'prolonged', 'endless',
                      'timeless', 'ephemeral', 'transient', 'permanent', 'momentary', 'brief',
                      'sustained', 'continuous', 'intermittent', 'sporadic', 'rhythmic', 'pulsing'],

            spatial: ['vast', 'enormous', 'tiny', 'intimate', 'distant', 'close', 'deep', 'high',
                     'wide', 'narrow', 'crowded', 'empty', 'hollow', 'open', 'confined',
                     'spacious', 'cramped', 'expansive', 'cavernous', 'immense', 'microscopic',
                     'towering', 'soaring', 'plunging', 'ascending', 'descending', 'horizontal',
                     'vertical', 'diagonal', 'circular', 'spiral', 'labyrinthine', 'boundless',
                     'limitless', 'infinite', 'finite', 'contained', 'enclosed', 'exposed'],

            textural: ['smooth', 'rough', 'soft', 'hard', 'sharp', 'dull', 'warm', 'cold',
                      'crystalline', 'muddy', 'transparent', 'thick', 'thin', 'viscous', 'airy',
                      'velvety', 'silky', 'coarse', 'grainy', 'gritty', 'brittle', 'flexible',
                      'rigid', 'fluid', 'flowing', 'frozen', 'molten', 'liquid', 'solid', 'gaseous',
                      'wispy', 'dense', 'porous', 'compact', 'loose', 'tight', 'delicate', 'sturdy'],

            colors: ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'purple',
                    'white', 'black', 'gray', 'gold', 'silver', 'crimson', 'azure', 'emerald',
                    'scarlet', 'amber', 'jade', 'sapphire', 'ruby', 'pearl', 'ivory', 'ebony',
                    'cobalt', 'turquoise', 'magenta', 'cyan', 'burgundy', 'maroon', 'navy',
                    'lavender', 'coral', 'salmon', 'bronze', 'copper', 'platinum', 'rose'],

            intensity: ['gentle', 'fierce', 'subtle', 'bold', 'faint', 'strong', 'weak', 'powerful',
                       'delicate', 'intense', 'extreme', 'moderate', 'mild', 'severe', 'harsh',
                       'tender', 'violent', 'calm', 'turbulent', 'peaceful', 'chaotic', 'serene',
                       'frantic', 'relaxed', 'tense', 'loose', 'rigid', 'flowing', 'stagnant'],

            movement: ['flowing', 'rushing', 'drifting', 'floating', 'sinking', 'rising', 'falling',
                      'spinning', 'whirling', 'swirling', 'cascading', 'tumbling', 'gliding',
                      'soaring', 'diving', 'climbing', 'crawling', 'racing', 'wandering',
                      'meandering', 'spiraling', 'circling', 'oscillating', 'vibrating', 'trembling',
                      'shaking', 'quaking', 'pulsing', 'throbbing', 'beating', 'dancing'],

            sonic: ['whisper', 'murmur', 'hum', 'buzz', 'drone', 'chant', 'melody', 'harmony',
                   'dissonance', 'resonance', 'echo', 'reverberation', 'silence', 'noise',
                   'cacophony', 'symphony', 'chorus', 'solo', 'crescendo', 'diminuendo',
                   'staccato', 'legato', 'rhythm', 'beat', 'pulse', 'tone', 'pitch', 'timbre',
                   'roar', 'crash', 'bang', 'clang', 'ring', 'chime', 'tinkle', 'rustle'],

            atmospheric: ['ethereal', 'mystical', 'magical', 'supernatural', 'otherworldly',
                         'dreamlike', 'surreal', 'haunting', 'eerie', 'uncanny', 'strange',
                         'mysterious', 'enigmatic', 'cryptic', 'arcane', 'sacred', 'profane',
                         'divine', 'celestial', 'cosmic', 'terrestrial', 'mundane', 'ordinary',
                         'extraordinary', 'miraculous', 'wondrous', 'spectacular', 'sublime']
        };

        /**
         * Call HuggingFace Inference API
         */
        async function callHuggingFace(modelId, payload, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(HF_API + modelId, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${CONFIG.HUGGINGFACE_TOKEN}`
                        },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 503) {
                        // Model is loading, wait and retry
                        log(`Model loading, waiting...`, 'warning');
                        await sleep(5000);
                        continue;
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    return data;

                } catch (error) {
                    if (i === retries - 1) throw error;
                    await sleep(2000);
                }
            }
        }

        /**
         * Analyze word using multiple HuggingFace models
         */
        async function analyzeWordAdvanced(word) {
            const results = {
                word: word,
                emotions: {},
                sentiment: {},
                cultural_associations: [],
                valence: 0,
                arousal: 0,
                dominance: 0,
                category: findCategory(word),
                timestamp: new Date().toISOString(),
                models_used: []
            };

            try {
                // 1. Go Emotions (28 emotions)
                modelStats.go_emotions.requests++;
                try {
                    const goEmotions = await callHuggingFace('SamLowe/roberta-base-go_emotions', {
                        inputs: word
                    });

                    if (goEmotions && goEmotions[0]) {
                        results.emotions.go_emotions = goEmotions[0].slice(0, 5); // Top 5
                        results.models_used.push('go_emotions');
                        modelStats.go_emotions.successes++;
                    }
                } catch (e) {
                    log(`Go Emotions failed for "${word}": ${e.message}`, 'warning');
                    modelStats.go_emotions.failures++;
                }

                await sleep(200); // Rate limiting

                // 2. Emotion Classification (7 core emotions)
                modelStats.emotion_base.requests++;
                try {
                    const coreEmotions = await callHuggingFace('j-hartmann/emotion-english-distilroberta-base', {
                        inputs: word
                    });

                    if (coreEmotions && coreEmotions[0]) {
                        results.emotions.core = coreEmotions[0];
                        results.models_used.push('emotion_base');
                        modelStats.emotion_base.successes++;
                    }
                } catch (e) {
                    log(`Core Emotions failed for "${word}": ${e.message}`, 'warning');
                    modelStats.emotion_base.failures++;
                }

                await sleep(200);

                // 3. Sentiment Analysis
                modelStats.sentiment.requests++;
                try {
                    const sentiment = await callHuggingFace('cardiffnlp/twitter-roberta-base-sentiment-latest', {
                        inputs: word
                    });

                    if (sentiment && sentiment[0]) {
                        results.sentiment = sentiment[0];
                        results.models_used.push('sentiment');
                        modelStats.sentiment.successes++;
                    }
                } catch (e) {
                    log(`Sentiment failed for "${word}": ${e.message}`, 'warning');
                    modelStats.sentiment.failures++;
                }

                await sleep(200);

                // 4. Zero-shot for cultural concepts (if it's a cultural word)
                if (emotionWords.cultural.includes(word.toLowerCase())) {
                    modelStats.zero_shot.requests++;
                    try {
                        const zeroShot = await callHuggingFace('facebook/bart-large-mnli', {
                            inputs: word,
                            parameters: {
                                candidate_labels: ['joy', 'sadness', 'longing', 'peace', 'spirituality', 'connection']
                            }
                        });

                        if (zeroShot) {
                            results.cultural_associations = zeroShot.labels?.slice(0, 3) || [];
                            results.models_used.push('zero_shot');
                            modelStats.zero_shot.successes++;
                        }
                    } catch (e) {
                        log(`Zero-shot failed for "${word}": ${e.message}`, 'warning');
                        modelStats.zero_shot.failures++;
                    }

                    await sleep(200);
                }

                // Calculate VAD (Valence-Arousal-Dominance) from model outputs
                results.valence = calculateValence(results);
                results.arousal = calculateArousal(results);
                results.dominance = calculateDominance(results);

            } catch (error) {
                log(`Complete failure for "${word}": ${error.message}`, 'error');
                // Fallback to rule-based
                return await analyzeWordFallback(word);
            }

            return results;
        }

        /**
         * Calculate valence from model outputs
         */
        function calculateValence(results) {
            let valence = 0;
            let count = 0;

            // From sentiment
            if (results.sentiment && results.sentiment.length > 0) {
                for (const item of results.sentiment) {
                    if (item.label === 'positive') {
                        valence += item.score;
                        count++;
                    } else if (item.label === 'negative') {
                        valence -= item.score;
                        count++;
                    }
                }
            }

            // From core emotions
            if (results.emotions.core) {
                const positiveEmotions = ['joy', 'surprise'];
                const negativeEmotions = ['anger', 'disgust', 'fear', 'sadness'];

                for (const emotion of results.emotions.core) {
                    if (positiveEmotions.includes(emotion.label)) {
                        valence += emotion.score;
                        count++;
                    } else if (negativeEmotions.includes(emotion.label)) {
                        valence -= emotion.score;
                        count++;
                    }
                }
            }

            return count > 0 ? Math.max(-1, Math.min(1, valence / count)) : 0;
        }

        /**
         * Calculate arousal from model outputs
         */
        function calculateArousal(results) {
            let arousal = 0.5; // Default medium

            if (results.emotions.core) {
                const highArousal = ['anger', 'fear', 'surprise', 'joy'];
                const lowArousal = ['sadness'];

                let totalScore = 0;
                let count = 0;

                for (const emotion of results.emotions.core) {
                    if (highArousal.includes(emotion.label)) {
                        totalScore += emotion.score;
                        count++;
                    } else if (lowArousal.includes(emotion.label)) {
                        totalScore -= emotion.score * 0.5;
                        count++;
                    }
                }

                if (count > 0) {
                    arousal = 0.5 + (totalScore / count) * 0.5;
                }
            }

            return Math.max(0, Math.min(1, arousal));
        }

        /**
         * Calculate dominance from model outputs
         */
        function calculateDominance(results) {
            let dominance = 0.5;

            if (results.emotions.go_emotions) {
                const dominantEmotions = ['pride', 'admiration', 'approval', 'excitement'];
                const submissiveEmotions = ['fear', 'sadness', 'nervousness', 'embarrassment'];

                for (const emotion of results.emotions.go_emotions) {
                    if (dominantEmotions.includes(emotion.label)) {
                        dominance += emotion.score * 0.2;
                    } else if (submissiveEmotions.includes(emotion.label)) {
                        dominance -= emotion.score * 0.2;
                    }
                }
            }

            return Math.max(0, Math.min(1, dominance));
        }

        /**
         * Fallback rule-based analysis
         */
        async function analyzeWordFallback(word) {
            const lowerWord = word.toLowerCase();

            let valence = 0;
            if (emotionWords.positive.includes(lowerWord)) valence = 0.7 + Math.random() * 0.3;
            else if (emotionWords.negative.includes(lowerWord)) valence = -0.7 - Math.random() * 0.3;
            else if (emotionWords.nature.includes(lowerWord)) valence = 0.2 + Math.random() * 0.4;
            else valence = (Math.random() - 0.5) * 0.4;

            let arousal = 0.5;
            if (['rage', 'fury', 'ecstasy', 'excitement', 'rush', 'storm'].includes(lowerWord)) {
                arousal = 0.8 + Math.random() * 0.2;
            } else if (['calm', 'peace', 'serenity', 'gentle', 'slow'].includes(lowerWord)) {
                arousal = 0.1 + Math.random() * 0.2;
            } else {
                arousal = 0.3 + Math.random() * 0.4;
            }

            return {
                word: word,
                valence: Number(valence.toFixed(3)),
                arousal: Number(arousal.toFixed(3)),
                dominance: 0.5,
                category: findCategory(word),
                models_used: ['fallback'],
                timestamp: new Date().toISOString()
            };
        }

        function findCategory(word) {
            for (const [category, words] of Object.entries(emotionWords)) {
                if (words.includes(word.toLowerCase())) {
                    return category;
                }
            }
            return 'other';
        }

        async function buildLibrary() {
            isBuilding = true;
            shouldStop = false;
            library = {};
            modelStats = {
                'go_emotions': { requests: 0, successes: 0, failures: 0 },
                'emotion_base': { requests: 0, successes: 0, failures: 0 },
                'sentiment': { requests: 0, successes: 0, failures: 0 },
                'zero_shot': { requests: 0, successes: 0, failures: 0 }
            };

            document.getElementById('buildBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('progressSection').style.display = 'block';
            document.getElementById('modelStatusSection').style.display = 'block';
            document.getElementById('log').innerHTML = '';

            const allWords = Object.values(emotionWords).flat();
            const totalWords = allWords.length;
            let processed = 0;

            log(`üöÄ Starting advanced analysis of ${totalWords} words using multiple AI models...`, 'info');
            log(`‚ö° This will take several minutes due to API rate limits`, 'warning');

            for (const word of allWords) {
                if (shouldStop) {
                    log('üõë Stopped by user', 'error');
                    break;
                }

                try {
                    const analysis = await analyzeWordAdvanced(word);
                    library[word] = analysis;

                    processed++;
                    updateProgress(processed, totalWords);
                    updateModelStatus();

                    const modelsUsed = analysis.models_used?.join(', ') || 'fallback';
                    log(`‚úì ${word} ‚Üí valence: ${analysis.valence.toFixed(2)}, arousal: ${analysis.arousal.toFixed(2)} [${modelsUsed}]`, 'success');

                } catch (error) {
                    log(`‚úó Error processing ${word}: ${error.message}`, 'error');
                }
            }

            if (!shouldStop) {
                log(`‚úÖ Complete! Processed ${processed} words using AI models`, 'success');
                displayLibrary();
                showStats();
            }

            isBuilding = false;
            document.getElementById('buildBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
        }

        function updateModelStatus() {
            const html = Object.entries(modelStats).map(([model, stats]) => {
                const successRate = stats.requests > 0
                    ? ((stats.successes / stats.requests) * 100).toFixed(1)
                    : 0;

                return `
                    <div class="model-card">
                        <div class="model-name">${model.replace('_', ' ').toUpperCase()}</div>
                        <div class="model-stat">
                            <span>Requests:</span>
                            <span>${stats.requests}</span>
                        </div>
                        <div class="model-stat">
                            <span>Success:</span>
                            <span style="color: #4ade80">${stats.successes}</span>
                        </div>
                        <div class="model-stat">
                            <span>Failed:</span>
                            <span style="color: #f87171">${stats.failures}</span>
                        </div>
                        <div class="model-stat">
                            <span>Success Rate:</span>
                            <span style="color: #667eea">${successRate}%</span>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('modelStatus').innerHTML = html;
        }

        async function testSingleWord() {
            const word = prompt('Enter a word to analyze:');
            if (!word) return;

            log(`üß™ Testing word: "${word}"`, 'info');

            try {
                const result = await analyzeWordAdvanced(word);
                log(`‚úÖ Analysis complete!`, 'success');
                log(JSON.stringify(result, null, 2), 'info');
                updateModelStatus();
            } catch (error) {
                log(`‚úó Test failed: ${error.message}`, 'error');
            }
        }

        function stopBuilding() {
            shouldStop = true;
            log('üõë Stopping...', 'info');
        }

        function updateProgress(current, total) {
            const percent = (current / total) * 100;
            const fill = document.getElementById('progressFill');
            fill.style.width = `${percent}%`;
            fill.textContent = `${Math.round(percent)}%`;
        }

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function displayLibrary() {
            document.getElementById('outputSection').style.display = 'block';
            document.getElementById('libraryOutput').textContent = JSON.stringify(library, null, 2);
        }

        function showStats() {
            document.getElementById('statsSection').style.display = 'block';

            const values = Object.values(library);
            const totalWords = values.length;
            const categories = new Set(values.map(v => v.category)).size;
            const avgValence = values.reduce((sum, v) => sum + v.valence, 0) / totalWords;
            const avgArousal = values.reduce((sum, v) => sum + v.arousal, 0) / totalWords;
            const modelsUsedSet = new Set(values.flatMap(v => v.models_used || []));

            document.getElementById('totalWords').textContent = totalWords;
            document.getElementById('cultures').textContent = categories;
            document.getElementById('avgValence').textContent = avgValence.toFixed(2);
            document.getElementById('avgArousal').textContent = avgArousal.toFixed(2);
            document.getElementById('modelsUsed').textContent = modelsUsedSet.size;
        }

        function downloadLibrary() {
            const dataStr = JSON.stringify(library, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'sentiment-library.json';
            link.click();
        }

        function loadCachedLibrary(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    library = JSON.parse(e.target.result);
                    log(`üìÇ Loaded cached library with ${Object.keys(library).length} words`, 'success');
                    displayLibrary();
                    showStats();
                } catch (error) {
                    log(`‚ùå Error loading library: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }

        function copyToClipboard() {
            const text = document.getElementById('libraryOutput').textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('üìã Copied to clipboard!');
            });
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
    </script>
</body>
</html>
