<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drift v3 - Generative Music</title>
    <style>
        @font-face {
            font-family: 'IBM';
            src: local('IBM Plex Mono'), local('Consolas'), local('Monaco');
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #e8e4d9;
            font-family: 'Courier New', 'IBM Plex Mono', monospace;
            min-height: 100vh;
            overflow-x: hidden;
            font-size: 12px;
            line-height: 1.4;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            min-height: 100vh;
        }

        /* LEFT PANEL - Code Streams */
        .viz-panel {
            position: relative;
            background: #050505;
            border-right: 1px solid #1a1a1a;
            display: grid;
            grid-auto-flow: column;
            grid-auto-columns: minmax(160px, 1fr);
            grid-template-rows: 1fr;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .stream-column {
            border-right: 1px solid #111;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            min-width: 160px;
        }

        .stream-column:last-child {
            border-right: none;
        }

        .stream-header {
            padding: 8px 6px;
            background: #0a0a0a;
            border-bottom: 1px solid #1a1a1a;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #333;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .stream-header .inst-name {
            color: #f5f5f0;
            font-weight: bold;
        }

        .stream-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            font-size: 9px;
            line-height: 1.3;
            padding: 4px;
        }

        .stream-log {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px;
        }

        .stream-entry {
            padding: 2px 0;
            opacity: 0.9;
            animation: fadeIn 0.3s ease-out;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 0.9; transform: translateY(0); }
        }

        .stream-entry.note {
            color: #f0ebe0;
        }

        .stream-entry.decision {
            color: #d4cfc4;
        }

        .stream-entry.chord {
            color: #c8c3b8;
        }

        .stream-entry.arpeggio {
            color: #e6d9a8;  /* Golden color for arpeggios */
        }

        .stream-entry.effect {
            color: #9a958a;
        }

        .stream-entry.silence {
            color: #3a3a3a;
        }

        .stream-entry .time {
            color: #222;
            margin-right: 4px;
        }

        .stream-entry .freq {
            color: #444;
            font-size: 8px;
        }

        /* Note visualization bar */
        .note-bar {
            height: 2px;
            background: linear-gradient(90deg, #d4cfc4, transparent);
            margin: 2px 0;
            width: 100%;
            transform-origin: left center;
            animation: noteDecay 3s ease-out forwards;
            will-change: transform, opacity;
        }

        @keyframes noteDecay {
            from { transform: scaleX(1); opacity: 1; }
            to { transform: scaleX(0); opacity: 0; }
        }

        .stream-effects {
            padding: 4px 6px;
            background: #080808;
            border-top: 1px solid #111;
            font-size: 7px;
        }

        .fx-row {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 2px;
        }

        .fx-row span {
            color: #333;
            width: 20px;
        }

        .fx-bar {
            flex: 1;
            height: 3px;
            background: #111;
        }

        .fx-fill {
            height: 100%;
            background: #b8b3a8;
            width: 100%;
            transform-origin: left center;
            transform: scaleX(var(--fx-level, 0));
            transition: transform var(--fx-duration, 2s) cubic-bezier(0.4, 0, 0.2, 1), background 1s ease;
            will-change: transform;
        }

        /* Pan bar with center marker */
        .pan-bar {
            position: relative;
            background: linear-gradient(to right, #111 0%, #222 50%, #111 100%);
        }

        .pan-bar::after {
            content: '│';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #333;
            font-size: 6px;
            line-height: 3px;
        }

        .pan-marker {
            position: absolute;
            width: 4px;
            height: 100%;
            background: #d4cfc4;
            left: 50%;
            transform: translateX(-50%);
            transition: left var(--pan-duration, 2.5s) cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Echo and Reverb specific colors */
        .echo-fill {
            background: #a8a49a;
        }
        .reverb-fill {
            background: #908c82;
        }
        
        /* Additional effect colors */
        .delay-time-fill { background: #9c9890; }
        .delay-fb-fill { background: #b0aca4; }
        .reverb-decay-fill { background: #848078; }
        .reverb-tone-fill { background: #989488; }
        .vib-depth-fill { background: #c4c0b8; }
        .vib-speed-fill { background: #a8a4a0; }
        .trm-depth-fill { background: #d0ccc4; }
        .trm-speed-fill { background: #b4b0a8; }
        
        /* EQ bars - centered at middle, can go left (cut) or right (boost) */
        .eq-bar {
            position: relative;
            background: linear-gradient(to right, #1a1818 0%, #111 50%, #181a18 100%);
        }
        .eq-bar::after {
            content: '│';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #333;
            font-size: 6px;
            line-height: 3px;
        }
        .eq-marker {
            position: absolute;
            width: 4px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
            transition: left var(--eq-duration, 2.5s) cubic-bezier(0.4, 0, 0.2, 1);
        }
        .eq-low { background: #8c8880; }
        .eq-mid { background: #a8a49c; }
        .eq-high { background: #c0bcb4; }
        
        /* FX section header */
        .fx-section-label {
            color: #222;
            font-size: 6px;
            text-transform: uppercase;
            margin: 3px 0 1px 0;
            letter-spacing: 1px;
        }

        .stream-stats {
            padding: 4px 6px;
            background: #0a0a0a;
            border-top: 1px solid #111;
            font-size: 8px;
            color: #333;
            text-align: center;
        }

        .stream-stats span {
            color: #e8e4d9;
        }

        .stream-stats span.off {
            color: #6a6560;
        }

        /* Fade overlay at top */
        .stream-column::before {
            content: '';
            position: absolute;
            top: 28px;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom, #050505, transparent);
            z-index: 5;
            pointer-events: none;
        }

        /* RIGHT PANEL - Controls & Logs */
        .control-panel {
            background: #0a0a0a;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* ASCII Header */
        .ascii-header {
            padding: 10px;
            border-bottom: 1px solid #1a1a1a;
            white-space: pre;
            font-size: 8px;
            color: #333;
            text-align: center;
            line-height: 1.1;
        }

        .ascii-header .highlight {
            color: #8a857a;
        }

        /* Ticket Style Info */
        .ticket {
            border: 1px dashed #333;
            margin: 8px;
            padding: 8px;
            background: #0d0d0d;
        }

        .ticket-header {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px dotted #222;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }

        .ticket-row {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            color: #666;
        }

        .ticket-row .label {
            color: #444;
        }

        .ticket-row .value {
            color: #e8e4d9;
            font-weight: bold;
        }
        
        .ticket-row .value-select {
            color: #e8e4d9;
            font-weight: bold;
            background: transparent;
            border: none;
            font-family: inherit;
            font-size: inherit;
            cursor: pointer;
            padding: 0;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            max-width: 120px;
        }
        
        .ticket-row .value-select:hover {
            background: #1a1a1a;
        }
        
        .ticket-row .value-select option {
            background: #0a0a0a;
            color: #e8e4d9;
        }

        .ticket-barcode {
            text-align: center;
            padding: 8px 0 4px 0;
            letter-spacing: 2px;
            color: #222;
            font-size: 10px;
        }

        /* Controls */
        .controls-section {
            padding: 8px;
            border-bottom: 1px solid #1a1a1a;
        }

        .btn-row {
            display: flex;
            gap: 4px;
            margin-bottom: 4px;
        }

        button {
            flex: 1;
            background: #0a0a0a;
            border: 1px solid #3a3a3a;
            color: #c8c4b8;
            padding: 8px 4px;
            font-family: inherit;
            font-size: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: #151515;
            border-color: #6a6560;
        }

        button:disabled {
            color: #3a3a3a;
            border-color: #1a1a1a;
            cursor: not-allowed;
        }

        button.active {
            background: #141414;
            border-color: #8a857a;
        }

        button.recording {
            background: #1a0a0a;
            border-color: #ff0000;
            color: #ff0000;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

        /* BPM Slider */
        .bpm-control {
            margin-top: 8px;
            padding: 6px 0;
        }

        .bpm-label {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #666;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .bpm-label span:last-child {
            color: #c8c4b8;
            font-weight: bold;
        }

        #bpmSlider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #1a1a1a;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        #bpmSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #c8c4b8;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #0a0a0a;
        }

        #bpmSlider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #c8c4b8;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #0a0a0a;
        }

        #bpmSlider:hover::-webkit-slider-thumb {
            background: #e8e4d8;
        }

        /* Motif Stave */
        .motif-section {
            border: 1px dashed #333;
            margin: 8px;
            padding: 8px;
            background: #0d0d0d;
        }

        .motif-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .motif-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .motif-playing {
            color: #8a8;
            font-size: 8px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .motif-playing.active {
            opacity: 1;
        }

        .motif-regenerate {
            background: transparent;
            border: 1px solid #333;
            color: #666;
            padding: 2px 6px;
            font-size: 8px;
            cursor: pointer;
            font-family: inherit;
        }

        .motif-regenerate:hover {
            border-color: #555;
            color: #999;
        }

        .motif-buttons {
            display: flex;
            gap: 4px;
        }

        .stave-container {
            position: relative;
            height: 80px;
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            overflow: hidden;
        }

        .stave-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .stave-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: #222;
        }

        .stave-notes {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            padding: 0 4px;
        }

        .stave-note-slot {
            flex: 1;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
        }

        .stave-note-slot:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .stave-note {
            width: 12px;
            height: 10px;
            background: #c8c4b8;
            border-radius: 50%;
            transform: rotate(-15deg);
            position: absolute;
            transition: top 0.15s ease-out, background 0.2s;
            box-shadow: 0 0 4px rgba(200, 196, 184, 0.3);
        }

        .stave-note.playing {
            background: #ffd700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
        }

        .stave-note.empty {
            background: #333;
            opacity: 0.3;
            box-shadow: none;
        }

        .stave-note-label {
            position: absolute;
            bottom: 2px;
            font-size: 7px;
            color: #555;
            text-align: center;
            width: 100%;
        }

        .stave-ledger {
            position: absolute;
            width: 18px;
            height: 1px;
            background: #333;
            left: 50%;
            transform: translateX(-50%);
        }

        .stave-help {
            font-size: 8px;
            color: #444;
            text-align: center;
            margin-top: 4px;
            letter-spacing: 0.5px;
        }

        /* Log Panel */
        .log-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .log-header {
            padding: 6px 8px;
            background: #0d0d0d;
            border-bottom: 1px solid #1a1a1a;
            color: #444;
            font-size: 10px;
            display: flex;
            justify-content: space-between;
        }

        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 4px 8px;
            font-size: 9px;
            background: #080808;
        }

        .log-entry {
            padding: 2px 0;
            border-bottom: 1px dotted #111;
            display: flex;
            gap: 8px;
        }

        .log-time {
            color: #333;
            min-width: 50px;
        }

        .log-type {
            min-width: 60px;
        }

        .log-type.note { color: #c8c4b8; }
        .log-type.chord { color: #a8a49c; }
        .log-type.effect { color: #908c84; }
        .log-type.system { color: #5a5a5a; }
        .log-type.decision { color: #d4d0c8; }
        .log-type.weather { color: #6a6660; }

        .log-msg {
            color: #444;
            flex: 1;
        }

        /* Weather Display (per-channel) */
        .channel-weather {
            padding: 4px 6px;
            border-top: 1px solid #1a1a1a;
            background: #080808;
        }
        
        .channel-weather .wx-header {
            font-size: 7px;
            color: #335;
            margin-bottom: 3px;
            letter-spacing: 1px;
        }
        
        .weather-display {
            padding: 8px;
            border-top: 1px solid #1a1a1a;
            background: #080808;
        }
        
        .weather-header {
            font-size: 9px;
            color: #446;
            margin-bottom: 6px;
            letter-spacing: 1px;
        }
        
        .weather-grid {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .weather-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 7px;
        }
        
        .wx-label {
            color: #335;
            width: 45px;
            text-transform: lowercase;
        }
        
        .wx-bar {
            flex: 1;
            height: 3px;
            background: #111;
            position: relative;
            overflow: hidden;
        }
        
        .wx-bar::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #4a4640, #7a756c);
            width: 100%;
            transform-origin: left center;
            transform: scaleX(var(--wx-level, 0.5));
            transition: transform var(--wx-duration, 4s) cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }

        /* Effects Bar */
        .effects-bar {
            padding: 8px;
            border-top: 1px solid #1a1a1a;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            font-size: 9px;
        }

        .effect-item {
            text-align: center;
        }

        .effect-label {
            color: #333;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .effect-bar {
            height: 4px;
            background: #111;
            position: relative;
        }

        .effect-fill {
            height: 100%;
            background: #a8a49c;
            transition: width 2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        ::-webkit-scrollbar-thumb {
            background: #222;
        }

        /* Hidden file input */
        #loadFile {
            display: none;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Left: Instrument Code Streams -->
        <div class="viz-panel" id="vizPanel" title="Live visualization of each instrument's activity and parameters"></div>

        <!-- Right: Controls & Logs -->
        <div class="control-panel" title="System controls, composition data, and activity log">
            <!-- ASCII Art Header -->
            <div class="ascii-header" title="Drift v3 - Generative ambient music synthesizer">
<span class="highlight">┌─────────────────────────────┐</span>
<span class="highlight">│</span>   Drift v3 <span style="color:#6a6560">- generative music</span>  <span class="highlight">│</span>
<span class="highlight">│</span>   <span style="color:#4a4540">by Peter Baumgartner</span>      <span class="highlight">│</span>
<span class="highlight">│</span>   <a href="README.md" style="color:#5a5550;text-decoration:none;" title="Read the documentation">README.md</a>                   <span class="highlight">│</span>
<span class="highlight">└─────────────────────────────┘</span>
            </div>

            <!-- Ticket-style Info -->
            <div class="ticket">
                <div class="ticket-header" title="Current musical parameters for this session">
                    <span>COMPOSITION DATA</span>
                    <span id="ticketId" title="Unique session identifier">────────</span>
                </div>
                <div class="ticket-row" title="The tonal center - all notes relate to this pitch. Click to change.">
                    <span class="label">ROOT/</span>
                    <select class="value-select" id="rootSelect" title="Select root note (C, C#, D, etc.)">
                        <option value="">──</option>
                    </select>
                </div>
                <div class="ticket-row" title="Major or Minor tonality. Click to change.">
                    <span class="label">QUAL/</span>
                    <select class="value-select" id="qualitySelect" title="Select Major or Minor">
                        <option value="Major">Major</option>
                        <option value="Minor">Minor</option>
                    </select>
                </div>
                <div class="ticket-row" title="Current chord voicing - changes every 15-30 seconds. Click to change.">
                    <span class="label">CHORD/</span>
                    <select class="value-select" id="chordSelect" title="Select chord (triads, 7ths, inversions, etc.)">
                        <option value="">──────</option>
                    </select>
                </div>
                <div class="ticket-row" title="Elapsed time since playback started">
                    <span class="label">TIME/</span>
                    <span class="value" id="timeDisplay" title="Minutes:Seconds of current session">00:00</span>
                </div>
                <div class="ticket-barcode" title="Decorative barcode - purely aesthetic">║▌│█║▌║▌│║▌│█│║▌║▌│█║</div>
            </div>

            <!-- Motif Stave -->
            <div class="motif-section" title="Central melody - click notes to edit">
                <div class="motif-header">
                    <div class="motif-header-left">
                        <span>♪ MOTIF</span>
                        <span class="motif-playing" id="motifPlaying">● playing</span>
                    </div>
                    <div class="motif-buttons">
                        <button class="motif-regenerate" id="motifClear" title="Clear all notes">[✕]</button>
                        <button class="motif-regenerate" id="motifRegenerate" title="Generate a new random motif">[↻]</button>
                    </div>
                </div>
                <div class="stave-container" id="staveContainer">
                    <div class="stave-lines">
                        <!-- 5 staff lines -->
                        <div class="stave-line" style="top: 20%"></div>
                        <div class="stave-line" style="top: 35%"></div>
                        <div class="stave-line" style="top: 50%"></div>
                        <div class="stave-line" style="top: 65%"></div>
                        <div class="stave-line" style="top: 80%"></div>
                    </div>
                    <div class="stave-notes" id="staveNotes">
                        <!-- Notes will be generated here -->
                    </div>
                </div>
                <div class="stave-help">click to add/edit • right-click to delete</div>
            </div>

            <!-- Control Buttons -->
            <div class="controls-section" title="Playback and configuration controls">
                <div class="btn-row">
                    <button id="startBtn" title="Initialize audio system and begin generative playback">[▶] INIT</button>
                    <button id="randomizeBtn" disabled title="Randomize key, mode, and instrument configurations">[↻] RAND</button>
                    <button id="stopBtn" disabled title="Stop all playback and silence instruments">[■] STOP</button>
                </div>
                <div class="btn-row">
                    <button id="saveBtn" disabled title="Save current configuration to a JSON file">[↓] SAVE</button>
                    <button id="loadBtn" title="Load a previously saved configuration">[↑] LOAD</button>
                    <button id="recordBtn" disabled title="Record audio output to a file">[●] REC</button>
                </div>
                <input type="file" id="loadFile" accept=".json">
                
                <!-- BPM Slider -->
                <div class="bpm-control" title="Adjust overall tempo - affects all instrument timing">
                    <div class="bpm-label">
                        <span>BPM</span>
                        <span id="bpmValue">60</span>
                    </div>
                    <input type="range" id="bpmSlider" min="20" max="120" value="60" title="Drag to change tempo (20-120 BPM)">
                </div>
            </div>

            <!-- Live Log -->
            <div class="log-section">
                <div class="log-header" title="Real-time log of musical decisions and system events">
                    <span>▌ SYSTEM LOG</span>
                    <span id="logCount" title="Total log entries">0</span>
                </div>
                <div class="log-container" id="logContainer">
                    <div class="log-entry">
                        <span class="log-time">──:──</span>
                        <span class="log-type system">BOOT</span>
                        <span class="log-msg">Awaiting initialization...</span>
                    </div>
                </div>
            </div>

            <!-- Global Effects Info (per-channel bars are in instrument columns) -->
            <div class="effects-bar" title="Note: All audio effects are applied per-channel in the instrument columns above">
                <div class="effect-item">
                    <div class="effect-label" style="font-size: 7px; color: #555" title="Effects are independently controlled for each instrument">ALL FX PER-CHANNEL ↑</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════
        // INSTRUMENT STREAM LOGGING
        // ═══════════════════════════════════════════════════════════════
        
        const INSTRUMENT_DEFS = [
            { id: 'violins', domId: 'violins', label: 'VIOLINS', headerTitle: 'High strings with airy bowing and shimmering sustain.' },
            { id: 'cello', domId: 'cello', label: 'CELLO', headerTitle: 'Warm low-mid strings with expressive bowing.' },
            { id: 'bass', domId: 'bass', label: 'BASS', headerTitle: 'Deep bass foundation and slow resonance.' },
            { id: 'harp', domId: 'harp', label: 'HARP', headerTitle: 'Harp-like plucks with a wide resonant range.' },
            { id: 'piano', domId: 'piano', label: 'PIANO', headerTitle: 'Felt/soft piano for delicate motifs.' },
            { id: 'guitar', domId: 'guitar', label: 'GUITAR', headerTitle: 'Nylon/ukulele-style plucks, gentle and innocent.' },
            { id: 'celeste', domId: 'celeste', label: 'CELESTE', headerTitle: 'Bell-like crystalline tones in the high register.' },
            { id: 'rhodes', domId: 'rhodes', label: 'RHODES', headerTitle: 'Warm electric piano tones with soft tremolo.' },
            { id: 'vibraphone', domId: 'vibes', label: 'VIBES', headerTitle: 'Metallic mallet tones with motor shimmer.' },
            { id: 'whistle', domId: 'whistle', label: 'WHISTLE', headerTitle: 'Tin whistle/ocarina/shakuhachi breathy color.' },
            { id: 'flute', domId: 'flute', label: 'FLUTE', headerTitle: 'Flute/piccolo air and light.' },
            { id: 'oboe', domId: 'oboe', label: 'OBOE', headerTitle: 'Reedy oboe/English horn voice.' },
            { id: 'clarinet', domId: 'clarinet', label: 'CLARINET', headerTitle: 'Smooth clarinet/bass clarinet timbre.' },
            { id: 'bassoon', domId: 'bassoon', label: 'BASSOON', headerTitle: 'Wooden bassoon foundation.' },
            { id: 'woodwinds', domId: 'woodwinds', label: 'WOODWINDS', headerTitle: 'Colorful woodwind ensemble wash.' },
            { id: 'horns', domId: 'horns', label: 'HORNS', headerTitle: 'Warm horn choir with noble swell.' },
            { id: 'trumpet', domId: 'trumpet', label: 'TRUMPET', headerTitle: 'Bright trumpet calls and shimmer.' },
            { id: 'lowbrass', domId: 'lowbrass', label: 'LOW BRASS', headerTitle: 'Trombones/tuba weight and depth.' },
            { id: 'brass', domId: 'brass', label: 'BRASS', headerTitle: 'Full brass ensemble glow.' }
        ];
        
        const INSTRUMENT_ORDER = INSTRUMENT_DEFS.map((inst) => inst.id);
        const INSTRUMENT_CAPABILITIES = {
            violins: { canSwell: true, canVibrato: true, canTremolo: true },
            cello: { canSwell: true, canVibrato: true, canTremolo: true },
            bass: { canSwell: true, canVibrato: true, canTremolo: true },
            harp: { canSwell: false, canVibrato: false, canTremolo: false },
            piano: { canSwell: false, canVibrato: false, canTremolo: false },
            guitar: { canSwell: false, canVibrato: true, canTremolo: false },
            celeste: { canSwell: false, canVibrato: false, canTremolo: false },
            rhodes: { canSwell: false, canVibrato: false, canTremolo: true },
            vibraphone: { canSwell: false, canVibrato: false, canTremolo: true },
            whistle: { canSwell: true, canVibrato: true, canTremolo: false },
            flute: { canSwell: true, canVibrato: true, canTremolo: false },
            oboe: { canSwell: true, canVibrato: true, canTremolo: false },
            clarinet: { canSwell: true, canVibrato: true, canTremolo: false },
            bassoon: { canSwell: true, canVibrato: true, canTremolo: false },
            woodwinds: { canSwell: true, canVibrato: true, canTremolo: false },
            horns: { canSwell: true, canVibrato: true, canTremolo: false },
            trumpet: { canSwell: true, canVibrato: true, canTremolo: false },
            lowbrass: { canSwell: true, canVibrato: true, canTremolo: false },
            brass: { canSwell: true, canVibrato: true, canTremolo: false }
        };
        
        // ═══════════════════════════════════════════════════════════════
        // REALISTIC INSTRUMENT SYNTHESIS - Harmonic profiles & techniques
        // ═══════════════════════════════════════════════════════════════
        
        // Harmonic profiles for additive synthesis (relative amplitudes)
        // Each instrument has partials that define its timbre
        const HARMONIC_PROFILES = {
            // STRINGS - Rich odd/even harmonics, sawlike but warmer
            violins: {
                harmonics: [1, 0.5, 0.33, 0.25, 0.2, 0.15, 0.12, 0.1, 0.08, 0.06],
                noiseType: 'bow', noiseAmount: 0.03,
                formants: [800, 1200, 2800], formantQ: 4,
                detuneSpread: 8, oscillators: 3
            },
            cello: {
                harmonics: [1, 0.6, 0.35, 0.25, 0.18, 0.12, 0.08, 0.05],
                noiseType: 'bow', noiseAmount: 0.025,
                formants: [250, 600, 2200], formantQ: 3,
                detuneSpread: 6, oscillators: 3
            },
            bass: {
                harmonics: [1, 0.7, 0.4, 0.2, 0.1, 0.05],
                noiseType: 'bow', noiseAmount: 0.02,
                formants: [150, 400], formantQ: 2,
                detuneSpread: 4, oscillators: 2
            },
            
            // PLUCKED - Strong attack, quick decay harmonics
            harp: {
                harmonics: [1, 0.7, 0.3, 0.15, 0.08, 0.04],
                noiseType: 'pluck', noiseAmount: 0.08,
                formants: [1000, 3000], formantQ: 2,
                detuneSpread: 3, oscillators: 2,
                hasBodyResonance: true
            },
            piano: {
                harmonics: [1, 0.8, 0.5, 0.35, 0.25, 0.18, 0.12, 0.08, 0.05],
                noiseType: 'hammer', noiseAmount: 0.12,
                formants: [400, 1200, 3500], formantQ: 3,
                detuneSpread: 4, oscillators: 3,
                hasBodyResonance: true,
                inharmonicity: 0.0005 // Piano strings are slightly inharmonic
            },
            guitar: {
                harmonics: [1, 0.65, 0.4, 0.25, 0.15, 0.08],
                noiseType: 'pluck', noiseAmount: 0.1,
                formants: [300, 900, 2500], formantQ: 3,
                detuneSpread: 2, oscillators: 2,
                hasBodyResonance: true
            },
            
            // BELLS/KEYS - Inharmonic partials, metallic
            celeste: {
                harmonics: [1, 0, 0.4, 0, 0.2, 0, 0.1], // Odd harmonics emphasized
                noiseType: 'strike', noiseAmount: 0.05,
                formants: [2500, 5000], formantQ: 8,
                detuneSpread: 2, oscillators: 2,
                inharmonicity: 0.002
            },
            rhodes: {
                harmonics: [1, 0.6, 0.3, 0.15, 0.08],
                noiseType: 'tine', noiseAmount: 0.06,
                formants: [800, 2000], formantQ: 4,
                detuneSpread: 3, oscillators: 2
            },
            vibraphone: {
                harmonics: [1, 0, 0.35, 0, 0.15, 0, 0.06],
                noiseType: 'mallet', noiseAmount: 0.04,
                formants: [1500, 3500], formantQ: 6,
                detuneSpread: 2, oscillators: 2,
                inharmonicity: 0.003
            },
            
            // WOODWINDS - Formant-heavy, breath noise
            whistle: {
                harmonics: [1, 0.1, 0.05], // Almost pure sine
                noiseType: 'breath', noiseAmount: 0.15,
                formants: [1800, 3200], formantQ: 8,
                detuneSpread: 1, oscillators: 1
            },
            flute: {
                harmonics: [1, 0.3, 0.1, 0.03],
                noiseType: 'breath', noiseAmount: 0.12,
                formants: [800, 2000, 4000], formantQ: 6,
                detuneSpread: 1, oscillators: 1
            },
            oboe: {
                harmonics: [1, 0.8, 0.6, 0.45, 0.35, 0.25, 0.18, 0.12],
                noiseType: 'reed', noiseAmount: 0.06,
                formants: [500, 1400, 2800], formantQ: 10,
                detuneSpread: 2, oscillators: 2
            },
            clarinet: {
                harmonics: [1, 0.1, 0.75, 0.05, 0.5, 0.03, 0.3], // Odd harmonics (closed pipe)
                noiseType: 'reed', noiseAmount: 0.04,
                formants: [400, 1200, 2400], formantQ: 8,
                detuneSpread: 2, oscillators: 2
            },
            bassoon: {
                harmonics: [1, 0.7, 0.5, 0.4, 0.3, 0.2, 0.15, 0.1],
                noiseType: 'reed', noiseAmount: 0.05,
                formants: [450, 1100, 2000], formantQ: 6,
                detuneSpread: 3, oscillators: 2
            },
            woodwinds: {
                harmonics: [1, 0.5, 0.35, 0.2, 0.12, 0.08],
                noiseType: 'breath', noiseAmount: 0.08,
                formants: [600, 1500, 3000], formantQ: 5,
                detuneSpread: 4, oscillators: 3
            },
            
            // BRASS - Bright, buzzy, formant-rich
            horns: {
                harmonics: [1, 0.7, 0.55, 0.4, 0.3, 0.22, 0.15, 0.1, 0.06],
                noiseType: 'buzz', noiseAmount: 0.03,
                formants: [400, 1200, 2400], formantQ: 5,
                detuneSpread: 5, oscillators: 3
            },
            trumpet: {
                harmonics: [1, 0.8, 0.65, 0.5, 0.4, 0.3, 0.22, 0.15, 0.1],
                noiseType: 'buzz', noiseAmount: 0.04,
                formants: [1200, 2000, 3500], formantQ: 6,
                detuneSpread: 3, oscillators: 2
            },
            lowbrass: {
                harmonics: [1, 0.75, 0.55, 0.4, 0.28, 0.18, 0.1, 0.05],
                noiseType: 'buzz', noiseAmount: 0.03,
                formants: [300, 900, 1800], formantQ: 4,
                detuneSpread: 4, oscillators: 3
            },
            brass: {
                harmonics: [1, 0.7, 0.5, 0.38, 0.28, 0.2, 0.13, 0.08],
                noiseType: 'buzz', noiseAmount: 0.035,
                formants: [500, 1400, 2600], formantQ: 5,
                detuneSpread: 5, oscillators: 3
            }
        };
        
        // ═══════════════════════════════════════════════════════════════
        // DISASTERPEACE STYLE FEATURES
        // ═══════════════════════════════════════════════════════════════
        
        const DISASTERPEACE_CONFIG = {
            // Sidechain pumping
            sidechain: {
                enabled: true,
                attackTime: 0.005,
                releaseTime: 0.15,
                ratio: 0.3,          // How much to duck (0.3 = duck to 30%)
                pulseInterval: 500   // ms between pumps (synced to tempo)
            },
            
            // Arpeggiator
            arpeggiator: {
                enabled: true,
                patterns: ['up', 'down', 'updown', 'random'],
                divisions: [8, 16],  // 8th and 16th notes
                gateLength: 0.7      // Note length as fraction of step
            },
            
            // Bitcrusher
            bitcrusher: {
                enabled: true,
                bitDepth: 12,        // Reduce to 12-bit
                sampleRateReduction: 2, // Halve sample rate
                mixAmount: 0.15      // Subtle blend
            },
            
            // Tape wobble / pitch drift
            tapeWobble: {
                enabled: true,
                rate: 0.3,           // Hz
                depth: 4,            // cents
                randomness: 0.4
            },
            
            // Rhythmic gate
            rhythmicGate: {
                enabled: true,
                patterns: [
                    [1,0,1,0,1,0,1,0],        // Basic 8ths
                    [1,0,0,1,0,0,1,0],        // Syncopated
                    [1,1,0,1,1,0,1,0],        // Dotted
                    [1,0,1,1,0,1,0,1]         // Offbeat emphasis
                ],
                stepDuration: 125    // ms per step (synced to BPM)
            }
        };
        
        // Global sidechain state
        let sidechainPulseTime = 0;
        let sidechainGain = null;
        
        // Initialize sidechain compressor
        function initSidechain(audioCtx, masterGain) {
            if (!DISASTERPEACE_CONFIG.sidechain.enabled) return null;
            
            sidechainGain = audioCtx.createGain();
            sidechainGain.gain.value = 1;
            
            // Schedule pumping
            const pump = () => {
                if (!isPlaying) return;
                
                const now = audioCtx.currentTime;
                const config = DISASTERPEACE_CONFIG.sidechain;
                const tempo = parseInt(document.getElementById('bpmSlider')?.value || 60);
                const beatMs = (60000 / tempo) / 2; // Half beat for pumping
                
                // Duck
                sidechainGain.gain.setValueAtTime(1, now);
                sidechainGain.gain.linearRampToValueAtTime(config.ratio, now + config.attackTime);
                sidechainGain.gain.linearRampToValueAtTime(1, now + config.attackTime + config.releaseTime);
                
                setTimeout(pump, beatMs);
            };
            
            return sidechainGain;
        }
        
        // Create noise burst for instrument attacks
        function createNoiseNode(audioCtx, type, duration) {
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                let noise = Math.random() * 2 - 1;
                
                // Shape noise based on type
                switch (type) {
                    case 'bow':
                        // Filtered pink-ish noise
                        noise *= (1 - i / bufferSize) * 0.5;
                        break;
                    case 'pluck':
                    case 'hammer':
                    case 'strike':
                    case 'mallet':
                    case 'tine':
                        // Sharp attack burst
                        noise *= Math.exp(-i / (bufferSize * 0.1));
                        break;
                    case 'breath':
                        // Sustained breathy noise
                        noise *= 0.5 + 0.5 * Math.sin(i / bufferSize * Math.PI);
                        break;
                    case 'reed':
                    case 'buzz':
                        // Buzzy sustained
                        noise *= (0.3 + 0.7 * (1 - i / bufferSize));
                        break;
                }
                
                data[i] = noise;
            }
            
            const noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = buffer;
            return noiseSource;
        }
        
        // Create formant filter bank
        function createFormantFilters(audioCtx, formants, Q) {
            return formants.map(freq => {
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = freq;
                filter.Q.value = Q;
                return filter;
            });
        }
        
        // Orchestral pan positions (audience perspective, -1 = left, 1 = right)
        // Based on traditional symphony orchestra seating
        const ORCHESTRAL_PAN = {
            // Strings - spread across front
            violins: -0.7,      // First violins: left
            cello: 0.5,         // Cellos: right of center  
            bass: 0.75,         // Basses: far right
            harp: -0.85,        // Harp: far left
            
            // Keyboards - left-center area
            piano: -0.25,       // Piano: left of center
            celeste: -0.4,      // Celeste: left
            rhodes: 0.15,       // Rhodes: slightly right
            vibraphone: 0.3,    // Vibes: right of center
            guitar: -0.15,      // Guitar: near center-left
            
            // Woodwinds - center, slightly spread
            flute: -0.2,        // Flute: left of center
            oboe: 0.05,         // Oboe: center
            clarinet: -0.1,     // Clarinet: near center
            bassoon: 0.2,       // Bassoon: right of center
            whistle: -0.35,     // Whistle: left (ethnic color)
            woodwinds: 0.0,     // Woodwind ensemble: center
            
            // Brass - back, right-center
            horns: -0.3,        // Horns: left-center (traditional)
            trumpet: 0.4,       // Trumpets: right of center
            lowbrass: 0.55,     // Trombones/tuba: right
            brass: 0.25         // Brass ensemble: right of center
        };
        
        // Get orchestral pan position with slight variation
        function getOrchestraPan(instrument) {
            const basePan = ORCHESTRAL_PAN[instrument] || 0;
            // Add subtle variation (±0.1) to prevent static image
            const variation = (Math.random() - 0.5) * 0.2;
            return Math.max(-1, Math.min(1, basePan + variation));
        }
        
        const streamDomIds = Object.fromEntries(INSTRUMENT_DEFS.map((inst) => [inst.id, inst.domId]));
        
        const WEATHER_FIELDS = [
            { key: 'presence', label: 'presence', title: 'Volume/presence level - low=quiet, high=prominent' },
            { key: 'density', label: 'density', title: 'Note frequency - low=sparse, high=busy' },
            { key: 'intimacy', label: 'intimacy', title: 'Reverb mix - low=distant/wet, high=close/dry' },
            { key: 'breath', label: 'breath', title: 'Note attack time - low=soft, high=sharp' },
            { key: 'decay', label: 'decay', title: 'Note release time - low=short, high=sustained' },
            { key: 'drift', label: 'drift', title: 'Pitch instability - low=stable, high=wobbly' },
            { key: 'depth', label: 'depth', title: 'Register tendency - low=bass, high=treble' },
            { key: 'suspension', label: 'suspension', title: 'Timing flexibility - low=tight, high=rubato' },
            { key: 'solitude', label: 'solitude', title: 'Independence - low=responsive, high=isolated' },
            { key: 'memory', label: 'memory', title: 'Repetition tendency - low=novel, high=familiar' },
            { key: 'complexity', label: 'complexity', title: 'Harmonic complexity - low=simple triads, high=altered/extended chords' },
            { key: 'expansiveness', label: 'expansiveness', title: 'Voicing spread - low=tight clusters, high=wide orchestral voicings' }
        ];
        
        function buildEffectsMarkup(id) {
            return `
                <div class="stream-effects" title="Audio effects applied to this channel">
                    <div class="fx-section-label" title="Pitch modulation effect">vibrato</div>
                    <div class="fx-row" title="Vibrato depth - how much the pitch bends"><span>DPT</span><div class="fx-bar"><div class="fx-fill vib-depth-fill" id="${id}-vib-depth"></div></div></div>
                    <div class="fx-row" title="Vibrato amount - wet/dry mix"><span>AMT</span><div class="fx-bar"><div class="fx-fill" id="${id}-vib"></div></div></div>
                    <div class="fx-row" title="Vibrato speed - oscillation rate in Hz"><span>SPD</span><div class="fx-bar"><div class="fx-fill vib-speed-fill" id="${id}-vib-speed"></div></div></div>
                    <div class="fx-section-label" title="Volume modulation effect">tremolo</div>
                    <div class="fx-row" title="Tremolo depth - how much volume changes"><span>DPT</span><div class="fx-bar"><div class="fx-fill trm-depth-fill" id="${id}-trm-depth"></div></div></div>
                    <div class="fx-row" title="Tremolo amount - wet/dry mix"><span>AMT</span><div class="fx-bar"><div class="fx-fill" id="${id}-trm"></div></div></div>
                    <div class="fx-row" title="Tremolo speed - pulse rate in Hz"><span>SPD</span><div class="fx-bar"><div class="fx-fill trm-speed-fill" id="${id}-trm-speed"></div></div></div>
                    <div class="fx-section-label" title="Echo/repeat effect">delay</div>
                    <div class="fx-row" title="Delay time - gap between repeats"><span>TIM</span><div class="fx-bar"><div class="fx-fill delay-time-fill" id="${id}-delay-time"></div></div></div>
                    <div class="fx-row" title="Delay mix - wet/dry balance"><span>MIX</span><div class="fx-bar"><div class="fx-fill echo-fill" id="${id}-echo"></div></div></div>
                    <div class="fx-row" title="Delay feedback - how many repeats"><span>FBK</span><div class="fx-bar"><div class="fx-fill delay-fb-fill" id="${id}-delay-fb"></div></div></div>
                    <div class="fx-section-label" title="Room/space simulation">reverb</div>
                    <div class="fx-row" title="Reverb mix - wet/dry balance"><span>MIX</span><div class="fx-bar"><div class="fx-fill reverb-fill" id="${id}-reverb"></div></div></div>
                    <div class="fx-row" title="Reverb decay - how long it rings"><span>DEC</span><div class="fx-bar"><div class="fx-fill reverb-decay-fill" id="${id}-reverb-decay"></div></div></div>
                    <div class="fx-row" title="Reverb tone - brightness of reflections"><span>TON</span><div class="fx-bar"><div class="fx-fill reverb-tone-fill" id="${id}-reverb-tone"></div></div></div>
                    <div class="fx-section-label" title="3-band equalizer">eq</div>
                    <div class="fx-row" title="Low shelf EQ - bass frequencies (~100Hz)"><span>LOW</span><div class="fx-bar eq-bar"><div class="eq-marker eq-low" id="${id}-eq-low"></div></div></div>
                    <div class="fx-row" title="Mid peak EQ - midrange frequencies (~1kHz)"><span>MID</span><div class="fx-bar eq-bar"><div class="eq-marker eq-mid" id="${id}-eq-mid"></div></div></div>
                    <div class="fx-row" title="High shelf EQ - treble frequencies (~4kHz)"><span>HI</span><div class="fx-bar eq-bar"><div class="eq-marker eq-high" id="${id}-eq-high"></div></div></div>
                    <div class="fx-section-label" title="Stereo position">pan</div>
                    <div class="fx-row" title="Pan position - left/right in stereo field"><span>L/R</span><div class="fx-bar pan-bar"><div class="pan-marker" id="${id}-pan"></div></div></div>
                </div>
            `;
        }
        
        function buildWeatherMarkup(id) {
            const rows = WEATHER_FIELDS.map((field) => (
                `<div class="weather-item" title="${field.title}"><span class="wx-label">${field.label}</span><span class="wx-bar" id="${id}-wx-${field.key}"></span></div>`
            )).join('');
            
            return `
                <div class="channel-weather" title="Slow-drifting atmospheric parameters unique to this channel">
                    <div class="wx-header" title="Weather changes every 1-2 minutes">WEATHER</div>
                    <div class="weather-grid">${rows}</div>
                </div>
            `;
        }
        
        function buildStreamColumn(def) {
            const id = def.domId;
            return `
            <div class="stream-column" id="stream-${id}">
                <div class="stream-header" title="${def.headerTitle}"><span class="inst-name">${def.label}</span></div>
                <div class="stream-content" title="Live activity log showing notes, chords, and decisions"><div class="stream-log"></div></div>
                ${buildEffectsMarkup(id)}
                ${buildWeatherMarkup(id)}
                <div class="stream-stats" title="Note count and current mode"><span id="${id}-count" title="Notes played">0</span>n | <span id="${id}-mode" title="Current playing mode">--</span></div>
            </div>
            `;
        }
        
        const vizPanel = document.getElementById('vizPanel');
        if (vizPanel) {
            vizPanel.innerHTML = INSTRUMENT_DEFS.map(buildStreamColumn).join('');
        }

        const streamDomCache = {};
        const effectDomCache = {};
        const weatherDomCache = {};
        
        INSTRUMENT_DEFS.forEach((inst) => {
            const domId = inst.domId;
            const column = document.getElementById(`stream-${domId}`);
            streamDomCache[inst.id] = {
                column: column || null,
                content: column ? column.querySelector('.stream-content') : null,
                log: column ? column.querySelector('.stream-log') : null,
                countEl: document.getElementById(`${domId}-count`),
                modeEl: document.getElementById(`${domId}-mode`)
            };
            
            effectDomCache[inst.id] = {
                vibDepthEl: document.getElementById(`${domId}-vib-depth`),
                vibEl: document.getElementById(`${domId}-vib`),
                vibSpeedEl: document.getElementById(`${domId}-vib-speed`),
                trmDepthEl: document.getElementById(`${domId}-trm-depth`),
                trmEl: document.getElementById(`${domId}-trm`),
                trmSpeedEl: document.getElementById(`${domId}-trm-speed`),
                delayTimeEl: document.getElementById(`${domId}-delay-time`),
                echoEl: document.getElementById(`${domId}-echo`),
                delayFbEl: document.getElementById(`${domId}-delay-fb`),
                reverbEl: document.getElementById(`${domId}-reverb`),
                reverbDecayEl: document.getElementById(`${domId}-reverb-decay`),
                reverbToneEl: document.getElementById(`${domId}-reverb-tone`),
                eqLowEl: document.getElementById(`${domId}-eq-low`),
                eqMidEl: document.getElementById(`${domId}-eq-mid`),
                eqHighEl: document.getElementById(`${domId}-eq-high`),
                panEl: document.getElementById(`${domId}-pan`)
            };
            
            const weatherEls = {};
            WEATHER_FIELDS.forEach((field) => {
                weatherEls[field.key] = document.getElementById(`${domId}-wx-${field.key}`);
            });
            weatherDomCache[inst.id] = weatherEls;
        });
        
        const instrumentCounts = Object.fromEntries(INSTRUMENT_DEFS.map((inst) => [inst.id, 0]));
        
        const streamIds = Object.fromEntries(INSTRUMENT_DEFS.map((inst) => [inst.id, `stream-${inst.domId}`]));
        
        const MAX_STREAM_ENTRIES = 50;
        const MAX_STREAM_FLUSH = 20;
        const streamBuffers = {};
        const streamPending = new Set();
        let streamFlushHandle = null;
        
        function flushStreamLogs() {
            streamFlushHandle = null;
            if (streamPending.size === 0) return;
            
            const nextPending = new Set();
            
            streamPending.forEach((instrument) => {
                const entries = streamBuffers[instrument];
                if (!entries || entries.length === 0) return;
                
                const dom = streamDomCache[instrument];
                const streamLogEl = dom && dom.log ? dom.log : null;
                if (!streamLogEl) {
                    entries.length = 0;
                    return;
                }
                
                const batch = entries.splice(0, MAX_STREAM_FLUSH);
                const fragment = document.createDocumentFragment();
                let noteCount = 0;
                
                batch.forEach(({ type, msg, extra, time }) => {
                    const entry = document.createElement('div');
                    entry.className = `stream-entry ${type}`;
                    
                    const timeEl = document.createElement('span');
                    timeEl.className = 'time';
                    timeEl.textContent = time;
                    entry.appendChild(timeEl);
                    entry.appendChild(document.createTextNode(msg));
                    
                    if (extra) {
                        const freqEl = document.createElement('span');
                        freqEl.className = 'freq';
                        freqEl.textContent = ` ${extra}`;
                        entry.appendChild(freqEl);
                    }
                    
                    fragment.appendChild(entry);
                    
                    if (type === 'note') {
                        noteCount++;
                        const bar = document.createElement('div');
                        bar.className = 'note-bar';
                        fragment.appendChild(bar);
                    }
                });
                
                streamLogEl.appendChild(fragment);
                
                if (noteCount > 0) {
                    instrumentCounts[instrument] += noteCount;
                    if (dom && dom.countEl) dom.countEl.textContent = instrumentCounts[instrument];
                }
                
                const excess = streamLogEl.children.length - MAX_STREAM_ENTRIES;
                for (let i = 0; i < excess; i++) {
                    streamLogEl.removeChild(streamLogEl.firstChild);
                }
                
                if (dom && dom.content) {
                    dom.content.scrollTop = dom.content.scrollHeight;
                }
                
                if (entries.length > 0) {
                    nextPending.add(instrument);
                }
            });
            
            streamPending.clear();
            nextPending.forEach((instrument) => streamPending.add(instrument));
            
            if (streamPending.size > 0) {
                streamFlushHandle = requestAnimationFrame(flushStreamLogs);
            }
        }
        
        function streamLog(instrument, type, msg, extra = '') {
            const streamId = streamIds[instrument];
            if (!streamId) return;
            
            const now = new Date();
            const time = now.toTimeString().slice(3, 8);
            
            if (!streamBuffers[instrument]) {
                streamBuffers[instrument] = [];
            }
            streamBuffers[instrument].push({ type, msg, extra, time });
            streamPending.add(instrument);
            
            if (!streamFlushHandle) {
                streamFlushHandle = requestAnimationFrame(flushStreamLogs);
            }
        }
        
        function updateStreamMode(instrument, isMelody, isOff = false) {
            const dom = streamDomCache[instrument];
            const el = dom && dom.modeEl ? dom.modeEl : document.getElementById(`${streamDomIds[instrument] || instrument}-mode`);
            if (el) {
                if (isOff) {
                    el.textContent = 'OFF';
                    el.classList.add('off');
                } else {
                    el.textContent = isMelody ? 'MEL' : 'CHD';
                    el.classList.remove('off');
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // LOGGING SYSTEM
        // ═══════════════════════════════════════════════════════════════
        
        let logCount = 0;
        const logContainer = document.getElementById('logContainer');
        const logCountEl = document.getElementById('logCount');
        const MAX_LOGS = 200;
        const MAX_LOG_FLUSH = 40;
        const logBuffer = [];
        let logFlushHandle = null;
        
        function flushLogBuffer() {
            logFlushHandle = null;
            if (!logContainer || logBuffer.length === 0) return;
            
            const fragment = document.createDocumentFragment();
            const pending = logBuffer.splice(0, MAX_LOG_FLUSH);
            
            pending.forEach(({ type, msg, time }) => {
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                
                const timeEl = document.createElement('span');
                timeEl.className = 'log-time';
                timeEl.textContent = time;
                
                const typeEl = document.createElement('span');
                typeEl.className = `log-type ${type}`;
                typeEl.textContent = type.toUpperCase();
                
                const msgEl = document.createElement('span');
                msgEl.className = 'log-msg';
                msgEl.textContent = msg;
                
                entry.appendChild(timeEl);
                entry.appendChild(typeEl);
                entry.appendChild(msgEl);
                fragment.appendChild(entry);
            });
            
            logContainer.appendChild(fragment);
            logCount += pending.length;
            if (logCountEl) logCountEl.textContent = logCount;
            
            // Auto-scroll
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Limit logs
            const excess = logContainer.children.length - MAX_LOGS;
            for (let i = 0; i < excess; i++) {
                logContainer.removeChild(logContainer.firstChild);
            }
            
            if (logBuffer.length > 0) {
                logFlushHandle = requestAnimationFrame(flushLogBuffer);
            }
        }
        
        function log(type, msg) {
            const now = new Date();
            const time = now.toTimeString().slice(0, 5);
            
            logBuffer.push({ type, msg, time });
            if (!logFlushHandle) {
                logFlushHandle = requestAnimationFrame(flushLogBuffer);
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // SCALES & MUSIC THEORY
        // ═══════════════════════════════════════════════════════════════
        
        const SCALES = {
            'Major': [0, 2, 4, 5, 7, 9, 11],
            'Minor': [0, 2, 3, 5, 7, 8, 10],
            'Dorian': [0, 2, 3, 5, 7, 9, 10],
            'Phrygian': [0, 1, 3, 5, 7, 8, 10],
            'Lydian': [0, 2, 4, 6, 7, 9, 11],
            'Mixolydian': [0, 2, 4, 5, 7, 9, 10],
            'Aeolian': [0, 2, 3, 5, 7, 8, 10],
            'Locrian': [0, 1, 3, 5, 6, 8, 10],
            'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11],
            'Melodic Minor': [0, 2, 3, 5, 7, 9, 11],
            'Whole Tone': [0, 2, 4, 6, 8, 10],
            'Pentatonic': [0, 2, 4, 7, 9],
            'Minor Pentatonic': [0, 3, 5, 7, 10],
            'Blues': [0, 3, 5, 6, 7, 10],
            'Japanese': [0, 1, 5, 7, 8],
            'Egyptian': [0, 2, 5, 7, 10],
            'Hirajoshi': [0, 2, 3, 7, 8]
        };

        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        const CHORD_TYPES = {
            // Simple - complexity 0-0.3
            triads: [
                { name: 'I', degrees: [0, 2, 4], complexity: 0.1 },
                { name: 'ii', degrees: [1, 3, 5], complexity: 0.1 },
                { name: 'iii', degrees: [2, 4, 6], complexity: 0.1 },
                { name: 'IV', degrees: [3, 5, 0], complexity: 0.1 },
                { name: 'V', degrees: [4, 6, 1], complexity: 0.1 },
                { name: 'vi', degrees: [5, 0, 2], complexity: 0.1 },
                { name: 'vii°', degrees: [6, 1, 3], complexity: 0.2 },
            ],
            suspended: [
                { name: 'Isus2', degrees: [0, 1, 4], complexity: 0.15 },
                { name: 'Isus4', degrees: [0, 3, 4], complexity: 0.15 },
                { name: 'IIsus4', degrees: [1, 4, 5], complexity: 0.2 },
                { name: 'IVsus2', degrees: [3, 4, 0], complexity: 0.15 },
                { name: 'IVsus4', degrees: [3, 6, 0], complexity: 0.15 },
                { name: 'Vsus2', degrees: [4, 5, 1], complexity: 0.15 },
                { name: 'Vsus4', degrees: [4, 0, 1], complexity: 0.15 },
                { name: 'visus4', degrees: [5, 1, 2], complexity: 0.2 },
            ],
            // Medium - complexity 0.3-0.5
            inversions: [
                { name: 'I/3', degrees: [2, 4, 0], complexity: 0.3 },
                { name: 'I/5', degrees: [4, 0, 2], complexity: 0.35 },
                { name: 'ii/3', degrees: [3, 5, 1], complexity: 0.3 },
                { name: 'IV/3', degrees: [5, 0, 3], complexity: 0.3 },
                { name: 'IV/5', degrees: [0, 3, 5], complexity: 0.35 },
                { name: 'V/3', degrees: [6, 1, 4], complexity: 0.35 },
                { name: 'V/5', degrees: [1, 4, 6], complexity: 0.35 },
                { name: 'vi/3', degrees: [0, 2, 5], complexity: 0.3 },
                { name: 'vi/5', degrees: [2, 5, 0], complexity: 0.35 },
            ],
            slashChords: [
                { name: 'I/2', degrees: [1, 0, 2, 4], complexity: 0.4 },
                { name: 'I/4', degrees: [3, 0, 2, 4], complexity: 0.4 },
                { name: 'IV/1', degrees: [0, 3, 5, 0], complexity: 0.4 },
                { name: 'IV/5', degrees: [4, 3, 5, 0], complexity: 0.4 },
                { name: 'V/1', degrees: [0, 4, 6, 1], complexity: 0.45 },
                { name: 'vi/5', degrees: [4, 5, 0, 2], complexity: 0.4 },
                { name: 'ii/1', degrees: [0, 1, 3, 5], complexity: 0.45 },
            ],
            sevenths: [
                { name: 'Imaj7', degrees: [0, 2, 4, 6], complexity: 0.4 },
                { name: 'ii7', degrees: [1, 3, 5, 0], complexity: 0.4 },
                { name: 'iii7', degrees: [2, 4, 6, 1], complexity: 0.4 },
                { name: 'IVmaj7', degrees: [3, 5, 0, 2], complexity: 0.4 },
                { name: 'V7', degrees: [4, 6, 1, 3], complexity: 0.4 },
                { name: 'vi7', degrees: [5, 0, 2, 4], complexity: 0.4 },
                { name: 'viiø7', degrees: [6, 1, 3, 5], complexity: 0.45 },
            ],
            // Complex - complexity 0.5-0.7
            seventhInversions: [
                { name: 'Imaj7/3', degrees: [2, 4, 6, 0], complexity: 0.55 },
                { name: 'Imaj7/5', degrees: [4, 6, 0, 2], complexity: 0.55 },
                { name: 'Imaj7/7', degrees: [6, 0, 2, 4], complexity: 0.6 },
                { name: 'V7/3', degrees: [6, 1, 3, 4], complexity: 0.55 },
                { name: 'V7/5', degrees: [1, 3, 4, 6], complexity: 0.55 },
                { name: 'V7/7', degrees: [3, 4, 6, 1], complexity: 0.6 },
                { name: 'ii7/3', degrees: [3, 5, 0, 1], complexity: 0.55 },
                { name: 'ii7/5', degrees: [5, 0, 1, 3], complexity: 0.55 },
            ],
            susSeventh: [
                { name: '7sus4', degrees: [0, 3, 4, 6], complexity: 0.5 },
                { name: '7sus2', degrees: [0, 1, 4, 6], complexity: 0.5 },
                { name: 'V7sus4', degrees: [4, 0, 1, 3], complexity: 0.55 },
                { name: 'ii7sus4', degrees: [1, 4, 5, 0], complexity: 0.55 },
                { name: 'maj7sus4', degrees: [0, 3, 4, 6], complexity: 0.55 },
            ],
            addChords: [
                { name: 'Iadd9', degrees: [0, 2, 4, 1], complexity: 0.45 },
                { name: 'Iadd4', degrees: [0, 2, 3, 4], complexity: 0.45 },
                { name: 'iiadd9', degrees: [1, 3, 5, 2], complexity: 0.45 },
                { name: 'IVadd9', degrees: [3, 5, 0, 4], complexity: 0.45 },
                { name: 'Vadd9', degrees: [4, 6, 1, 5], complexity: 0.45 },
                { name: 'viadd9', degrees: [5, 0, 2, 6], complexity: 0.45 },
                { name: 'Iadd6', degrees: [0, 2, 4, 5], complexity: 0.4 },
                { name: 'IVadd6', degrees: [3, 5, 0, 1], complexity: 0.4 },
            ],
            // Very complex - complexity 0.7-0.9
            extended: [
                { name: 'Imaj9', degrees: [0, 2, 4, 6, 1], complexity: 0.7 },
                { name: 'ii9', degrees: [1, 3, 5, 0, 2], complexity: 0.7 },
                { name: 'V9', degrees: [4, 6, 1, 3, 5], complexity: 0.7 },
                { name: 'Imaj11', degrees: [0, 2, 4, 6, 1, 3], complexity: 0.75 },
                { name: 'ii11', degrees: [1, 3, 5, 0, 2, 4], complexity: 0.75 },
                { name: 'V11', degrees: [4, 6, 1, 3, 5, 0], complexity: 0.75 },
                { name: 'Imaj13', degrees: [0, 2, 4, 6, 1, 5], complexity: 0.8 },
                { name: 'V13', degrees: [4, 6, 1, 3, 5, 2], complexity: 0.8 },
                { name: '9sus4', degrees: [0, 3, 4, 6, 1], complexity: 0.7 },
                { name: '13sus4', degrees: [0, 3, 4, 6, 1, 5], complexity: 0.8 },
            ],
            altered: [
                { name: 'V7#9', degrees: [4, 6, 1, 3, 6], complexity: 0.75 },
                { name: 'V7b9', degrees: [4, 6, 1, 3, 5], complexity: 0.75 },
                { name: 'V7#5', degrees: [4, 6, 2, 3], complexity: 0.7 },
                { name: 'V7b5', degrees: [4, 6, 0, 3], complexity: 0.7 },
                { name: 'V7alt', degrees: [4, 6, 0, 3, 5], complexity: 0.85 },
                { name: 'dim7', degrees: [0, 2, 4, 6], complexity: 0.65 },
                { name: 'aug', degrees: [0, 2, 5], complexity: 0.6 },
                { name: 'augmaj7', degrees: [0, 2, 5, 6], complexity: 0.7 },
            ],
            quartal: [
                { name: 'Q4', degrees: [0, 3, 6], complexity: 0.5 },
                { name: 'Q4ext', degrees: [0, 3, 6, 1], complexity: 0.6 },
                { name: 'Q5', degrees: [0, 4, 1], complexity: 0.5 },
                { name: 'Q5ext', degrees: [0, 4, 1, 5], complexity: 0.6 },
                { name: 'Q4wide', degrees: [0, 3, 6, 2], complexity: 0.65 },
                { name: 'Q5wide', degrees: [0, 4, 1, 5, 2], complexity: 0.7 },
            ],
            // Extreme - complexity 0.9+
            polychords: [
                { name: 'I/V', degrees: [0, 2, 4, 4, 6, 1], complexity: 0.85 },
                { name: 'ii/I', degrees: [1, 3, 5, 0, 2, 4], complexity: 0.85 },
                { name: 'IV/V', degrees: [3, 5, 0, 4, 6, 1], complexity: 0.85 },
                { name: 'bVII/I', degrees: [6, 1, 3, 0, 2, 4], complexity: 0.9 },
            ],
            clusters: [
                { name: 'cluster2', degrees: [0, 1, 2], complexity: 0.9 },
                { name: 'cluster3', degrees: [0, 1, 2, 3], complexity: 0.95 },
                { name: 'wideCluster', degrees: [0, 4, 1, 5], complexity: 0.85 },
                { name: 'spreadCluster', degrees: [0, 6, 2, 5], complexity: 0.9 },
            ]
        };

        const CHORD_VOICINGS = [
            // 2 notes - dyads and intervals
            [0, 7], [0, 5], [0, 4], [0, 3], [0, 9], [0, 12],
            [0, 2], [0, 10], [0, 14], [0, 19],  // 2nds, 7ths, 9ths, 12ths
            // 3 notes - triads and open voicings
            [0, 4, 7], [0, 3, 7], [0, 5, 7], [0, 4, 9], [0, 7, 12], [0, 7, 14],
            [0, 7, 16], [0, 5, 12], [0, 4, 11], [0, 3, 10],  // Open triads
            [0, 12, 19], [0, 12, 16], [0, 7, 19],  // Very open
            // 4 notes - 7th chords and voicings
            [0, 4, 7, 11], [0, 3, 7, 10], [0, 4, 7, 10], [0, 3, 7, 11], [0, 4, 7, 14],
            [0, 5, 7, 12], [0, 2, 7, 11], [0, 4, 9, 14],
            [0, 7, 11, 14], [0, 7, 10, 14], [0, 4, 11, 14],  // Drop 2 voicings
            [0, 10, 14, 17], [0, 11, 14, 19],  // Rootless voicings
            // 5 notes - extended chords
            [0, 4, 7, 11, 14], [0, 3, 7, 10, 14], [0, 4, 7, 11, 18], [0, 5, 7, 12, 16],
            [0, 4, 7, 14, 17], [0, 2, 7, 11, 14],
            [0, 7, 11, 14, 21], [0, 4, 10, 14, 17],  // More 9ths/11ths
            // 6 notes - lush voicings
            [0, 4, 7, 11, 14, 17], [0, 3, 7, 10, 14, 17], [0, 4, 7, 11, 14, 21],
            [0, 2, 4, 7, 11, 14], [0, 5, 7, 12, 16, 19],
            [0, 7, 11, 14, 17, 21], [0, 4, 7, 14, 17, 21],  // Wide 13ths
            // 7 notes - full orchestral
            [0, 4, 7, 11, 14, 17, 21], [0, 3, 7, 10, 14, 17, 21], [0, 2, 4, 7, 11, 14, 17],
            [0, 4, 7, 9, 11, 14, 18],
            [0, 7, 12, 14, 19, 21, 24],  // Very spread
            // Quartal voicings
            [0, 5, 10], [0, 5, 10, 15], [0, 5, 10, 15, 20],
            [0, 7, 14], [0, 7, 14, 21], [0, 7, 14, 21, 28],  // Quintal
            // Cluster voicings
            [0, 1, 3], [0, 2, 3], [0, 1, 2, 4], [0, 2, 3, 5]
        ];
        
        // Voicings categorized by expansiveness (spread)
        const VOICING_CATEGORIES = {
            tight: [  // 0-0.25 expansiveness - compact voicings
                [0, 1, 3], [0, 2, 3], [0, 1, 2, 4], [0, 2, 3, 5],  // Clusters
                [0, 3, 7], [0, 4, 7], [0, 5, 7],  // Close triads
                [0, 2], [0, 3], [0, 4],  // Small intervals
                [0, 3, 7, 10], [0, 4, 7, 10], [0, 4, 7, 11]  // Close position 7ths
            ],
            moderate: [  // 0.25-0.5 expansiveness
                [0, 4, 9], [0, 7], [0, 5], [0, 9],  // Open intervals
                [0, 4, 7, 11], [0, 3, 7, 10], [0, 5, 7, 12],  // Standard voicings
                [0, 4, 7, 14], [0, 2, 7, 11], [0, 4, 9, 14],  // With extensions
                [0, 5, 10], [0, 5, 10, 15],  // Quartal
                [0, 10, 14, 17], [0, 11, 14, 19]  // Rootless
            ],
            open: [  // 0.5-0.75 expansiveness
                [0, 7, 12], [0, 7, 14], [0, 7, 16], [0, 5, 12],  // Open triads
                [0, 7, 11, 14], [0, 7, 10, 14], [0, 4, 11, 14],  // Drop 2
                [0, 4, 7, 11, 14], [0, 3, 7, 10, 14], [0, 4, 7, 11, 18],
                [0, 4, 7, 14, 17], [0, 2, 7, 11, 14],
                [0, 12], [0, 14], [0, 19],  // Wide intervals
                [0, 7, 14, 21], [0, 5, 10, 15, 20]  // Extended quartal/quintal
            ],
            expansive: [  // 0.75-1.0 expansiveness - very spread
                [0, 12, 19], [0, 12, 16], [0, 7, 19],  // Very open triads
                [0, 7, 11, 14, 21], [0, 4, 10, 14, 17],
                [0, 4, 7, 11, 14, 17], [0, 3, 7, 10, 14, 17], [0, 4, 7, 11, 14, 21],
                [0, 7, 11, 14, 17, 21], [0, 4, 7, 14, 17, 21],  // Wide 13ths
                [0, 4, 7, 11, 14, 17, 21], [0, 3, 7, 10, 14, 17, 21],
                [0, 7, 12, 14, 19, 21, 24],  // Very spread orchestral
                [0, 7, 14, 21, 28]  // Super wide quintal
            ]
        };
        
        // Select voicing based on weather expansiveness
        function selectVoicingByExpansiveness(expansiveness = 0.5) {
            // Add some randomness but bias toward the weather value
            const roll = Math.random() * 0.4 + expansiveness * 0.6;
            
            let category;
            if (roll < 0.25) {
                category = VOICING_CATEGORIES.tight;
            } else if (roll < 0.5) {
                category = VOICING_CATEGORIES.moderate;
            } else if (roll < 0.75) {
                category = VOICING_CATEGORIES.open;
            } else {
                category = VOICING_CATEGORIES.expansive;
            }
            
            return randomChoice(category);
        }

        // ═══════════════════════════════════════════════════════════════
        // STATE
        // ═══════════════════════════════════════════════════════════════
        
        let audioCtx = null;
        let masterGain = null;
        let synths = [];
        let isPlaying = false;
        let driftIntervals = [];
        let startTime = null;
        let timeDisplayInterval = null;
        
        // BPM / Tempo control
        let globalBPM = 60;  // Default BPM (60 = 1x speed, baseline)
        const BASE_BPM = 60; // Reference BPM for 1x multiplier
        
        // Get tempo multiplier: BPM 60 = 1x, BPM 120 = 0.5x (faster), BPM 30 = 2x (slower)
        function getTempoMultiplier() {
            return BASE_BPM / globalBPM;
        }
        
        // Noise layer state (Disasterpeace style)
        let noiseSource = null;
        let noiseGain = null;
        let noiseFilter = null;
        let noiseFilter2 = null;  // Second filter for more shaping
        let noiseResonance = null; // Resonant filter for evolving character
        let noiseFadeTimeout = null;
        let noiseEvolveTimeouts = []; // Multiple evolution timers
        
        let globalScale = null;
        let globalRoot = null;
        let globalScaleIntervals = null;
        let currentChord = null;
        let currentChordNotes = [];
        let chordChangeInterval = null;
        let chordHistory = [];

        // ═══════════════════════════════════════════════════════════════
        // CENTRAL MOTIF SYSTEM
        // ═══════════════════════════════════════════════════════════════
        
        // The central motif - up to 12 notes that define the piece
        let centralMotif = [];  // Array of MIDI note numbers
        const MAX_MOTIF_LENGTH = 12;
        const MIN_MOTIF_LENGTH = 4;
        
        // Which section currently "owns" the melody
        let currentMelodySection = null;
        let melodySectionStartTime = 0;
        const MELODY_SECTION_DURATION = { min: 20000, max: 45000 }; // 20-45 seconds per section
        
        // Motif playback state
        let motifPlaybackIndex = 0;
        let lastMotifPlayTime = 0;
        let motifPlaybackTimeout = null;
        const MOTIF_REST_CHANCE = 0.3;  // Chance to rest between motif notes
        const MOTIF_VARIATION_CHANCE = 0.25; // Chance to vary a note slightly
        
        // ═══════════════════════════════════════════════════════════════
        // MOTIF-BASED HARMONY SYSTEM
        // Chords and harmonies derive FROM the central motif
        // ═══════════════════════════════════════════════════════════════
        
        let motifHarmony = {
            chordProgression: [],   // Array of chord objects derived from motif
            currentChordIndex: 0,   // Which chord in the progression
            harmonyNotes: []        // Current harmony notes for all instruments
        };
        
        // Analyze motif to extract implied harmonies
        function analyzeMotifHarmony() {
            if (centralMotif.length === 0) return;
            
            // Get pitch classes from motif
            const pitchClasses = centralMotif.map(n => (n - globalRoot + 12) % 12);
            const uniquePCs = [...new Set(pitchClasses)];
            
            // Find the most prominent pitch classes
            const pcCounts = {};
            pitchClasses.forEach(pc => {
                pcCounts[pc] = (pcCounts[pc] || 0) + 1;
            });
            
            // Sort by frequency
            const sortedPCs = Object.entries(pcCounts)
                .sort((a, b) => b[1] - a[1])
                .map(e => parseInt(e[0]));
            
            // Build chord progression based on motif's implied harmony
            const progression = [];
            
            // First chord: tonic with motif color
            progression.push({
                name: 'I (tonic)',
                root: 0,
                intervals: buildChordFromMotif(sortedPCs, 0),
                function: 'tonic'
            });
            
            // Second chord: subdominant area (IV or ii)
            const subRoot = sortedPCs.includes(5) ? 5 : (sortedPCs.includes(2) ? 2 : 5);
            progression.push({
                name: subRoot === 5 ? 'IV (sub)' : 'ii (sub)',
                root: subRoot,
                intervals: buildChordFromMotif(sortedPCs, subRoot),
                function: 'subdominant'
            });
            
            // Third chord: dominant area (V or vii°)
            const domRoot = sortedPCs.includes(7) ? 7 : (sortedPCs.includes(11) ? 11 : 7);
            progression.push({
                name: domRoot === 7 ? 'V (dom)' : 'vii° (dom)',
                root: domRoot,
                intervals: buildChordFromMotif(sortedPCs, domRoot),
                function: 'dominant'
            });
            
            // Fourth chord: return to tonic or deceptive
            if (Math.random() < 0.7) {
                progression.push({
                    name: 'I (return)',
                    root: 0,
                    intervals: buildChordFromMotif(sortedPCs, 0),
                    function: 'tonic'
                });
            } else {
                // Deceptive: vi chord
                progression.push({
                    name: 'vi (deceptive)',
                    root: 9,
                    intervals: buildChordFromMotif(sortedPCs, 9),
                    function: 'tonic-sub'
                });
            }
            
            motifHarmony.chordProgression = progression;
            motifHarmony.currentChordIndex = 0;
            
            log('system', `♫ Harmony: ${progression.map(c => c.name).join(' → ')}`);
            
            // Apply first chord
            applyMotifHarmony();
        }
        
        // Build a chord from motif pitch classes, favoring notes in the motif
        function buildChordFromMotif(motifPCs, chordRoot) {
            const intervals = [0]; // Always include root
            
            // Standard chord tones relative to chord root
            const possibleIntervals = [3, 4, 7, 10, 11, 14]; // m3, M3, P5, m7, M7, 9th
            
            possibleIntervals.forEach(interval => {
                const pc = (chordRoot + interval) % 12;
                // Include if it's in the motif OR it's a basic chord tone (3rd, 5th)
                if (motifPCs.includes(pc) || interval === 4 || interval === 3 || interval === 7) {
                    if (!intervals.includes(interval)) {
                        intervals.push(interval);
                    }
                }
            });
            
            // Ensure we have at least a triad
            if (!intervals.includes(3) && !intervals.includes(4)) {
                intervals.push(globalScale === 'Minor' ? 3 : 4);
            }
            if (!intervals.includes(7)) {
                intervals.push(7);
            }
            
            return intervals.sort((a, b) => a - b);
        }
        
        // Apply current motif harmony to all instruments
        function applyMotifHarmony() {
            if (motifHarmony.chordProgression.length === 0) return;
            
            const chord = motifHarmony.chordProgression[motifHarmony.currentChordIndex];
            const chordRoot = globalRoot + chord.root;
            
            // Generate harmony notes across all octaves
            const harmonyNotes = [];
            for (let octave = 2; octave <= 7; octave++) {
                const octaveBase = octave * 12;
                chord.intervals.forEach(interval => {
                    harmonyNotes.push(octaveBase + chordRoot + interval);
                });
            }
            
            motifHarmony.harmonyNotes = harmonyNotes;
            
            // Update synths with new harmony
            if (synths && synths.length > 0) {
                synths.forEach(synth => {
                    if (!synth.config.isMelody) {
                        const [rangeLow, rangeHigh] = synth.config.range || [24, 108];
                        synth.config.notes = harmonyNotes.filter(n => 
                            n >= rangeLow && n <= rangeHigh
                        );
                    }
                });
            }
            
            // Also update currentChordNotes for compatibility
            currentChordNotes = harmonyNotes;
            
            log('harmony', `♫ ${chord.name}: [${chord.intervals.map(i => i).join(',')}] from root ${NOTE_NAMES[chordRoot % 12]}`);
        }
        
        // Advance to next chord in motif-derived progression
        function advanceMotifHarmony() {
            if (motifHarmony.chordProgression.length === 0) {
                analyzeMotifHarmony();
                return;
            }
            
            motifHarmony.currentChordIndex = 
                (motifHarmony.currentChordIndex + 1) % motifHarmony.chordProgression.length;
            
            applyMotifHarmony();
        }
        
        // Get harmony notes that support the current motif note
        function getMotifHarmonyNote(currentMotifNote, availableNotes) {
            if (!currentMotifNote || availableNotes.length === 0) return null;
            
            // Find notes that harmonize well with the motif note
            const motifPC = currentMotifNote % 12;
            const goodIntervals = [0, 3, 4, 5, 7, 8, 9]; // Unison, 3rds, 4th, 5th, 6ths
            
            const harmonizingNotes = availableNotes.filter(note => {
                const interval = Math.abs((note % 12) - motifPC);
                const normalizedInterval = interval > 6 ? 12 - interval : interval;
                return goodIntervals.includes(normalizedInterval);
            });
            
            return harmonizingNotes.length > 0 ? randomChoice(harmonizingNotes) : randomChoice(availableNotes);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // PHRASE & STRUCTURE SYSTEM (Jeremy Soule / Eno influence)
        // ═══════════════════════════════════════════════════════════════
        
        // Phrase structure - creates "breathing" and cadences
        let currentPhrase = 0;           // Current phrase number
        let phraseStartTime = 0;         // When current phrase started
        let beatsInPhrase = 0;           // Beat counter within phrase
        const PHRASE_LENGTHS = [8, 16, 32]; // Possible phrase lengths in "beats"
        let currentPhraseLength = 16;    // Current phrase length
        const BEAT_DURATION = 2000;      // Base beat duration in ms (at 60 BPM)
        
        // Get current position within phrase (0-1)
        function getPhrasePosition() {
            const elapsed = Date.now() - phraseStartTime;
            const phraseDuration = currentPhraseLength * BEAT_DURATION * getTempoMultiplier();
            return Math.min(1, elapsed / phraseDuration);
        }
        
        // Check if we're at a phrase boundary (for cadences)
        function isPhraseBoundary() {
            const pos = getPhrasePosition();
            return pos > 0.9; // Last 10% of phrase
        }
        
        // Check if we're at a strong beat (1, 5, 9, 13 for 16-beat phrase)
        function isStrongBeat() {
            const pos = getPhrasePosition();
            const beatInPhrase = Math.floor(pos * currentPhraseLength);
            return beatInPhrase % 4 === 0;
        }
        
        // Advance to next phrase
        function advancePhrase() {
            currentPhrase++;
            phraseStartTime = Date.now();
            currentPhraseLength = randomChoice(PHRASE_LENGTHS);
            beatsInPhrase = 0;
            log('system', `━━━ Phrase ${currentPhrase} (${currentPhraseLength} beats) ━━━`);
            
            // ═══ HARMONY CHANGES AT PHRASE BOUNDARIES ═══
            // Change chord every phrase (aligned with structure)
            advanceMotifHarmony();
            
            // Trigger convergence at some phrase starts
            if (Math.random() < 0.3) {
                scheduleConvergence();
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // DYNAMIC ARCS (Harold Budd / Eno influence)
        // ═══════════════════════════════════════════════════════════════
        
        // Macro-level dynamic shape over 2-4 minutes
        let dynamicArc = {
            phase: 'building',    // 'building', 'peak', 'receding', 'rest'
            startTime: 0,
            duration: 120000,     // 2 minutes default
            intensity: 0.5,       // Current intensity 0-1
            targetIntensity: 0.7
        };
        
        const ARC_PHASES = {
            building: { minDuration: 60000, maxDuration: 150000, targetRange: [0.6, 0.9] },
            peak: { minDuration: 20000, maxDuration: 60000, targetRange: [0.8, 1.0] },
            receding: { minDuration: 45000, maxDuration: 120000, targetRange: [0.2, 0.5] },
            rest: { minDuration: 30000, maxDuration: 90000, targetRange: [0.1, 0.3] }
        };
        
        // Get current dynamic intensity (affects volume, density, activity)
        function getDynamicIntensity() {
            const elapsed = Date.now() - dynamicArc.startTime;
            const progress = Math.min(1, elapsed / dynamicArc.duration);
            
            // Smooth interpolation toward target
            const startIntensity = dynamicArc.intensity;
            const ease = progress * progress * (3 - 2 * progress); // Smoothstep
            return startIntensity + (dynamicArc.targetIntensity - startIntensity) * ease;
        }
        
        // Transition to next arc phase
        function advanceDynamicArc() {
            const phases = ['building', 'peak', 'receding', 'rest'];
            const currentIndex = phases.indexOf(dynamicArc.phase);
            const nextPhase = phases[(currentIndex + 1) % phases.length];
            
            const phaseConfig = ARC_PHASES[nextPhase];
            dynamicArc.intensity = getDynamicIntensity();
            dynamicArc.phase = nextPhase;
            dynamicArc.startTime = Date.now();
            dynamicArc.duration = phaseConfig.minDuration + 
                Math.random() * (phaseConfig.maxDuration - phaseConfig.minDuration);
            dynamicArc.targetIntensity = phaseConfig.targetRange[0] + 
                Math.random() * (phaseConfig.targetRange[1] - phaseConfig.targetRange[0]);
            
            log('system', `◆ Dynamic arc: ${nextPhase.toUpperCase()} (${(dynamicArc.duration/1000).toFixed(0)}s)`);
            
            // Schedule next arc transition
            if (isPlaying) {
                setTimeout(() => {
                    if (isPlaying) advanceDynamicArc();
                }, dynamicArc.duration);
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // CONVERGENCE MOMENTS (Those magical crystallization points)
        // ═══════════════════════════════════════════════════════════════
        
        let convergenceActive = false;
        let convergenceNote = null;
        let convergenceStartTime = 0;
        const CONVERGENCE_DURATION = 4000; // 4 seconds of aligned playing
        
        // Schedule a convergence moment
        function scheduleConvergence() {
            if (convergenceActive) return;
            
            // Pick a strong chord tone for everyone to converge on
            const rootNote = 48 + globalRoot; // Bass register root
            convergenceNote = rootNote;
            convergenceActive = true;
            convergenceStartTime = Date.now();
            
            log('system', `★ CONVERGENCE on ${midiToNoteName(convergenceNote)}`);
            
            // End convergence after duration
            setTimeout(() => {
                convergenceActive = false;
                convergenceNote = null;
                log('system', `★ Convergence released`);
            }, CONVERGENCE_DURATION);
        }
        
        // Check if instrument should play convergence note
        function shouldPlayConvergence(instrument) {
            if (!convergenceActive) return false;
            const elapsed = Date.now() - convergenceStartTime;
            
            // Stagger entries - different instruments join at different times
            const section = getInstrumentSection(instrument);
            const sectionOrder = { strings: 0, keys: 0.2, woodwinds: 0.4, brass: 0.6 };
            const entryPoint = (sectionOrder[section] || 0.3) * CONVERGENCE_DURATION;
            
            return elapsed > entryPoint && Math.random() < 0.55;
        }
        
        // Get convergence note in instrument's range
        function getConvergenceNote(instrument, availableNotes) {
            if (!convergenceNote) return null;
            
            // Find the convergence note (or octave) in instrument's range
            for (let octave = -2; octave <= 2; octave++) {
                const note = convergenceNote + (octave * 12);
                if (availableNotes.includes(note)) return note;
                // Also accept notes within the range even if not in availableNotes
                const nearest = findNearestChordTone(note, availableNotes);
                if (Math.abs(nearest - note) <= 2) return nearest;
            }
            return null;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // HARMONIC PEDAL POINTS (Hosono / Budd grounding)
        // ═══════════════════════════════════════════════════════════════
        
        let pedalNote = null;
        let pedalStartTime = 0;
        const PEDAL_DURATION = { min: 30000, max: 90000 }; // 30-90 seconds
        const PEDAL_INSTRUMENTS = ['bass', 'cello', 'lowbrass', 'bassoon'];
        
        // Update pedal point
        function updatePedalPoint() {
            const elapsed = Date.now() - pedalStartTime;
            const duration = PEDAL_DURATION.min + Math.random() * (PEDAL_DURATION.max - PEDAL_DURATION.min);
            
            if (!pedalNote || elapsed > duration) {
                // New pedal on root or fifth
                const interval = Math.random() < 0.7 ? 0 : 7; // Root 70%, fifth 30%
                pedalNote = 36 + globalRoot + interval; // Low register
                pedalStartTime = Date.now();
                log('system', `♩ Pedal point: ${midiToNoteName(pedalNote)}`);
            }
        }
        
        // Check if instrument should play pedal
        function shouldPlayPedal(instrument) {
            if (!pedalNote) return false;
            if (!PEDAL_INSTRUMENTS.includes(instrument)) return false;
            
            // Pedal instruments have high chance to sustain the pedal
            return Math.random() < 0.45;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // ACTIVITY AWARENESS (Pauline Oliveros deep listening)
        // ═══════════════════════════════════════════════════════════════
        
        let recentActivity = []; // { time, instrument, type }
        const ACTIVITY_WINDOW = 5000; // 5 second window
        
        // Record activity
        function recordActivity(instrument, type = 'note') {
            recentActivity.push({ time: Date.now(), instrument, type });
            // Cleanup old entries
            const cutoff = Date.now() - ACTIVITY_WINDOW;
            recentActivity = recentActivity.filter(a => a.time > cutoff);
        }
        
        // Get current texture density (0-1)
        function getTextureDensity() {
            const cutoff = Date.now() - ACTIVITY_WINDOW;
            const recent = recentActivity.filter(a => a.time > cutoff);
            // Normalize: 0 notes = 0, 16+ notes in 5s = 1
            return Math.min(1, recent.length / 16);
        }
        
        // Should instrument pull back due to density?
        function shouldPullBack(instrument) {
            const density = getTextureDensity();
            const dynamicLevel = getDynamicIntensity();
            
            // More likely to pull back when dense AND in receding/rest phase
            const pullBackThreshold = dynamicArc.phase === 'rest' ? 0.25 : 
                                      dynamicArc.phase === 'receding' ? 0.4 : 0.55;
            
            if (density > pullBackThreshold) {
                // Higher density = higher chance to stay quiet
                return Math.random() < (density - pullBackThreshold) * 2.4;
            }
            return false;
        }
        
        // Should instrument lean in due to sparseness?
        function shouldLeanIn(instrument) {
            const density = getTextureDensity();
            const dynamicLevel = getDynamicIntensity();
            
            // More likely to lean in when sparse AND in building/peak phase
            if (density < 0.2 && (dynamicArc.phase === 'building' || dynamicArc.phase === 'peak')) {
                return Math.random() < (0.2 - density) * 1.6;
            }
            return false;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // MOTIF ECHO CHAINS (Call and response)
        // ═══════════════════════════════════════════════════════════════
        
        let lastMotifPlayer = null;
        let lastMotifTime = 0;
        const ECHO_WINDOW = 6000; // 6 seconds to echo
        
        // Record that an instrument played the motif
        function recordMotifPlay(instrument) {
            lastMotifPlayer = instrument;
            lastMotifTime = Date.now();
        }
        
        // Should this instrument echo the motif?
        function shouldEchoMotif(instrument) {
            if (!lastMotifPlayer || lastMotifPlayer === instrument) return false;
            const elapsed = Date.now() - lastMotifTime;
            if (elapsed > ECHO_WINDOW) return false;
            
            // Different section more likely to echo (antiphonal)
            const mySection = getInstrumentSection(instrument);
            const theirSection = getInstrumentSection(lastMotifPlayer);
            const crossSection = mySection !== theirSection;
            
            const baseChance = crossSection ? 0.25 : 0.12;
            return Math.random() < baseChance;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // BREATH CYCLES (Collective rests - Eno influence)
        // ═══════════════════════════════════════════════════════════════
        
        let breathPhase = 'normal'; // 'normal', 'inhale', 'exhale', 'held'
        let breathStartTime = 0;
        const BREATH_CYCLE = {
            normalDuration: { min: 45000, max: 120000 },  // 45s-2min of normal playing
            inhaleDuration: 8000,   // 8s of gradual quieting
            heldDuration: { min: 4000, max: 12000 },     // 4-12s of near silence
            exhaleDuration: 6000    // 6s of gradual return
        };
        
        // Get breath modifier for volume/activity (0-1)
        function getBreathModifier() {
            const elapsed = Date.now() - breathStartTime;
            
            switch (breathPhase) {
                case 'inhale':
                    // Gradually reduce to near zero
                    return Math.max(0.1, 1 - (elapsed / BREATH_CYCLE.inhaleDuration) * 0.9);
                case 'held':
                    // Very quiet
                    return 0.1;
                case 'exhale':
                    // Gradually return
                    return 0.1 + (elapsed / BREATH_CYCLE.exhaleDuration) * 0.9;
                default:
                    return 1;
            }
        }
        
        // Advance breath cycle
        function advanceBreathCycle() {
            switch (breathPhase) {
                case 'normal':
                    breathPhase = 'inhale';
                    breathStartTime = Date.now();
                    log('system', `○ Breath: inhaling...`);
                    setTimeout(() => { if (isPlaying) advanceBreathCycle(); }, BREATH_CYCLE.inhaleDuration);
                    break;
                case 'inhale':
                    breathPhase = 'held';
                    breathStartTime = Date.now();
                    const holdTime = BREATH_CYCLE.heldDuration.min + 
                        Math.random() * (BREATH_CYCLE.heldDuration.max - BREATH_CYCLE.heldDuration.min);
                    log('system', `○ Breath: held...`);
                    setTimeout(() => { if (isPlaying) advanceBreathCycle(); }, holdTime);
                    break;
                case 'held':
                    breathPhase = 'exhale';
                    breathStartTime = Date.now();
                    log('system', `○ Breath: exhaling...`);
                    setTimeout(() => { if (isPlaying) advanceBreathCycle(); }, BREATH_CYCLE.exhaleDuration);
                    break;
                case 'exhale':
                    breathPhase = 'normal';
                    breathStartTime = Date.now();
                    const normalTime = BREATH_CYCLE.normalDuration.min + 
                        Math.random() * (BREATH_CYCLE.normalDuration.max - BREATH_CYCLE.normalDuration.min);
                    log('system', `○ Breath: normal`);
                    setTimeout(() => { if (isPlaying) advanceBreathCycle(); }, normalTime);
                    break;
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // STRONGER CADENCES (Resolution at phrase ends)
        // ═══════════════════════════════════════════════════════════════
        
        // Get cadence note (resolve to chord tone at phrase end)
        function getCadenceNote(instrument, availableNotes) {
            if (!isPhraseBoundary()) return null;
            
            // At phrase end, strongly prefer root, then fifth, then third
            const root = globalRoot;
            const fifth = (globalRoot + 7) % 12;
            const third = (globalRoot + (globalScale === 'Minor' ? 3 : 4)) % 12;
            
            // Find these in available notes
            const cadenceOptions = availableNotes.filter(note => {
                const pc = note % 12;
                return pc === root || pc === fifth || pc === third;
            });
            
            if (cadenceOptions.length > 0) {
                // Weight toward root
                const weighted = [];
                cadenceOptions.forEach(note => {
                    const pc = note % 12;
                    if (pc === root) weighted.push(note, note, note); // 3x weight
                    else if (pc === fifth) weighted.push(note, note); // 2x weight
                    else weighted.push(note); // 1x weight
                });
                return randomChoice(weighted);
            }
            return null;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // MOTIF VARIATIONS (Transposition, inversion, augmentation)
        // ═══════════════════════════════════════════════════════════════
        
        // Get transposed motif (shift by interval)
        function getTransposedMotif(semitones) {
            return centralMotif.map(note => note + semitones);
        }
        
        // Get inverted motif (mirror around first note)
        function getInvertedMotif() {
            if (centralMotif.length === 0) return [];
            const pivot = centralMotif[0];
            return centralMotif.map(note => pivot - (note - pivot));
        }
        
        // Get retrograde motif (reversed)
        function getRetrogradeMotif() {
            return [...centralMotif].reverse();
        }
        
        // Get augmented motif note (slower - every other note)
        function getAugmentedMotifNote(index) {
            const augIndex = Math.floor(index / 2) % centralMotif.length;
            return centralMotif[augIndex];
        }
        
        // Choose a motif variation
        function getMotifVariation() {
            const roll = Math.random();
            if (roll < 0.5) return { type: 'original', motif: centralMotif };
            if (roll < 0.65) return { type: 'transposed', motif: getTransposedMotif(randomChoice([-5, -3, 3, 5, 7])) };
            if (roll < 0.8) return { type: 'inverted', motif: getInvertedMotif() };
            if (roll < 0.9) return { type: 'retrograde', motif: getRetrogradeMotif() };
            return { type: 'transposed', motif: getTransposedMotif(12) }; // Octave up
        }

        // Generate a new central motif based on current key
        function generateCentralMotif() {
            // Weighted length: favor 4-8 notes, occasionally up to 12
            // 70% chance of 4-8, 30% chance of 9-12
            let length;
            if (Math.random() < 0.7) {
                length = 4 + Math.floor(Math.random() * 5); // 4-8 notes
            } else {
                length = 9 + Math.floor(Math.random() * 4); // 9-12 notes
            }
            const motif = [];
            
            // Start on a chord tone (root, 3rd, or 5th)
            const startIntervals = [0, 4, 7]; // Root, major 3rd, 5th
            const startInterval = randomChoice(startIntervals);
            const startOctave = 60 + globalRoot; // Middle C octave
            const startNote = startOctave + startInterval;
            motif.push(startNote);
            
            // Build melodic contour
            let prevNote = startNote;
            const scaleNotes = [];
            for (let oct = 48; oct <= 84; oct += 12) {
                globalScaleIntervals.forEach(interval => {
                    scaleNotes.push(oct + globalRoot + interval);
                });
            }
            
            for (let i = 1; i < length; i++) {
                // Prefer stepwise motion with occasional leaps
                const stepSize = Math.random() < 0.7 ? 
                    (Math.random() < 0.5 ? 1 : 2) : // Step: 1 or 2 scale degrees
                    (Math.random() < 0.5 ? 3 : 4);  // Leap: 3 or 4 scale degrees
                
                const direction = Math.random() < 0.5 ? 1 : -1;
                
                // Find the next note in the scale
                const currentIndex = scaleNotes.indexOf(prevNote);
                let nextIndex = currentIndex + (stepSize * direction);
                
                // Keep within range
                nextIndex = Math.max(0, Math.min(scaleNotes.length - 1, nextIndex));
                let nextNote = scaleNotes[nextIndex];
                
                // Occasionally land on chord tones (especially at phrase points)
                if (i === length - 1 || (i > 0 && i % 4 === 0)) {
                    // End on a stable note
                    const chordTones = currentChordNotes.filter(n => 
                        Math.abs(n - nextNote) <= 4
                    );
                    if (chordTones.length > 0) {
                        nextNote = randomChoice(chordTones);
                    }
                }
                
                motif.push(nextNote);
                prevNote = nextNote;
            }
            
            centralMotif = motif;
            updateStaveDisplay();
            log('system', `♪ New motif: ${motif.map(midiToNoteName).join(' ')}`);
            
            // Re-analyze harmony when motif changes
            if (isPlaying) {
                analyzeMotifHarmony();
            }
            
            return motif;
        }
        
        // Update the visual stave display
        function updateStaveDisplay() {
            const container = document.getElementById('staveNotes');
            if (!container) return;
            
            container.innerHTML = '';
            
            for (let i = 0; i < MAX_MOTIF_LENGTH; i++) {
                const slot = document.createElement('div');
                slot.className = 'stave-note-slot';
                slot.dataset.index = i;
                
                const note = centralMotif[i];
                const noteEl = document.createElement('div');
                noteEl.className = 'stave-note' + (note === undefined ? ' empty' : '');
                
                if (note !== undefined) {
                    // Position note on stave (C4=60 is middle line)
                    // Each line/space is about 8% of height
                    // C4 = 50%, B4 = 42%, D4 = 58%, etc.
                    const semitoneFromMiddleC = note - 60;
                    // 7 semitones = octave, but we want diatonic position
                    const noteInOctave = note % 12;
                    const octave = Math.floor(note / 12);
                    const diatonicPos = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6][noteInOctave]; // C=0, D=1, E=2, F=3, G=4, A=5, B=6
                    const middleCOctave = 5;
                    const totalDiatonic = (octave - middleCOctave) * 7 + diatonicPos;
                    
                    // Each diatonic step is ~6% of height, middle C at 50%
                    const topPercent = 50 - (totalDiatonic * 6);
                    noteEl.style.top = `${Math.max(5, Math.min(85, topPercent))}%`;
                    
                    // Add ledger lines if needed
                    if (topPercent < 15 || topPercent > 85) {
                        const ledger = document.createElement('div');
                        ledger.className = 'stave-ledger';
                        ledger.style.top = noteEl.style.top;
                        slot.appendChild(ledger);
                    }
                    
                    // Note label
                    const label = document.createElement('div');
                    label.className = 'stave-note-label';
                    label.textContent = midiToNoteName(note);
                    slot.appendChild(label);
                } else {
                    noteEl.style.top = '50%';
                }
                
                slot.appendChild(noteEl);
                
                // Click handler for editing (left-click), right-click for delete
                slot.addEventListener('click', (e) => handleStaveClick(i, e));
                slot.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleStaveClick(i, e);
                });
                
                container.appendChild(slot);
            }
        }
        
        // Handle clicking on the stave to edit notes
        function handleStaveClick(index, event) {
            // Right-click to delete a note
            if (event.button === 2) {
                event.preventDefault();
                if (index < centralMotif.length) {
                    centralMotif.splice(index, 1);
                    updateStaveDisplay();
                    log('system', `♪ Note removed. Motif: ${centralMotif.length > 0 ? centralMotif.map(midiToNoteName).join(' ') : '(empty)'}`);
                    
                    // Re-analyze harmony when notes change
                    if (isPlaying && centralMotif.length > 0) {
                        analyzeMotifHarmony();
                    }
                }
                return;
            }
            
            // Don't add notes if not initialized
            if (globalRoot === null || !globalScaleIntervals) {
                log('system', '⚠ Initialize first to edit motif');
                return;
            }
            
            const container = document.getElementById('staveContainer');
            const rect = container.getBoundingClientRect();
            const clickY = event.clientY - rect.top;
            const heightPercent = (clickY / rect.height) * 100;
            
            // Convert click position to MIDI note
            // 50% = middle C (60), each 6% = one diatonic step
            const diatonicFromMiddle = (50 - heightPercent) / 6;
            const octaveShift = Math.floor(diatonicFromMiddle / 7);
            const diatonicInOctave = Math.round(((diatonicFromMiddle % 7) + 7) % 7);
            
            // Map diatonic position to scale degree
            const diatonicToSemitone = [0, 2, 4, 5, 7, 9, 11]; // Major scale intervals
            const semitone = diatonicToSemitone[diatonicInOctave];
            
            // Calculate MIDI note in current key
            const baseOctave = 60 + (octaveShift * 12);
            let midiNote = baseOctave + globalRoot + semitone;
            
            // Snap to scale if needed
            const interval = (midiNote - globalRoot) % 12;
            const normalized = (interval + 12) % 12;
            if (!globalScaleIntervals.includes(normalized)) {
                // Find nearest scale tone
                let nearest = globalScaleIntervals.reduce((prev, curr) => 
                    Math.abs(curr - normalized) < Math.abs(prev - normalized) ? curr : prev
                );
                midiNote = midiNote - normalized + nearest;
            }
            
            // Enforce max 12 notes
            if (index >= MAX_MOTIF_LENGTH) {
                log('system', '⚠ Maximum 12 notes in motif');
                return;
            }
            
            // Update the motif
            if (index < centralMotif.length) {
                centralMotif[index] = midiNote;
            } else {
                // Extend motif if clicking in empty slot
                while (centralMotif.length < index) {
                    centralMotif.push(centralMotif[centralMotif.length - 1] || 60);
                }
                if (centralMotif.length < MAX_MOTIF_LENGTH) {
                    centralMotif.push(midiNote);
                }
            }
            
            updateStaveDisplay();
            
            // Play the note for feedback
            if (audioCtx && audioCtx.state === 'running') {
                playPreviewNote(midiNote);
            }
            
            log('system', `♪ Motif edited: ${centralMotif.map(midiToNoteName).join(' ')}`);
            
            // Re-analyze harmony when motif changes
            if (isPlaying) {
                analyzeMotifHarmony();
            }
        }
        
        // Play a short preview note
        function playPreviewNote(midiNote) {
            const freq = midiToFreq(midiNote);
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.value = freq;
            osc.type = 'triangle';
            gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }
        
        // Highlight a note on the stave when playing
        function highlightMotifNote(index) {
            const slots = document.querySelectorAll('.stave-note-slot');
            slots.forEach((slot, i) => {
                const note = slot.querySelector('.stave-note');
                if (note) {
                    note.classList.toggle('playing', i === index);
                }
            });
            
            // Show "playing" indicator
            const indicator = document.getElementById('motifPlaying');
            if (indicator) {
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), 500);
            }
        }
        
        // Get the next note from the motif with possible variation
        function getNextMotifNote(availableNotes) {
            if (centralMotif.length === 0) return null;
            
            const note = centralMotif[motifPlaybackIndex];
            motifPlaybackIndex = (motifPlaybackIndex + 1) % centralMotif.length;
            
            // Occasionally vary the note
            if (Math.random() < MOTIF_VARIATION_CHANCE) {
                const variation = randomChoice([-2, -1, 1, 2]); // Small interval variation
                const variedNote = note + variation;
                // Ensure it's in the available range
                if (availableNotes.includes(variedNote) || 
                    availableNotes.some(n => Math.abs(n - variedNote) <= 2)) {
                    return findNearestChordTone(variedNote, availableNotes);
                }
            }
            
            // Find the note in the instrument's range
            return findNearestChordTone(note, availableNotes);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // SECTION MELODY OWNERSHIP
        // ═══════════════════════════════════════════════════════════════
        
        // Assign melody to a section
        function assignMelodySection() {
            const sections = Object.keys(orchestralSections);
            currentMelodySection = randomChoice(sections);
            melodySectionStartTime = Date.now();
            
            const duration = MELODY_SECTION_DURATION.min + 
                Math.random() * (MELODY_SECTION_DURATION.max - MELODY_SECTION_DURATION.min);
            
            log('decision', `♪ ${currentMelodySection.toUpperCase()} takes the melody`);
            
            // Schedule next section change
            setTimeout(() => {
                if (isPlaying) {
                    assignMelodySection();
                }
            }, duration);
        }
        
        // Check if an instrument should play the motif
        function shouldPlayMotif(instrument) {
            const section = getInstrumentSection(instrument);
            if (!section || section !== currentMelodySection) return false;
            
            // Leader has highest chance, others follow
            const isLeader = isSectionLeader(instrument);
            const baseChance = isLeader ? 0.45 : 0.2;
            
            // Don't play motif too frequently
            const timeSinceLast = Date.now() - lastMotifPlayTime;
            if (timeSinceLast < 3000) return false; // At least 3 seconds between motif notes
            
            return Math.random() < baseChance;
        }
        
        // Get supporting harmony for the current motif note
        function getMotifSupportNote(instrument, availableNotes) {
            if (centralMotif.length === 0) return null;
            
            const currentMotifNote = centralMotif[motifPlaybackIndex > 0 ? motifPlaybackIndex - 1 : 0];
            
            // Use the motif harmony system to find good supporting notes
            if (motifHarmony.harmonyNotes.length > 0) {
                return getMotifHarmonyNote(currentMotifNote, availableNotes);
            }
            
            // Fallback: Play a harmony note (3rd, 5th, or octave below/above)
            const harmonyIntervals = [-12, -7, -5, -4, -3, 3, 4, 5, 7, 12];
            const interval = randomChoice(harmonyIntervals);
            const harmonyNote = currentMotifNote + interval;
            
            return findNearestChordTone(harmonyNote, availableNotes);
        }
        
        // ═══════════════════════════════════════════════════════════════
        // INTERCONNECTION SYSTEM - Call and Response
        // ═══════════════════════════════════════════════════════════════
        
        // Recent notes played (for unison/sympathy)
        let recentNotes = [];  // { note, instrument, time }
        const RECENT_NOTES_WINDOW = 3000; // 3 second memory
        
        // ═══════════════════════════════════════════════════════════════
        // ORCHESTRAL SECTIONS - Instruments grouped by family
        // ═══════════════════════════════════════════════════════════════
        const orchestralSections = {
            strings: {
                instruments: ['violins', 'cello', 'bass'],
                leader: 'violins',           // Section leader initiates phrases
                color: 'harp',               // Color instrument that occasionally joins
                role: 'foundation',          // Strings provide harmonic foundation
                cohesion: 0.7,               // How tightly section plays together (0-1)
                responseDelay: { min: 0.1, max: 0.4 }  // Seconds before section responds
            },
            keys: {
                instruments: ['piano', 'celeste', 'rhodes', 'vibraphone'],
                leader: 'piano',
                color: 'guitar',
                role: 'color',               // Keys add harmonic color and texture
                cohesion: 0.5,               // More independent voices
                responseDelay: { min: 0.05, max: 0.25 }
            },
            woodwinds: {
                instruments: ['flute', 'oboe', 'clarinet', 'bassoon'],
                leader: 'flute',
                ensemble: 'woodwinds',       // Full section sound
                color: 'whistle',            // Ethnic color
                role: 'melody',              // Woodwinds carry melodic lines
                cohesion: 0.65,
                responseDelay: { min: 0.08, max: 0.3 }
            },
            brass: {
                instruments: ['horns', 'trumpet', 'lowbrass'],
                leader: 'horns',
                ensemble: 'brass',           // Full section sound
                role: 'power',               // Brass provides climactic moments
                cohesion: 0.75,              // Brass plays very tight together
                responseDelay: { min: 0.05, max: 0.2 }
            }
        };
        
        // Map each instrument to its section
        const instrumentToSection = {};
        Object.entries(orchestralSections).forEach(([sectionName, section]) => {
            section.instruments.forEach(inst => {
                instrumentToSection[inst] = sectionName;
            });
            if (section.color) instrumentToSection[section.color] = sectionName;
            if (section.ensemble) instrumentToSection[section.ensemble] = sectionName;
        });
        
        // Section activity tracking
        let sectionActivity = {
            strings: { lastPlay: 0, activeInstruments: [], currentPhrase: null },
            keys: { lastPlay: 0, activeInstruments: [], currentPhrase: null },
            woodwinds: { lastPlay: 0, activeInstruments: [], currentPhrase: null },
            brass: { lastPlay: 0, activeInstruments: [], currentPhrase: null }
        };
        
        // Track when sections should play together
        let sectionCues = {}; // { sectionName: { note, time, leader } }
        
        // Antiphonal pairs (for call-and-response between sections)
        const antiphonalPairs = {
            groupA: ['violins', 'cello', 'bass', 'harp', 'piano', 'guitar', 'celeste', 'rhodes', 'vibraphone'],
            groupB: ['whistle', 'flute', 'oboe', 'clarinet', 'bassoon', 'woodwinds', 'horns', 'trumpet', 'lowbrass', 'brass'],
            mediator: 'piano'
        };
        
        // Instruments that can naturally glide/portamento between notes
        const glissandoInstruments = {
            violins: { chance: 0.2, maxInterval: 7, speed: 0.18 },     // Expressive string slides
            cello: { chance: 0.25, maxInterval: 7, speed: 0.18 },
            bass: { chance: 0.18, maxInterval: 5, speed: 0.2 },
            harp: { chance: 0.1, maxInterval: 12, speed: 0.12 },
            guitar: { chance: 0.15, maxInterval: 5, speed: 0.15 },
            whistle: { chance: 0.22, maxInterval: 7, speed: 0.12 },
            flute: { chance: 0.18, maxInterval: 5, speed: 0.12 },
            oboe: { chance: 0.12, maxInterval: 3, speed: 0.12 },
            clarinet: { chance: 0.2, maxInterval: 7, speed: 0.12 },
            bassoon: { chance: 0.1, maxInterval: 3, speed: 0.16 },
            woodwinds: { chance: 0.15, maxInterval: 5, speed: 0.15 },
            horns: { chance: 0.12, maxInterval: 5, speed: 0.2 },
            trumpet: { chance: 0.1, maxInterval: 4, speed: 0.18 },
            lowbrass: { chance: 0.2, maxInterval: 12, speed: 0.22 },
            brass: { chance: 0.1, maxInterval: 5, speed: 0.2 },
            vibraphone: { chance: 0.1, maxInterval: 12, speed: 0.25 }
        };
        
        // Track last note per instrument for glissando
        let lastNoteByInstrument = {};
        
        // Last phrase ending (for question/answer)
        let lastPhraseEnding = { note: null, instrument: null, isQuestion: false };
        
        // Track recent melodies for retrograde/inversion
        let recentMelodies = {}; // Per-instrument melody fragments
        const MELODY_MEMORY = 6; // Remember last N notes for transformations
        
        // Interconnection chances (0-1)
        const interconnectChances = {
            antiphonalResponse: 0.22,    // Chance opposite group responds
            questionAnswer: 0.25,        // Chance of answering a question phrase
            unison: 0.08,                // Chance of playing same note as recent
            proximityInfluence: 0.15,    // Chance nearby pan instruments interact
            sympathyHarmony: 0.12,       // Chance of playing harmony to recent note
            retrograde: 0.06,            // Chance to play another's melody backwards
            inversion: 0.06,             // Chance to play another's melody inverted
            invertedRetrograde: 0.04     // Chance to play backwards AND inverted (rare)
        };
        
        // Motif system - repeated phrases with gentle transformations
        const motifSettings = {
            length: { min: 3, max: 6 },
            hold: { min: 2, max: 4 },
            repeatChance: 0.45,
            transposeChance: 0.2,
            invertChance: 0.15,
            retroChance: 0.12,
            expandChance: 0.08,
            maxLength: 8,
            transposeSteps: [-2, -1, 1, 2]
        };
        
        let motifState = {};
        
        // ═══════════════════════════════════════════════════════════════
        // ARPEGGIATION SYSTEM - Chance to arpeggiate chords instead of playing simultaneously
        // ═══════════════════════════════════════════════════════════════
        const arpeggioSettings = {
            // Per-instrument arpeggio tendencies
            violins: { chance: 0.18, speed: { min: 0.12, max: 0.28 } },    // Light string figures
            cello: { chance: 0.12, speed: { min: 0.15, max: 0.35 } },      // Slow, stately arpeggios
            bass: { chance: 0.08, speed: { min: 0.2, max: 0.4 } },         // Slow bass rolls
            harp: { chance: 0.55, speed: { min: 0.06, max: 0.14 } },       // Natural harp arpeggiation
            piano: { chance: 0.32, speed: { min: 0.1, max: 0.22 } },       // Soft broken chords
            guitar: { chance: 0.45, speed: { min: 0.08, max: 0.18 } },     // Gentle plucked rolls
            celeste: { chance: 0.35, speed: { min: 0.08, max: 0.18 } },    // Quick, sparkling arpeggios
            rhodes: { chance: 0.2, speed: { min: 0.1, max: 0.25 } },       // Jazzy chord rolls
            vibraphone: { chance: 0.25, speed: { min: 0.1, max: 0.22 } },  // Mallet rolls
            whistle: { chance: 0.12, speed: { min: 0.12, max: 0.24 } },    // Breath-driven figures
            flute: { chance: 0.12, speed: { min: 0.12, max: 0.24 } },
            oboe: { chance: 0.1, speed: { min: 0.14, max: 0.28 } },
            clarinet: { chance: 0.12, speed: { min: 0.12, max: 0.25 } },
            bassoon: { chance: 0.08, speed: { min: 0.18, max: 0.3 } },
            woodwinds: { chance: 0.15, speed: { min: 0.12, max: 0.26 } }
        };
        
        // Arpeggio patterns (index offsets for note order)
        const arpeggioPatterns = {
            up: (notes) => [...notes].sort((a, b) => a - b),                    // Low to high
            down: (notes) => [...notes].sort((a, b) => b - a),                  // High to low
            upDown: (notes) => {                                                 // Up then back down
                const sorted = [...notes].sort((a, b) => a - b);
                return [...sorted, ...sorted.slice(1, -1).reverse()];
            },
            downUp: (notes) => {                                                 // Down then back up  
                const sorted = [...notes].sort((a, b) => b - a);
                return [...sorted, ...sorted.slice(1, -1).reverse()];
            },
            random: (notes) => {                                                 // Random order
                const shuffled = [...notes];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            },
            insideOut: (notes) => {                                              // Middle notes first, then outer
                const sorted = [...notes].sort((a, b) => a - b);
                const result = [];
                let left = 0, right = sorted.length - 1;
                let fromLeft = true;
                while (left <= right) {
                    if (fromLeft) result.push(sorted[left++]);
                    else result.push(sorted[right--]);
                    fromLeft = !fromLeft;
                }
                return result.reverse();
            }
        };
        
        // Motif helpers
        function resetMotifState() {
            motifState = {};
            // Reset section coordination state
            sectionActivity = {
                strings: { lastPlay: 0, activeInstruments: [], currentPhrase: null },
                keys: { lastPlay: 0, activeInstruments: [], currentPhrase: null },
                woodwinds: { lastPlay: 0, activeInstruments: [], currentPhrase: null },
                brass: { lastPlay: 0, activeInstruments: [], currentPhrase: null }
            };
            sectionCues = {};
            lastNoteByInstrument = {};
            recentNotes = [];
            recentMelodies = {};
            
            // Reset central motif state
            centralMotif = [];
            currentMelodySection = null;
            melodySectionStartTime = 0;
            motifPlaybackIndex = 0;
            lastMotifPlayTime = 0;
            
            // Reset motif harmony
            motifHarmony = {
                chordProgression: [],
                currentChordIndex: 0,
                harmonyNotes: []
            };
        }
        
        function sameNoteArray(a, b) {
            if (!a || !b || a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) return false;
            }
            return true;
        }
        
        function getScaleNotesInRange(rangeLow, rangeHigh) {
            const notes = [];
            const low = Math.max(0, Math.floor(rangeLow));
            const high = Math.min(127, Math.ceil(rangeHigh));
            for (let midi = low; midi <= high; midi++) {
                const interval = (midi - globalRoot) % 12;
                const normalized = (interval + 12) % 12;
                if (globalScaleIntervals.includes(normalized)) {
                    notes.push(midi);
                }
            }
            return notes;
        }
        
        function quantizeNoteToScale(note, scaleNotes, range) {
            const low = range[0];
            const high = range[1];
            const clamped = Math.max(low, Math.min(high, note));
            if (!scaleNotes || scaleNotes.length === 0) return clamped;
            return scaleNotes.reduce((nearest, curr) =>
                Math.abs(curr - clamped) < Math.abs(nearest - clamped) ? curr : nearest
            , scaleNotes[0]);
        }
        
        function quantizeMotif(notes, scaleNotes, range) {
            return notes.map(note => quantizeNoteToScale(note, scaleNotes, range));
        }
        
        function buildMotifBase(rootNote, scaleNotes, length) {
            const motif = [];
            let currentNote = rootNote;
            for (let i = 0; i < length; i++) {
                motif.push(currentNote);
                const nearbyNotes = scaleNotes.filter(n => Math.abs(n - currentNote) <= 7 && n !== currentNote);
                if (nearbyNotes.length > 0) currentNote = randomChoice(nearbyNotes);
            }
            return motif;
        }
        
        function getNearestScaleIndex(note, scaleNotes) {
            let bestIndex = 0;
            let bestDiff = Infinity;
            for (let i = 0; i < scaleNotes.length; i++) {
                const diff = Math.abs(scaleNotes[i] - note);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestIndex = i;
                }
            }
            return bestIndex;
        }
        
        function transposeMotifByScaleSteps(notes, scaleNotes, steps) {
            if (!scaleNotes || scaleNotes.length === 0) return notes.slice();
            return notes.map(note => {
                const idx = getNearestScaleIndex(note, scaleNotes);
                const newIndex = Math.max(0, Math.min(scaleNotes.length - 1, idx + steps));
                return scaleNotes[newIndex];
            });
        }
        
        function invertMotif(notes, axisNote, scaleNotes, range) {
            return notes.map(note => {
                const inverted = axisNote * 2 - note;
                return quantizeNoteToScale(inverted, scaleNotes, range);
            });
        }
        
        function getAdjacentScaleStep(note, direction, scaleNotes) {
            if (!scaleNotes || scaleNotes.length === 0) return note;
            const idx = getNearestScaleIndex(note, scaleNotes);
            const nextIndex = Math.max(0, Math.min(scaleNotes.length - 1, idx + direction));
            return scaleNotes[nextIndex];
        }
        
        function expandMotif(notes, scaleNotes, maxLength) {
            const expanded = [];
            for (let i = 0; i < notes.length; i++) {
                const note = notes[i];
                expanded.push(note);
                if (expanded.length >= maxLength) break;
                const next = notes[i + 1];
                if (!next) continue;
                if (Math.random() < 0.6) {
                    const direction = next > note ? 1 : -1;
                    const passing = getAdjacentScaleStep(note, direction, scaleNotes);
                    if (passing !== note && passing !== next) expanded.push(passing);
                } else if (Math.random() < 0.2) {
                    expanded.push(note);
                }
                if (expanded.length >= maxLength) break;
            }
            return expanded.slice(0, maxLength);
        }
        
        function seedMotifState(inst, baseNotes) {
            motifState[inst] = {
                base: baseNotes.slice(),
                variant: baseNotes.slice(),
                hold: randomInt(motifSettings.hold.min, motifSettings.hold.max)
            };
            return motifState[inst];
        }
        
        function ensureMotifState(inst, baseNotes) {
            const state = motifState[inst];
            if (!state || !sameNoteArray(state.base, baseNotes)) {
                return seedMotifState(inst, baseNotes);
            }
            return state;
        }
        
        function transformMotif(baseNotes, scaleNotes, range) {
            if (!baseNotes || baseNotes.length === 0) return [];
            if (!scaleNotes || scaleNotes.length === 0) return baseNotes.slice();
            
            const roll = Math.random();
            let variant = baseNotes.slice();
            
            if (roll < motifSettings.repeatChance) {
                variant = baseNotes.slice();
            } else if (roll < motifSettings.repeatChance + motifSettings.transposeChance) {
                const steps = randomChoice(motifSettings.transposeSteps);
                variant = transposeMotifByScaleSteps(baseNotes, scaleNotes, steps);
            } else if (roll < motifSettings.repeatChance + motifSettings.transposeChance + motifSettings.invertChance) {
                const axisNote = baseNotes[Math.floor(baseNotes.length / 2)];
                variant = invertMotif(baseNotes, axisNote, scaleNotes, range);
            } else if (roll < motifSettings.repeatChance + motifSettings.transposeChance + motifSettings.invertChance + motifSettings.retroChance) {
                variant = baseNotes.slice().reverse();
            } else {
                variant = expandMotif(baseNotes, scaleNotes, motifSettings.maxLength);
            }
            
            variant = quantizeMotif(variant, scaleNotes, range);
            if (variant.length === 0) return baseNotes.slice();
            return variant.slice(0, motifSettings.maxLength);
        }
        
        function getMotifNotes(inst, config) {
            const range = config.range || [24, 108];
            const scaleNotes = getScaleNotesInRange(range[0], range[1]);
            if (!config.motifBase || config.motifBase.length === 0) {
                if (scaleNotes.length === 0) return config.notes || [];
                const motifLength = randomInt(motifSettings.length.min, motifSettings.length.max);
                const rootNote = quantizeNoteToScale(config.baseOctave || randomChoice(scaleNotes), scaleNotes, range);
                config.motifBase = buildMotifBase(rootNote, scaleNotes, motifLength);
            }
            
            if (!config.motifBase || config.motifBase.length === 0) return config.notes || [];
            
            const state = ensureMotifState(inst, config.motifBase);
            if (state.hold <= 0) {
                state.variant = transformMotif(state.base, scaleNotes, range);
                state.hold = randomInt(motifSettings.hold.min, motifSettings.hold.max);
            }
            state.hold -= 1;
            
            config.notes = state.variant.slice();
            return config.notes;
        }
        
        function refreshMotifForInstrument(inst, config) {
            if (!config || !config.motifBase || config.motifBase.length === 0) return;
            const range = config.range || [24, 108];
            const scaleNotes = getScaleNotesInRange(range[0], range[1]);
            if (!scaleNotes.length) return;
            const retuned = quantizeMotif(config.motifBase, scaleNotes, range);
            config.motifBase = retuned;
            config.notes = retuned.slice();
            seedMotifState(inst, config.motifBase);
        }
        
        // Track if a group just played (for antiphonal)
        let lastPlayingGroup = null;
        let groupPlayTime = 0;

        // ═══════════════════════════════════════════════════════════════
        // WEATHER SYSTEM - Per-channel slow-moving parameters
        // ═══════════════════════════════════════════════════════════════
        
        const CHANNEL_NAMES = [...INSTRUMENT_ORDER];
        
        // Default weather values (each channel gets its own copy)
        const defaultWeather = {
            presence: 0.6,      // Volume (low = quiet)
            density: 0.35,      // Note frequency (low = sparse)
            intimacy: 0.6,      // Reverb mix (low = wet/distant)
            drift: 0.25,        // Pitch stability (high = detuned)
            breath: 0.35,       // Attack time (low = slow)
            decay: 0.5,         // Release time (high = long)
            depth: 0.35,        // Octave-down chance (high = more bass notes)
            suspension: 0.25,   // Sus chord tendency
            solitude: 0.6,      // Call-response (low = interactive)
            memory: 0.5,        // Delay feedback (high = long trails)
            complexity: 0.3,    // Chord complexity (low = triads, high = extended/altered)
            expansiveness: 0.4  // Voicing spread (low = tight, high = wide/open)
        };
        
        // Per-channel weather state
        const channelWeather = {};
        const channelWeatherTargets = {};
        CHANNEL_NAMES.forEach(ch => {
            // Start each channel with slightly different values
            channelWeather[ch] = { ...defaultWeather };
            Object.keys(channelWeather[ch]).forEach(param => {
                channelWeather[ch][param] += (Math.random() - 0.5) * 0.3;
                channelWeather[ch][param] = Math.max(0.1, Math.min(0.9, channelWeather[ch][param]));
            });
            channelWeatherTargets[ch] = { ...channelWeather[ch] };
        });
        
        // Drift speed per parameter (faster for more noticeable changes)
        const weatherSpeeds = {
            presence: 0.003,
            density: 0.0025,
            intimacy: 0.0028,
            breath: 0.004,
            decay: 0.002,
            drift: 0.0035,
            depth: 0.0015,
            suspension: 0.0028,
            solitude: 0.0025,
            memory: 0.002,
            complexity: 0.002,
            expansiveness: 0.0025
        };
        
        // How often to pick new targets (ms) - 1-2 minute cycles
        const weatherChangeIntervals = {
            presence: { min: 60000, max: 120000 },    // 1-2 min
            density: { min: 75000, max: 135000 },    // 1.25-2.25 min
            intimacy: { min: 55000, max: 110000 },   // ~1-2 min
            breath: { min: 50000, max: 100000 },     // ~1-1.5 min
            decay: { min: 70000, max: 130000 },      // ~1-2 min
            drift: { min: 60000, max: 120000 },      // 1-2 min
            depth: { min: 90000, max: 150000 },      // 1.5-2.5 min (slowest)
            suspension: { min: 65000, max: 125000 }, // ~1-2 min
            solitude: { min: 70000, max: 130000 },   // ~1-2 min
            memory: { min: 80000, max: 140000 },     // ~1.5-2.5 min
            complexity: { min: 90000, max: 180000 }, // ~1.5-3 min (slower for chord complexity)
            expansiveness: { min: 80000, max: 160000 } // ~1.5-2.5 min
        };
        
        let weatherDriftInterval = null;
        let weatherTargetTimeouts = {};
        
        // Legacy global weather - averages all channels for UI display and global effects
        const weather = { ...defaultWeather };
        
        function startWeatherSystem() {
            // Start the continuous drift
            weatherDriftInterval = setInterval(driftWeather, 200); // Update 5x per second
            
            // Schedule target changes for each channel and parameter
            CHANNEL_NAMES.forEach(channel => {
                Object.keys(defaultWeather).forEach(param => {
                    scheduleWeatherChange(channel, param);
                });
            });
            
            log('system', '☁ Weather system active (per-channel)');
        }
        
        function stopWeatherSystem() {
            if (weatherDriftInterval) clearInterval(weatherDriftInterval);
            Object.values(weatherTargetTimeouts).forEach(t => clearTimeout(t));
            weatherTargetTimeouts = {};
        }
        
        function driftWeather() {
            // Each channel's parameters drift toward their targets
            CHANNEL_NAMES.forEach(channel => {
                Object.keys(defaultWeather).forEach(param => {
                    const diff = channelWeatherTargets[channel][param] - channelWeather[channel][param];
                    channelWeather[channel][param] += diff * weatherSpeeds[param] * 10;
                    channelWeather[channel][param] = Math.max(0, Math.min(1, channelWeather[channel][param]));
                });
            });
            
            // Update global weather as average of all channels (for UI and global effects)
            Object.keys(defaultWeather).forEach(param => {
                let sum = 0;
                CHANNEL_NAMES.forEach(ch => sum += channelWeather[ch][param]);
                weather[param] = sum / CHANNEL_NAMES.length;
            });
            
            // Update UI every ~500ms (every 5th call)
            if (Math.random() < 0.12) updateWeatherDisplay();
        }
        
        function updateWeatherDisplay() {
            // Update per-channel weather bars with random transitions
            CHANNEL_NAMES.forEach((channel) => {
                const dom = weatherDomCache[channel];
                if (!dom) return;
                Object.keys(defaultWeather).forEach((param) => {
                    const el = dom[param];
                    if (el) {
                        // Set random transition duration for organic movement
                        const duration = getRandomTransitionDuration();
                        el.style.setProperty('--wx-duration', `${duration}s`);
                        el.style.setProperty('--wx-level', channelWeather[channel][param].toFixed(3));
                    }
                });
            });
        }
        
        function scheduleWeatherChange(channel, param) {
            const intervals = weatherChangeIntervals[param];
            const delay = intervals.min + Math.random() * (intervals.max - intervals.min);
            const timeoutKey = `${channel}_${param}`;
            
            weatherTargetTimeouts[timeoutKey] = setTimeout(() => {
                if (!isPlaying) return;
                
                // Pick new target - with momentum
                const currentVal = channelWeather[channel][param];
                const currentTarget = channelWeatherTargets[channel][param];
                const momentum = currentTarget - currentVal;
                
                // 60% chance to continue direction, 40% chance to reverse
                let newTarget;
                if (Math.random() < 0.6 && Math.abs(momentum) > 0.1) {
                    newTarget = currentTarget + (momentum > 0 ? 0.2 : -0.2) + (Math.random() - 0.5) * 0.3;
                } else {
                    newTarget = Math.random();
                }
                
                // Occasionally go to extremes (10% chance)
                if (Math.random() < 0.1) {
                    newTarget = Math.random() < 0.5 ? 0.1 : 0.9;
                }
                
                newTarget = Math.max(0.05, Math.min(0.95, newTarget));
                channelWeatherTargets[channel][param] = newTarget;
                
                // Log significant changes
                if (Math.abs(newTarget - currentVal) > 0.4) {
                    const direction = newTarget > currentVal ? '↑' : '↓';
                    log('weather', `${channel}.${param} ${direction}`);
                }
                
                // Schedule next change
                scheduleWeatherChange(channel, param);
            }, delay);
        }
        
        // Get weather-adjusted parameters for note playback (per-channel)
        function getWeatherAdjustments(channel = null) {
            // Use channel-specific weather if provided, otherwise use global average
            const wx = channel && channelWeather[channel] ? channelWeather[channel] : weather;
            return {
                // Presence affects volume and attack prominence
                volumeMultiplier: 0.3 + wx.presence * 0.7, // 0.3-1.0
                attackMultiplier: 0.5 + (1 - wx.breath) * 4, // 0.5-4.5 (low breath = slow attack)
                
                // Density affects whether to play chords or single notes
                singleNoteChance: 1 - wx.density, // Low density = more single notes
                silenceMultiplier: 1.15 + (1 - wx.density) * 2.4, // Low density = more silence
                
                // Intimacy affects reverb mix and pre-delay
                reverbMixMultiplier: 0.5 + (1 - wx.intimacy) * 1.5, // 0.5-2.0
                preDelay: (1 - wx.intimacy) * 0.5, // 0-500ms pre-delay when distant
                
                // Drift affects pitch stability
                detuneAmount: wx.drift * 25, // 0-25 cents
                vibratoMultiplier: 0.5 + wx.drift * 1.5, // 0.5-2.0
                
                // Decay affects release time
                releaseMultiplier: 0.5 + wx.decay * 3, // 0.5-3.5x
                
                // Depth affects octave-down chance (x2 lower octave notes)
                octaveDownChance: wx.depth * 0.5, // 0-50% chance to play octave lower
                
                // Suspension affects voicing choices
                suspendedChance: wx.suspension * 0.6, // 0-60% chance of sus voicing
                
                // Solitude affects call-and-response behavior
                responseChance: (1 - wx.solitude) * 0.35, // 0-35% when not solitary
                
                // Memory affects delay feedback and reverb tail
                delayFeedbackMultiplier: 0.5 + wx.memory * 1.0, // 0.5-1.5
                reverbDecayMultiplier: 0.7 + wx.memory * 0.8 // 0.7-1.5
            };
        }

        // Master output
        let dryGain = null;  // Main output for all per-channel effects
        
        // Per-channel effects state - darker, more reverb
        let channelEffects = {};

        // Effect parameter ranges - vintage Silvertone/Fender amp style
        const effectRanges = {
            // Vibrato (pitch wobble) - Fender "vibrato" circuit style
            vibratoDepth: { min: 0.002, max: 0.015 },  // Subtle pitch deviation (0.2-1.5%)
            vibratoAmount: { min: 0, max: 1 },          // Intensity dial 0-10
            vibratoSpeed: { min: 1, max: 10 },          // Classic range ~1-10 Hz
            
            // Tremolo (volume wobble) - Fender/Silvertone tremolo circuit
            tremoloDepth: { min: 0, max: 0.8 },         // How deep the throb (0-80%)
            tremoloAmount: { min: 0, max: 1 },          // Intensity dial 0-10
            tremoloSpeed: { min: 1, max: 12 },          // Slow surf to fast helicopter
            
            // Delay - tape echo style (Echoplex, Space Echo)
            delayTime: { min: 0.05, max: 0.6 },         // 50ms-600ms (tape delay range)
            delayAmount: { min: 0, max: 0.8 },          // Mix dial 0-10
            delayFeedback: { min: 0, max: 0.85 },       // Repeats (careful near max!)
            
            // Reverb - deep hall/plate style (darker, longer)
            reverbAmount: { min: 0.2, max: 0.95 },      // More reverb overall
            reverbDecay: { min: 3, max: 12 },           // Much longer: 3-12 seconds
            reverbTone: { min: 400, max: 3000 },        // Darker: lower cutoff range
            
            // Pan - full stereo field
            pan: { min: -1, max: 1 },                   // Full left to full right
            
            // 3-band EQ - vintage amp style (±12dB like old Fender/Silvertone)
            eqLow: { min: -12, max: 12 },               // Bass knob (~100Hz)
            eqMid: { min: -12, max: 12 },               // Mid knob (~1kHz)
            eqHigh: { min: -12, max: 12 },              // Treble knob (~4kHz)
            
            // Filter sweep - Disasterpeace style slow movement
            filterSweep: { min: 400, max: 8000 }        // Very slow sweeping lowpass
        };
        
        // Disasterpeace-style chances (per note)
        const disasterpeaceChances = {
            detunedLayers: 0.25,      // Chance of 2-3 detuned oscillators
            octaveDouble: 0.2,        // Chance to double octave above/below
            octaveAbove: 0.5,         // If doubling, 50% above, 50% below
            octaveDown: 0.15,         // Chance to play note an octave lower (darker)
            dynamicSwell: 0.35        // Chance of volume swell envelope (Eno-style)
        };
        
        let effectsEbbInterval = null;
        let modeChangeInterval = null;

        // ═══════════════════════════════════════════════════════════════
        // UTILITIES
        // ═══════════════════════════════════════════════════════════════
        
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max + 1));
        }

        function randomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function midiToFreq(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }

        function midiToNoteName(midi) {
            return NOTE_NAMES[midi % 12] + Math.floor(midi / 12 - 1);
        }

        function generateScaleNotes(rootMidi, intervals, octaves = 5) {
            const notes = [];
            for (let oct = 0; oct < octaves; oct++) {
                for (const interval of intervals) {
                    notes.push(rootMidi + interval + (oct * 12));
                }
            }
            return notes;
        }

        function generateRandomChord() {
            // Get complexity from weather (average across channels)
            const avgComplexity = weather.complexity || 0.5;
            
            // Weight chord types based on complexity weather
            // Low complexity = simple chords, high complexity = extended/altered
            const typeWeights = {};
            Object.keys(CHORD_TYPES).forEach(type => {
                const chords = CHORD_TYPES[type];
                const avgChordComplexity = chords.reduce((sum, c) => sum + (c.complexity || 0.5), 0) / chords.length;
                
                // Higher weight when chord complexity matches weather complexity
                const complexityDiff = Math.abs(avgChordComplexity - avgComplexity);
                // Bell curve weighting - close matches get high weight
                const weight = Math.max(1, Math.round(20 * Math.exp(-complexityDiff * 3)));
                typeWeights[type] = weight;
            });
            
            const weightedTypes = [];
            for (const [type, weight] of Object.entries(typeWeights)) {
                for (let i = 0; i < weight; i++) weightedTypes.push(type);
            }
            
            const chordType = randomChoice(weightedTypes);
            const chordsOfType = CHORD_TYPES[chordType];
            
            // Filter chords by complexity range
            const complexityRange = 0.3; // Allow some variance
            const filteredChords = chordsOfType.filter(c => {
                const diff = Math.abs((c.complexity || 0.5) - avgComplexity);
                return diff < complexityRange || Math.random() < 0.2; // 20% chance to pick outside range
            });
            
            const chordsToChooseFrom = filteredChords.length > 0 ? filteredChords : chordsOfType;
            
            let chord;
            let attempts = 0;
            do {
                chord = randomChoice(chordsToChooseFrom);
                attempts++;
            } while (chordHistory.includes(chord.name) && attempts < 10);
            
            chordHistory.push(chord.name);
            if (chordHistory.length > 6) chordHistory.shift();
            
            log('chord', `Selected: ${chord.name} (${chordType}, complexity: ${(chord.complexity || 0.5).toFixed(2)})`);
            return chord;
        }
        
        // Get all available chords as flat array
        function getAllChords() {
            const all = [];
            Object.entries(CHORD_TYPES).forEach(([type, chords]) => {
                chords.forEach(chord => {
                    all.push({ ...chord, type });
                });
            });
            return all;
        }
        
        // Set chord by name
        function setChordByName(name) {
            const allChords = getAllChords();
            const found = allChords.find(c => c.name === name);
            if (found) {
                currentChord = found;
                currentChordNotes = getChordNotes(currentChord);
                updateDisplay();
                log('chord', `Manual: ${found.name} (${found.type})`);
                
                // Update synths with new chord
                if (synths.length > 0) {
                    synths.forEach(synth => {
                        if (synth.config.isMelody) {
                            refreshMotifForInstrument(synth.config.synthType, synth.config);
                            return;
                        }
                        synth.config.notes = currentChordNotes.filter(n => 
                            n >= synth.config.range[0] && n <= synth.config.range[1]
                        );
                    });
                }
            }
        }
        
        // Set key (root + scale)
        function setKey(root, scale) {
            globalRoot = root;
            globalScale = scale;
            globalScaleIntervals = SCALES[scale];
            currentChordNotes = getChordNotes(currentChord);
            updateDisplay();
            log('system', `Key changed: ${NOTE_NAMES[root]} ${scale}`);
            
            // Update synths with new key
            if (synths.length > 0) {
                synths.forEach(synth => {
                    if (synth.config.isMelody) {
                        refreshMotifForInstrument(synth.config.synthType, synth.config);
                        return;
                    }
                    synth.config.notes = currentChordNotes.filter(n => 
                        n >= synth.config.range[0] && n <= synth.config.range[1]
                    );
                });
            }
        }

        function getChordNotes(chord) {
            if (!chord) return [];
            const rootMidi = 36 + globalRoot;
            const notes = [];
            
            // Weather: Suspension affects voicing style
            const wx = getWeatherAdjustments();
            const useSuspension = Math.random() < wx.suspendedChance;
            
            for (let octave = 0; octave < 5; octave++) {
                for (const degree of chord.degrees) {
                    let scaleNote = globalScaleIntervals[degree % globalScaleIntervals.length];
                    
                    // Weather: Transform 3rds into sus2 or sus4 ("Light Through Water")
                    if (useSuspension) {
                        // Check if this is a 3rd (typically 3 or 4 semitones from root)
                        const intervalFromRoot = scaleNote % 12;
                        if (intervalFromRoot === 3 || intervalFromRoot === 4) {
                            // Replace with sus2 (2 semitones) or sus4 (5 semitones)
                            scaleNote = Math.random() < 0.5 ? 
                                scaleNote - intervalFromRoot + 2 : // sus2
                                scaleNote - intervalFromRoot + 5;  // sus4
                        }
                    }
                    
                    const midiNote = rootMidi + scaleNote + (octave * 12);
                    if (midiNote >= 24 && midiNote <= 108) {
                        notes.push(midiNote);
                    }
                }
            }
            
            return [...new Set(notes)].sort((a, b) => a - b);
        }

        function findNearestChordTone(currentNote, newChordNotes) {
            if (newChordNotes.length === 0) return currentNote;
            return newChordNotes.reduce((nearest, note) => 
                Math.abs(note - currentNote) < Math.abs(nearest - currentNote) ? note : nearest
            );
        }

        // ═══════════════════════════════════════════════════════════════
        // INTERCONNECTION HELPERS
        // ═══════════════════════════════════════════════════════════════
        
        // Clean up old notes from recent memory
        function cleanRecentNotes() {
            const now = Date.now();
            recentNotes = recentNotes.filter(n => now - n.time < RECENT_NOTES_WINDOW);
        }
        
        // Record a note that was just played
        function recordNote(note, instrument) {
            cleanRecentNotes();
            recentNotes.push({ note, instrument, time: Date.now() });
            
            // Determine if this is a "question" (unstable) or "answer" (stable) ending
            // Unstable intervals from root: 2nds (1,2), 4ths (5), 7ths (10,11)
            const intervalFromRoot = note % 12;
            const unstableIntervals = [1, 2, 5, 6, 10, 11]; // minor 2nd, major 2nd, 4th, tritone, 7ths
            const isQuestion = unstableIntervals.includes(intervalFromRoot);
            
            lastPhraseEnding = { note, instrument, isQuestion };
            
            // Track which group just played
            if (antiphonalPairs.groupA.includes(instrument)) {
                lastPlayingGroup = 'A';
                groupPlayTime = Date.now();
            } else if (antiphonalPairs.groupB.includes(instrument)) {
                lastPlayingGroup = 'B';
                groupPlayTime = Date.now();
            }
        }
        
        // Get which antiphonal group an instrument belongs to
        function getInstrumentGroup(instrument) {
            if (antiphonalPairs.groupA.includes(instrument)) return 'A';
            if (antiphonalPairs.groupB.includes(instrument)) return 'B';
            return 'mediator';
        }
        
        // Check if instrument should respond antiphonally
        function shouldRespondAntiphonally(instrument) {
            if (!lastPlayingGroup || Date.now() - groupPlayTime > 4000) return false;
            
            const myGroup = getInstrumentGroup(instrument);
            
            // Mediator (rhodes) can respond to either group
            if (myGroup === 'mediator') {
                return Math.random() < interconnectChances.antiphonalResponse * 0.5;
            }
            
            // Opposite group responds
            if ((lastPlayingGroup === 'A' && myGroup === 'B') ||
                (lastPlayingGroup === 'B' && myGroup === 'A')) {
                return Math.random() < interconnectChances.antiphonalResponse;
            }
            
            return false;
        }
        
        // ═══════════════════════════════════════════════════════════════
        // ORCHESTRAL SECTION COORDINATION
        // ═══════════════════════════════════════════════════════════════
        
        // Get the section an instrument belongs to
        function getInstrumentSection(instrument) {
            return instrumentToSection[instrument] || null;
        }
        
        // Check if instrument is a section leader
        function isSectionLeader(instrument) {
            const sectionName = getInstrumentSection(instrument);
            if (!sectionName) return false;
            return orchestralSections[sectionName]?.leader === instrument;
        }
        
        // Record section activity when a note is played
        function recordSectionActivity(instrument, note) {
            const sectionName = getInstrumentSection(instrument);
            if (!sectionName || !sectionActivity[sectionName]) return;
            
            const now = Date.now();
            sectionActivity[sectionName].lastPlay = now;
            
            // Add to active instruments if not already there
            if (!sectionActivity[sectionName].activeInstruments.includes(instrument)) {
                sectionActivity[sectionName].activeInstruments.push(instrument);
            }
            
            // If this is the section leader, cue the section
            if (isSectionLeader(instrument)) {
                const section = orchestralSections[sectionName];
                sectionCues[sectionName] = {
                    note: note,
                    time: now,
                    leader: instrument,
                    cohesion: section.cohesion
                };
                log('decision', `§ ${sectionName.toUpperCase()} cued by ${instrument}`);
            }
            
            // Clean up inactive instruments after 5 seconds
            setTimeout(() => {
                const idx = sectionActivity[sectionName].activeInstruments.indexOf(instrument);
                if (idx > -1) {
                    sectionActivity[sectionName].activeInstruments.splice(idx, 1);
                }
            }, 5000);
        }
        
        // Check if this instrument should follow its section's cue
        function shouldFollowSectionCue(instrument, availableNotes) {
            const sectionName = getInstrumentSection(instrument);
            if (!sectionName) return null;
            
            const cue = sectionCues[sectionName];
            if (!cue) return null;
            
            // Don't follow your own cue
            if (cue.leader === instrument) return null;
            
            // Cue expires after 4 seconds
            const age = Date.now() - cue.time;
            if (age > 4000) {
                delete sectionCues[sectionName];
                return null;
            }
            
            // Cohesion determines chance of following
            // Higher cohesion = tighter section playing
            const followChance = cue.cohesion * (1 - age / 4000); // Decreases over time
            
            if (Math.random() < followChance) {
                // Find a note that harmonizes with the cue
                const cueNote = cue.note;
                const harmonyIntervals = [0, 3, 4, 7, 12]; // unison, 3rd, 5th, octave
                const harmonyOffset = randomChoice(harmonyIntervals);
                const targetNote = cueNote + harmonyOffset;
                
                // Find closest available note
                const followNote = findNearestChordTone(targetNote, availableNotes);
                if (followNote) {
                    streamLog(instrument, 'effect', `§ follow`);
                    return followNote;
                }
            }
            
            return null;
        }
        
        // Check if another section is playing and this section should respond
        function shouldSectionRespond(instrument) {
            const mySectionName = getInstrumentSection(instrument);
            if (!mySectionName) return null;
            
            const now = Date.now();
            const mySection = orchestralSections[mySectionName];
            
            // Look for recently active sections that might trigger a response
            for (const [sectionName, activity] of Object.entries(sectionActivity)) {
                if (sectionName === mySectionName) continue;
                
                const timeSince = now - activity.lastPlay;
                
                // Respond within 2-6 seconds of another section playing
                if (timeSince > 1500 && timeSince < 6000) {
                    // Different section roles have different response patterns
                    const otherSection = orchestralSections[sectionName];
                    let responseChance = 0.25;
                    
                    // Strings respond to woodwind melodies
                    if (mySection.role === 'foundation' && otherSection?.role === 'melody') {
                        responseChance = 0.45;
                    }
                    // Brass responds to build climaxes
                    if (mySection.role === 'power' && activity.activeInstruments.length >= 2) {
                        responseChance = 0.35;
                    }
                    // Keys add color to any section
                    if (mySection.role === 'color') {
                        responseChance = 0.3;
                    }
                    
                    if (Math.random() < responseChance) {
                        log('decision', `§ ${mySectionName} responding to ${sectionName}`);
                        return sectionName;
                    }
                }
            }
            
            return null;
        }
        
        // Get a coordinated note based on section activity
        function getSectionCoordinatedNote(instrument, availableNotes) {
            // First check if we should follow our own section's cue
            const followNote = shouldFollowSectionCue(instrument, availableNotes);
            if (followNote) return followNote;
            
            // Then check if we're responding to another section
            const respondingTo = shouldSectionRespond(instrument);
            if (respondingTo && sectionActivity[respondingTo]) {
                // Get recent notes from that section and harmonize
                const otherActivity = sectionActivity[respondingTo];
                const recentSectionNotes = recentNotes.filter(n => 
                    getInstrumentSection(n.instrument) === respondingTo &&
                    Date.now() - n.time < 4000
                );
                
                if (recentSectionNotes.length > 0) {
                    const targetNote = recentSectionNotes[recentSectionNotes.length - 1].note;
                    const harmonyIntervals = [0, 4, 7, 12, -12]; // unison, 3rd, 5th, octave up/down
                    const harmonyOffset = randomChoice(harmonyIntervals);
                    const responseNote = findNearestChordTone(targetNote + harmonyOffset, availableNotes);
                    
                    if (responseNote) {
                        streamLog(instrument, 'effect', `§→${respondingTo.slice(0,3)}`);
                        return responseNote;
                    }
                }
            }
            
            return null;
        }
        
        // Get a unison or harmony note based on recent activity
        function getInfluencedNote(instrument, availableNotes) {
            cleanRecentNotes();
            if (recentNotes.length === 0 || availableNotes.length === 0) return null;
            
            const myPan = channelEffects[instrument]?.pan || 0;
            
            // Filter recent notes by proximity (pan position)
            const nearbyNotes = recentNotes.filter(n => {
                const theirPan = channelEffects[n.instrument]?.pan || 0;
                const distance = Math.abs(myPan - theirPan);
                // Closer pan = higher chance of influence
                return distance < 1.2; // Within reasonable stereo distance
            });
            
            const notesToConsider = nearbyNotes.length > 0 ? nearbyNotes : recentNotes;
            const recentNote = notesToConsider[notesToConsider.length - 1];
            
            // Proximity influence - closer instruments influence more
            if (nearbyNotes.length > 0) {
                const theirPan = channelEffects[recentNote.instrument]?.pan || 0;
                const proximity = 1 - Math.abs(myPan - theirPan) / 2;
                
                if (Math.random() < interconnectChances.proximityInfluence * proximity) {
                    streamLog(instrument, 'decision', `~proximity~`);
                }
            }
            
            // Chance of exact unison
            if (Math.random() < interconnectChances.unison) {
                // Find the same note or closest octave in available notes
                const targetNote = recentNote.note;
                const octaveMatches = availableNotes.filter(n => n % 12 === targetNote % 12);
                if (octaveMatches.length > 0) {
                    const unison = randomChoice(octaveMatches);
                    streamLog(instrument, 'effect', `⇄ unison`);
                    log('decision', `${instrument}: Unison with ${recentNote.instrument} on ${midiToNoteName(unison)}`);
                    return unison;
                }
            }
            
            // Chance of harmony (3rd or 5th)
            if (Math.random() < interconnectChances.sympathyHarmony) {
                const targetNote = recentNote.note;
                const harmonyIntervals = [3, 4, 7]; // minor 3rd, major 3rd, 5th
                const harmonyOffset = randomChoice(harmonyIntervals);
                const harmonyNote = targetNote + harmonyOffset;
                
                // Find closest available note to the harmony
                const closest = findNearestChordTone(harmonyNote, availableNotes);
                if (Math.abs(closest - harmonyNote) <= 2) {
                    streamLog(instrument, 'effect', `⇄ harmony`);
                    log('decision', `${instrument}: Harmony with ${recentNote.instrument}`);
                    return closest;
                }
            }
            
            return null;
        }
        
        // Get an "answer" note if the last phrase was a "question"
        function getAnswerNote(instrument, availableNotes) {
            if (!lastPhraseEnding.isQuestion) return null;
            if (lastPhraseEnding.instrument === instrument) return null;
            if (Date.now() - groupPlayTime > 5000) return null;
            
            if (Math.random() < interconnectChances.questionAnswer) {
                // Answer with a stable note (root, 3rd, or 5th of current chord)
                const stableIntervals = [0, 4, 7]; // root, major 3rd, 5th
                const rootMidi = 36 + globalRoot;
                
                // Find stable notes in available range
                const stableNotes = availableNotes.filter(n => {
                    const interval = (n - rootMidi) % 12;
                    return stableIntervals.includes(interval) || stableIntervals.includes((interval + 12) % 12);
                });
                
                if (stableNotes.length > 0) {
                    // Prefer notes close to the question note for smooth resolution
                    const questionNote = lastPhraseEnding.note;
                    const answer = findNearestChordTone(questionNote, stableNotes);
                    streamLog(instrument, 'effect', `→ answer`);
                    log('decision', `${instrument}: Answering ${lastPhraseEnding.instrument}'s question`);
                    lastPhraseEnding.isQuestion = false; // Question has been answered
                    return answer;
                }
            }
            
            return null;
        }
        
        // Record a note to an instrument's melody memory
        function recordToMelody(instrument, note) {
            if (!recentMelodies[instrument]) {
                recentMelodies[instrument] = [];
            }
            recentMelodies[instrument].push({ note, time: Date.now() });
            if (recentMelodies[instrument].length > MELODY_MEMORY) {
                recentMelodies[instrument].shift();
            }
        }
        
        // Get retrograde (backwards) version of another instrument's melody
        function getRetrogradeNote(instrument, availableNotes) {
            // Find another instrument with melody memory
            const otherInstruments = Object.keys(recentMelodies).filter(i => 
                i !== instrument && recentMelodies[i].length >= 3
            );
            
            if (otherInstruments.length === 0) return null;
            if (Math.random() > interconnectChances.retrograde) return null;
            
            const sourceInstrument = randomChoice(otherInstruments);
            const sourceMelody = recentMelodies[sourceInstrument];
            
            // Play the melody backwards
            const reversedIndex = sourceMelody.length - 1 - (Date.now() % sourceMelody.length);
            const targetNote = sourceMelody[Math.max(0, reversedIndex)].note;
            
            // Find closest available note
            const closest = findNearestChordTone(targetNote, availableNotes);
            if (closest && Math.abs(closest - targetNote) <= 7) {
                streamLog(instrument, 'effect', `↩ retro`);
                log('decision', `${instrument}: Retrograde from ${sourceInstrument}`);
                return closest;
            }
            return null;
        }
        
        // Get inverted version of another instrument's melody
        function getInversionNote(instrument, availableNotes) {
            // Find another instrument with melody memory
            const otherInstruments = Object.keys(recentMelodies).filter(i => 
                i !== instrument && recentMelodies[i].length >= 3
            );
            
            if (otherInstruments.length === 0) return null;
            if (Math.random() > interconnectChances.inversion) return null;
            
            const sourceInstrument = randomChoice(otherInstruments);
            const sourceMelody = recentMelodies[sourceInstrument];
            
            // Get the most recent interval from source
            if (sourceMelody.length < 2) return null;
            
            const lastNote = sourceMelody[sourceMelody.length - 1].note;
            const prevNote = sourceMelody[sourceMelody.length - 2].note;
            const interval = lastNote - prevNote;
            
            // Invert: if source went up 3, we go down 3 from the axis
            const axisNote = availableNotes[Math.floor(availableNotes.length / 2)];
            const invertedNote = axisNote - interval;
            
            // Find closest available note
            const closest = findNearestChordTone(invertedNote, availableNotes);
            if (closest && Math.abs(closest - invertedNote) <= 5) {
                streamLog(instrument, 'effect', `↕ invert`);
                log('decision', `${instrument}: Inversion from ${sourceInstrument}`);
                return closest;
            }
            return null;
        }
        
        // Get inverted retrograde (backwards AND inverted) - rare contrapuntal technique
        function getInvertedRetrogradeNote(instrument, availableNotes) {
            const otherInstruments = Object.keys(recentMelodies).filter(i => 
                i !== instrument && recentMelodies[i].length >= 4
            );
            
            if (otherInstruments.length === 0) return null;
            if (Math.random() > interconnectChances.invertedRetrograde) return null;
            
            const sourceInstrument = randomChoice(otherInstruments);
            const sourceMelody = recentMelodies[sourceInstrument];
            
            // Get a note from the reversed melody
            const reversedIndex = sourceMelody.length - 1 - (Date.now() % sourceMelody.length);
            const retroNote = sourceMelody[Math.max(0, reversedIndex)].note;
            
            // Then invert around the axis
            const axisNote = availableNotes[Math.floor(availableNotes.length / 2)];
            const invertedRetroNote = axisNote * 2 - retroNote;
            
            // Find closest available note
            const closest = findNearestChordTone(invertedRetroNote, availableNotes);
            if (closest && Math.abs(closest - invertedRetroNote) <= 7) {
                streamLog(instrument, 'effect', `⤾ inv-retro`);
                log('decision', `${instrument}: Inverted Retrograde from ${sourceInstrument}`);
                return closest;
            }
            return null;
        }

        // ═══════════════════════════════════════════════════════════════
        // KEY MODULATION SYSTEM - Complementary key changes
        // ═══════════════════════════════════════════════════════════════
        
        let modulationTimeout = null;
        
        // Complementary root relationships (in semitones from current root)
        const COMPLEMENTARY_ROOTS = [
            0,   // Same root (Major/Minor toggle only)
            5,   // Perfect 4th up (subdominant)
            7,   // Perfect 5th up (dominant)
            -3,  // Minor 3rd down (relative minor/major)
            3,   // Minor 3rd up
            -2,  // Whole step down
            2,   // Whole step up
        ];
        
        function startKeyModulation() {
            scheduleModulation();
            log('system', '🎵 Key modulation system active (~3min cycles)');
        }
        
        function scheduleModulation() {
            // Schedule next possible modulation in 2.5-4 minutes
            const delay = 150000 + Math.random() * 90000; // 2.5-4 min
            
            modulationTimeout = setTimeout(() => {
                if (!isPlaying) return;
                
                // 40% chance to actually modulate when scheduled
                if (Math.random() < 0.4) {
                    performModulation();
                }
                
                scheduleModulation();
            }, delay);
        }
        
        function performModulation() {
            const oldRoot = globalRoot;
            const oldScale = globalScale;
            
            // Decide: change root, change quality (Major/Minor), or both
            const modulationType = Math.random();
            
            let newRoot = globalRoot;
            let newScale = globalScale;
            
            if (modulationType < 0.4) {
                // Toggle Major/Minor (40%)
                newScale = globalScale === 'Major' ? 'Minor' : 'Major';
            } else if (modulationType < 0.7) {
                // Change root only (30%)
                const rootShift = randomChoice(COMPLEMENTARY_ROOTS);
                newRoot = (globalRoot + rootShift + 12) % 12;
            } else {
                // Change both (30%)
                newScale = globalScale === 'Major' ? 'Minor' : 'Major';
                const rootShift = randomChoice(COMPLEMENTARY_ROOTS);
                newRoot = (globalRoot + rootShift + 12) % 12;
            }
            
            // Don't modulate to the same key
            if (newRoot === oldRoot && newScale === oldScale) {
                return;
            }
            
            // Perform the modulation
            globalRoot = newRoot;
            globalScale = newScale;
            globalScaleIntervals = SCALES[newScale];
            
            // Update chord notes for new key
            currentChordNotes = getChordNotes(currentChord);
            
            // Update synths
            if (synths.length > 0) {
                synths.forEach(synth => {
                    if (synth.config.isMelody) {
                        refreshMotifForInstrument(synth.config.synthType, synth.config);
                        return;
                    }
                    synth.config.notes = currentChordNotes.filter(n => 
                        n >= synth.config.range[0] && n <= synth.config.range[1]
                    );
                });
            }
            
            updateDisplay();
            
            log('modulation', `═══ KEY CHANGE: ${NOTE_NAMES[oldRoot]} ${oldScale} → ${NOTE_NAMES[newRoot]} ${newScale} ═══`);
            streamLog('system', 'effect', `🎵 ${NOTE_NAMES[newRoot]} ${newScale}`);
        }
        
        function stopKeyModulation() {
            if (modulationTimeout) {
                clearTimeout(modulationTimeout);
                modulationTimeout = null;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // REVERB - Enhanced for Disasterpeace-style vast spaces
        // ═══════════════════════════════════════════════════════════════
        
        function createReverbIR(duration = 4, decay = 3) {
            // Longer, lusher reverb with high-frequency damping
            const length = audioCtx.sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                
                // Pre-delay (slight gap before reverb starts)
                const preDelaySamples = Math.floor(audioCtx.sampleRate * 0.02);
                
                for (let i = 0; i < length; i++) {
                    const t = i / audioCtx.sampleRate;
                    
                    // Main decay envelope with softer initial attack
                    let envelope = Math.pow(1 - t / duration, decay);
                    
                    // Add early reflections (discrete echoes in first 100ms)
                    let earlyReflections = 0;
                    if (t < 0.1) {
                        const reflectionTimes = [0.012, 0.024, 0.035, 0.05, 0.072, 0.09];
                        for (const rt of reflectionTimes) {
                            if (Math.abs(t - rt) < 0.002) {
                                earlyReflections += (Math.random() * 2 - 1) * 0.3;
                            }
                        }
                    }
                    
                    // Pre-delay gap
                    if (i < preDelaySamples) {
                        channelData[i] = 0;
                    } else {
                        // Diffuse late reverb with high-frequency damping
                        const noise = Math.random() * 2 - 1;
                        
                        // Simulate high-frequency absorption over time
                        const hfDamping = Math.exp(-t * 3); // HF decays faster
                        const modulatedNoise = noise * (0.3 + 0.7 * hfDamping);
                        
                        channelData[i] = (modulatedNoise * envelope + earlyReflections) * 
                            (0.8 + 0.2 * Math.sin(t * 0.5)); // Subtle modulation for shimmer
                    }
                }
            }
            return impulse;
        }
        
        // Create shimmer reverb (pitch-shifted reverb tail for ethereal effect)
        function createShimmerReverb(audioCtx, masterGain) {
            // This creates a feedback loop with pitch shifting for that "infinite" shimmer
            // Note: Real shimmer uses granular pitch shifting, this is a simplified version
            const convolver = audioCtx.createConvolver();
            convolver.buffer = createReverbIR(6, 2.5); // Longer decay
            
            const shimmerGain = audioCtx.createGain();
            shimmerGain.gain.value = 0.15;
            
            const shimmerFilter = audioCtx.createBiquadFilter();
            shimmerFilter.type = 'highpass';
            shimmerFilter.frequency.value = 800; // Only shimmer the highs
            
            convolver.connect(shimmerFilter);
            shimmerFilter.connect(shimmerGain);
            shimmerGain.connect(masterGain);
            
            return { input: convolver, output: shimmerGain };
        }

        // ═══════════════════════════════════════════════════════════════
        // SYNTH CLASS
        // ═══════════════════════════════════════════════════════════════
        
        class AmbientSynth {
            constructor(audioCtx, masterGain, index, config) {
                this.audioCtx = audioCtx;
                this.masterGain = masterGain;
                this.index = index;
                this.config = config;
                this.noteIndex = 0;
                this.loopTimeout = null;
                
                const fx = channelEffects[config.synthType];
                
                // Per-channel 3-band EQ (vintage amp style)
                // Low shelf ~100Hz
                this.eqLow = audioCtx.createBiquadFilter();
                this.eqLow.type = 'lowshelf';
                this.eqLow.frequency.value = 100;
                this.eqLow.gain.value = fx.eqLow;
                
                // Mid peaking ~1kHz
                this.eqMid = audioCtx.createBiquadFilter();
                this.eqMid.type = 'peaking';
                this.eqMid.frequency.value = 1000;
                this.eqMid.Q.value = 0.7;
                this.eqMid.gain.value = fx.eqMid;
                
                // High shelf ~4kHz
                this.eqHigh = audioCtx.createBiquadFilter();
                this.eqHigh.type = 'highshelf';
                this.eqHigh.frequency.value = 4000;
                this.eqHigh.gain.value = fx.eqHigh;
                
                // Chain EQ: low -> mid -> high
                this.eqLow.connect(this.eqMid);
                this.eqMid.connect(this.eqHigh);
                
                // Per-channel delay chain
                this.delayNode = audioCtx.createDelay(2.0);
                this.delayNode.delayTime.value = fx.delayTime;
                this.delayFeedback = audioCtx.createGain();
                this.delayFeedback.gain.value = fx.delayFeedback;
                this.delaySend = audioCtx.createGain();
                this.delaySend.gain.value = fx.delayAmount;
                
                // Delay routing
                this.delaySend.connect(this.delayNode);
                this.delayNode.connect(this.delayFeedback);
                this.delayFeedback.connect(this.delayNode);
                this.delayNode.connect(dryGain); // Delay output to master
                
                // Per-channel reverb chain
                this.reverbNode = audioCtx.createConvolver();
                this.reverbNode.buffer = createReverbIR(fx.reverbDecay, 2.5);
                this.reverbToneFilter = audioCtx.createBiquadFilter();
                this.reverbToneFilter.type = 'lowpass';
                this.reverbToneFilter.frequency.value = fx.reverbTone;
                this.reverbSend = audioCtx.createGain();
                this.reverbSend.gain.value = fx.reverbAmount;
                
                // Reverb routing
                this.reverbSend.connect(this.reverbNode);
                this.reverbNode.connect(this.reverbToneFilter);
                this.reverbToneFilter.connect(dryGain); // Reverb output to master
                
                // EQ output connects to master (dry signal goes through EQ chain)
                this.eqHigh.connect(dryGain);
            }
            
            // Update effect parameters (called by ebb function)
            updateEffects() {
                const fx = channelEffects[this.config.synthType];
                const now = this.audioCtx.currentTime;
                
                // EQ parameters
                this.eqLow.gain.linearRampToValueAtTime(fx.eqLow, now + 2);
                this.eqMid.gain.linearRampToValueAtTime(fx.eqMid, now + 2);
                this.eqHigh.gain.linearRampToValueAtTime(fx.eqHigh, now + 2);
                
                // Delay parameters
                this.delayNode.delayTime.linearRampToValueAtTime(fx.delayTime, now + 2);
                this.delayFeedback.gain.linearRampToValueAtTime(fx.delayFeedback, now + 2);
                this.delaySend.gain.linearRampToValueAtTime(fx.delayAmount, now + 2);
                
                // Reverb parameters (can't change convolver buffer live, but can change tone and send)
                this.reverbToneFilter.frequency.linearRampToValueAtTime(fx.reverbTone, now + 2);
                this.reverbSend.gain.linearRampToValueAtTime(fx.reverbAmount, now + 2);
            }

            start() {
                log('system', `${this.config.synthType.toUpperCase()} started`);
                streamLog(this.config.synthType, 'decision', 'INIT');
                updateStreamMode(this.config.synthType, this.config.isMelody);
                this.scheduleNote();
            }

            stop() {
                if (this.loopTimeout) clearTimeout(this.loopTimeout);
            }

            scheduleNote() {
                if (!isPlaying) return;
                
                // ═══ TEMPO: Apply global BPM multiplier to all timing ═══
                const tempoMult = getTempoMultiplier();
                
                // ═══ WEATHER SYSTEM INTEGRATION ═══
                const wx = getWeatherAdjustments(this.config.synthType);

                // Check if instrument is OFF
                if (this.config.isOff) {
                    streamLog(this.config.synthType, 'silence', '■ off');
                    const nextTime = this.config.loopLength * 1000 * tempoMult;
                    this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                    return;
                }
                
                const inst = this.config.synthType;
                const availableNotes = this.config.isMelody ? getMotifNotes(inst, this.config) : this.config.notes;
                
                // ═══ BREATH CYCLE: Check if we should be quiet ═══
                const breathMod = getBreathModifier();
                if (breathMod < 0.3 && Math.random() > breathMod) {
                    streamLog(inst, 'silence', '○ breath');
                    const nextTime = this.config.loopLength * 1000 * tempoMult;
                    this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                    return;
                }
                
                // ═══ ACTIVITY AWARENESS: Pull back if texture too dense ═══
                if (shouldPullBack(inst)) {
                    streamLog(inst, 'silence', '◇ listening');
                    const nextTime = this.config.loopLength * 1000 * tempoMult;
                    this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                    return;
                }
                
                // ═══ CONVERGENCE: Everyone plays together ═══
                if (shouldPlayConvergence(inst)) {
                    const convNote = getConvergenceNote(inst, availableNotes);
                    if (convNote) {
                        streamLog(inst, 'note', `★ ${midiToNoteName(convNote)}`);
                        this.playNote(convNote);
                        recordActivity(inst, 'convergence');
                        recordSectionActivity(inst, convNote);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // ═══ DISASTERPEACE PULSE BASS ═══
                // Bass instruments play rhythmic ostinato patterns
                const bassInstruments = ['bass', 'lowbrass', 'bassoon'];
                if (bassInstruments.includes(inst) && Math.random() < 0.15) {
                    const tempo = parseInt(document.getElementById('bpmSlider')?.value || 60);
                    const beatMs = 60000 / tempo;
                    
                    // Get root and fifth from current harmony
                    const root = globalRoot + (motifHarmony.chordProgression.length > 0 
                        ? motifHarmony.chordProgression[motifHarmony.currentChordIndex].root 
                        : 0);
                    const fifth = root + 7;
                    
                    // Create pulse pattern (root-fifth or root-root-fifth-root)
                    const patterns = [
                        [root, fifth],
                        [root, root, fifth, root],
                        [root, root + 12, fifth, root],
                        [root, fifth, fifth, root]
                    ];
                    const pattern = randomChoice(patterns);
                    
                    streamLog(inst, 'effect', `◆ pulse`);
                    
                    pattern.forEach((note, i) => {
                        // Find note in available range
                        const noteInRange = findNearestChordTone(note + 36, availableNotes); // Octave 3
                        if (noteInRange) {
                            setTimeout(() => {
                                if (isPlaying) this.playNote(noteInRange);
                            }, i * (beatMs / 2)); // 8th notes
                        }
                    });
                    
                    recordActivity(inst, 'pulse');
                    const nextTime = Math.max(pattern.length * (beatMs / 2), this.config.loopLength * 1000 * tempoMult);
                    this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                    return;
                }
                
                // ═══ HARMONIC PEDAL: Bass instruments sustain root ═══
                if (shouldPlayPedal(inst)) {
                    const pedalInRange = findNearestChordTone(pedalNote, availableNotes);
                    if (pedalInRange && Math.abs(pedalInRange - pedalNote) <= 12) {
                        streamLog(inst, 'note', `♩ pedal`);
                        this.playNote(pedalInRange);
                        recordActivity(inst, 'pedal');
                        recordSectionActivity(inst, pedalInRange);
                        const nextTime = this.config.loopLength * 1000 * tempoMult * 1.5; // Hold pedal longer
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // ═══ PHRASE CADENCE: Resolve at phrase end ═══
                if (isPhraseBoundary() && Math.random() < 0.4) {
                    const cadenceNote = getCadenceNote(inst, availableNotes);
                    if (cadenceNote) {
                        streamLog(inst, 'note', `⌐ ${midiToNoteName(cadenceNote)}`);
                        this.playNote(cadenceNote);
                        recordActivity(inst, 'cadence');
                        recordSectionActivity(inst, cadenceNote);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // ═══ MOTIF ECHO: Respond to recent motif ═══
                if (shouldEchoMotif(inst)) {
                    const variation = getMotifVariation();
                    const echoNote = variation.motif[motifPlaybackIndex % variation.motif.length];
                    const echoInRange = findNearestChordTone(echoNote, availableNotes);
                    if (echoInRange) {
                        streamLog(inst, 'note', `↩ echo`);
                        this.playNote(echoInRange);
                        recordActivity(inst, 'echo');
                        recordSectionActivity(inst, echoInRange);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // ═══ DISASTERPEACE ARPEGGIATOR ═══
                // Chance to play an arpeggio pattern instead of single note
                if (DISASTERPEACE_CONFIG.arpeggiator.enabled && 
                    this.config.isMelody && 
                    centralMotif.length >= 3 &&
                    Math.random() < 0.08) {
                    
                    const arpConfig = DISASTERPEACE_CONFIG.arpeggiator;
                    const pattern = randomChoice(arpConfig.patterns);
                    const division = randomChoice(arpConfig.divisions);
                    const tempo = parseInt(document.getElementById('bpmSlider')?.value || 60);
                    const stepMs = (60000 / tempo) / division * 4; // Convert to ms
                    
                    // Build arpeggio from current motif harmony
                    let arpNotes = [...centralMotif].slice(0, 4);
                    if (pattern === 'down') arpNotes.reverse();
                    else if (pattern === 'updown') arpNotes = [...arpNotes, ...arpNotes.slice(1, -1).reverse()];
                    else if (pattern === 'random') arpNotes.sort(() => Math.random() - 0.5);
                    
                    // Play the arpeggio
                    streamLog(inst, 'effect', `↗ arp ${pattern}`);
                    arpNotes.forEach((note, i) => {
                        const noteInRange = findNearestChordTone(note, availableNotes);
                        if (noteInRange) {
                            setTimeout(() => {
                                if (isPlaying) this.playNote(noteInRange);
                            }, i * stepMs * arpConfig.gateLength);
                        }
                    });
                    
                    recordActivity(inst, 'arpeggio');
                    const totalArpTime = arpNotes.length * stepMs;
                    const nextTime = Math.max(totalArpTime, this.config.loopLength * 1000 * tempoMult);
                    this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                    return;
                }
                
                // Weather: Solitude affects response behavior
                const respondChance = wx.responseChance;

                // ═══ INTERCONNECTION: Check for call-and-response opportunities ═══
                let interconnectedNote = null;
                
                // Check for antiphonal response opportunity (affected by solitude weather)
                if (Math.random() < respondChance && shouldRespondAntiphonally(inst)) {
                    const answerNote = getAnswerNote(inst, availableNotes);
                    const influencedNote = getInfluencedNote(inst, availableNotes);
                    interconnectedNote = answerNote || influencedNote;
                    
                    if (interconnectedNote) {
                        streamLog(inst, 'effect', `← response`);
                        this.playNote(interconnectedNote);
                        recordSectionActivity(inst, interconnectedNote);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // ═══ SECTION COORDINATION: Check if we should follow our section ═══
                const sectionNote = getSectionCoordinatedNote(inst, availableNotes);
                if (sectionNote) {
                    this.playNote(sectionNote);
                    recordSectionActivity(inst, sectionNote);
                    recordToMelody(inst, sectionNote);
                    const nextTime = this.config.loopLength * 1000 * tempoMult;
                    this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                    return;
                }
                
                // ═══ CENTRAL MOTIF: Check if we should play the motif ═══
                if (shouldPlayMotif(inst)) {
                    const motifNote = getNextMotifNote(availableNotes);
                    if (motifNote) {
                        // Highlight the note on the stave
                        highlightMotifNote(motifPlaybackIndex > 0 ? motifPlaybackIndex - 1 : centralMotif.length - 1);
                        lastMotifPlayTime = Date.now();
                        
                        streamLog(inst, 'note', `♪ ${midiToNoteName(motifNote)}`);
                        this.playNote(motifNote);
                        recordSectionActivity(inst, motifNote);
                        recordToMelody(inst, motifNote);
                        recordMotifPlay(inst);  // Track for echo system
                        recordActivity(inst, 'motif');
                        
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // ═══ MOTIF SUPPORT: Other sections play harmony ═══
                const mySection = getInstrumentSection(inst);
                if (mySection && mySection !== currentMelodySection && Math.random() < 0.2) {
                    const supportNote = getMotifSupportNote(inst, availableNotes);
                    if (supportNote) {
                        streamLog(inst, 'effect', `♪ support`);
                        this.playNote(supportNote);
                        recordSectionActivity(inst, supportNote);
                        recordToMelody(inst, supportNote);
                        
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // Check for question/answer opportunity
                if (Math.random() < respondChance) {
                    const answerNote = getAnswerNote(inst, availableNotes);
                    if (answerNote) {
                        this.playNote(answerNote);
                        recordToMelody(inst, answerNote);
                        recordSectionActivity(inst, answerNote);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // Check for retrograde response opportunity
                if (Math.random() < respondChance) {
                    const retroNote = getRetrogradeNote(inst, availableNotes);
                    if (retroNote) {
                        this.playNote(retroNote);
                        recordToMelody(inst, retroNote);
                        recordSectionActivity(inst, retroNote);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // Check for inversion response opportunity
                if (Math.random() < respondChance) {
                    const invertNote = getInversionNote(inst, availableNotes);
                    if (invertNote) {
                        this.playNote(invertNote);
                        recordToMelody(inst, invertNote);
                        recordSectionActivity(inst, invertNote);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                
                // Check for inverted retrograde response opportunity (rare)
                if (Math.random() < respondChance * 0.5) {
                    const invRetroNote = getInvertedRetrogradeNote(inst, availableNotes);
                    if (invRetroNote) {
                        this.playNote(invRetroNote);
                        recordToMelody(inst, invRetroNote);
                        recordSectionActivity(inst, invRetroNote);
                        const nextTime = this.config.loopLength * 1000 * tempoMult;
                        this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
                        return;
                    }
                }
                // ═══ END INTERCONNECTION ═══

                // Weather: Density affects silence chance
                const baseSilence = this.config.silenceChance || 0;
                const weatherSilence = baseSilence * wx.silenceMultiplier;
                let effectiveSilenceChance = Math.min(0.9, weatherSilence);
                
                // ═══ ACTIVITY AWARENESS: Lean in when sparse ═══
                if (shouldLeanIn(inst)) {
                    effectiveSilenceChance *= 0.55; // Less likely to stay silent
                    streamLog(inst, 'effect', `◆ leaning in`);
                }
                
                if (Math.random() >= effectiveSilenceChance) {
                    const influencedNote = getInfluencedNote(inst, availableNotes);
                    
                    // Weather: Density affects single note vs chord
                    const forceSingleNote = Math.random() < wx.singleNoteChance;
                    
                    if (this.config.isMelody && availableNotes.length > 1 && !forceSingleNote) {
                        // Melody instruments play sequential notes (like a melody line)
                        const maxMelodyNotes = Math.min(availableNotes.length, 2 + Math.floor(Math.random() * 2));
                        log('decision', `${this.config.synthType}: Playing melody (${maxMelodyNotes} notes)`);
                        streamLog(this.config.synthType, 'decision', `melody(${maxMelodyNotes})`);
                        
                        const notesToPlay = [...availableNotes].slice(0, maxMelodyNotes);
                        if (influencedNote && !notesToPlay.includes(influencedNote)) {
                            notesToPlay[0] = influencedNote;
                        }
                        
                        notesToPlay.forEach((note, i) => {
                            setTimeout(() => {
                                if (isPlaying && !this.config.isOff) {
                                    this.playNote(note);
                                    recordToMelody(inst, note);
                                    recordSectionActivity(inst, note);
                                    recordActivity(inst, 'melody');
                                }
                            }, i * (this.config.melodySpeed || 0.5) * 1000 * tempoMult);
                        });
                    } else {
                        // Single instrument = single note (chords are formed by multiple instruments together)
                        const singleNote = influencedNote || randomChoice(availableNotes);
                        streamLog(this.config.synthType, 'note', `♪`);
                        this.playNote(singleNote);
                        recordToMelody(inst, singleNote);
                        recordSectionActivity(inst, singleNote);
                        recordActivity(inst, 'note');
                    }
                } else {
                    // Weather affects how we describe silence
                    if (weather.density < 0.3) {
                        streamLog(this.config.synthType, 'silence', '     ');  // Deep silence - just space
                    } else {
                        streamLog(this.config.synthType, 'silence', '· · ·');
                    }
                }

                const nextTime = this.config.loopLength * 1000 * tempoMult;
                this.loopTimeout = setTimeout(() => this.scheduleNote(), nextTime);
            }

            playNote(midiNote, isOctaveDouble = false) {
                const now = this.audioCtx.currentTime;
                
                // Get instrument capabilities
                const capabilities = INSTRUMENT_CAPABILITIES[this.config.synthType] || {};
                const canSwell = !!capabilities.canSwell;
                const canVibrato = !!capabilities.canVibrato;
                const canTremolo = !!capabilities.canTremolo;
                
                // Get weather for this channel first
                const wx = getWeatherAdjustments(this.config.synthType);
                
                // === OCTAVE DOWN CHANCE (weather.depth controls this) ===
                if (!isOctaveDouble && Math.random() < wx.octaveDownChance) {
                    const octaveDownNote = midiNote - 12;
                    if (octaveDownNote >= 24) { // Don't go too low
                        midiNote = octaveDownNote;
                        streamLog(this.config.synthType, 'effect', `8vb↓`);
                    }
                }
                
                // === GLISSANDO / PORTAMENTO (for instruments that can naturally glide) ===
                const inst = this.config.synthType;
                const glideSettings = glissandoInstruments[inst];
                let useGlide = false;
                let glideFromNote = null;
                let glideTime = 0;
                
                if (glideSettings && !isOctaveDouble && lastNoteByInstrument[inst]) {
                    const lastNote = lastNoteByInstrument[inst];
                    const interval = Math.abs(midiNote - lastNote);
                    
                    // Only glide if interval is reasonable and random chance passes
                    if (interval > 0 && interval <= glideSettings.maxInterval && Math.random() < glideSettings.chance) {
                        useGlide = true;
                        glideFromNote = lastNote;
                        glideTime = glideSettings.speed * (0.8 + Math.random() * 0.4); // Vary glide speed
                    }
                }
                
                // Track this note for next glide opportunity
                if (!isOctaveDouble) {
                    lastNoteByInstrument[inst] = midiNote;
                }
                
                const freq = midiToFreq(midiNote);
                const startFreq = useGlide ? midiToFreq(glideFromNote) : freq;
                
                // Record this note for interconnection system
                if (!isOctaveDouble) recordNote(midiNote, this.config.synthType);
                
                // Debug: verify audio context state
                if (this.audioCtx.state !== 'running') {
                    console.warn('AudioContext not running:', this.audioCtx.state);
                    this.audioCtx.resume();
                }
                
                // Weather: Breath affects attack time
                const baseAttack = Math.max(0.01, this.config.attack);
                const attack = baseAttack * wx.attackMultiplier;
                
                // Weather: Decay affects release time
                const decay = Math.max(0.1, this.config.decay);
                const baseRelease = Math.max(0.5, this.config.release);
                const release = baseRelease * wx.releaseMultiplier;
                
                const minDuration = attack + decay + 1 + release;
                const noteDuration = Math.max(minDuration, Math.min(this.config.loopLength * 1.5, attack + decay + 2 + release));

                // ═══ OCTAVE DOUBLING (Disasterpeace style) ═══
                if (!isOctaveDouble && this.config.isMelody && Math.random() < disasterpeaceChances.octaveDouble) {
                    const octaveShift = Math.random() < disasterpeaceChances.octaveAbove ? 12 : -12;
                    const doubleNote = midiNote + octaveShift;
                    if (doubleNote >= 24 && doubleNote <= 96) {
                        setTimeout(() => {
                            this.playNote(doubleNote, true);
                        }, 5 + Math.random() * 20);
                        streamLog(this.config.synthType, 'effect', `8va${octaveShift > 0 ? '↑' : '↓'}`);
                    }
                }

                log('note', `♪ ${midiToNoteName(midiNote)} (${freq.toFixed(1)}Hz) via ${this.config.synthType}`);
                
                // Stream log for instrument column
                if (!isOctaveDouble) {
                    if (useGlide) {
                        streamLog(this.config.synthType, 'note', `${midiToNoteName(glideFromNote)}~${midiToNoteName(midiNote)}`, `glide`);
                    } else {
                        streamLog(this.config.synthType, 'note', midiToNoteName(midiNote), `${freq.toFixed(0)}Hz`);
                    }
                }

                // ═══ REALISTIC ADDITIVE SYNTHESIS ═══
                // Use harmonic profiles for instrument-specific timbres
                const profile = HARMONIC_PROFILES[this.config.synthType];
                const oscillators = [];
                const cleanupNodes = [];
                
                if (profile && profile.harmonics && profile.harmonics.length > 0) {
                    // Create oscillators for each harmonic partial
                    const numHarmonics = Math.min(profile.harmonics.length, 6); // Limit for performance
                    const baseDetune = profile.detuneSpread || 5;
                    const numOscs = Math.min(profile.oscillators || 2, 2); // Limit oscillators per harmonic
                    
                    for (let h = 0; h < numHarmonics; h++) {
                        const harmonicAmp = profile.harmonics[h];
                        if (harmonicAmp < 0.03) continue; // Skip very quiet harmonics
                        
                        const harmonicNum = h + 1;
                        let harmonicFreq = freq * harmonicNum;
                        
                        // Apply inharmonicity for piano/bells
                        if (profile.inharmonicity) {
                            harmonicFreq *= (1 + profile.inharmonicity * harmonicNum * harmonicNum);
                        }
                        
                        // Create detuned oscillators for each harmonic (chorus effect)
                        for (let o = 0; o < numOscs; o++) {
                            const osc = this.audioCtx.createOscillator();
                            
                            // Use sine waves for additive synthesis (purest harmonics)
                            osc.type = 'sine';
                            
                            // Detune for thickness
                            const detuneAmount = (o - (numOscs - 1) / 2) * baseDetune;
                            const weatherDetune = detuneAmount + (Math.random() - 0.5) * (wx.detuneAmount * 0.3);
                            
                            if (useGlide) {
                                const startHarmonicFreq = startFreq * harmonicNum;
                                osc.frequency.setValueAtTime(startHarmonicFreq, now);
                                osc.frequency.exponentialRampToValueAtTime(harmonicFreq, now + glideTime);
                            } else {
                                osc.frequency.setValueAtTime(harmonicFreq, now);
                            }
                            osc.detune.setValueAtTime(weatherDetune, now);
                            
                            // Add tape wobble (Disasterpeace style)
                            if (DISASTERPEACE_CONFIG.tapeWobble.enabled && Math.random() < 0.3) {
                                const wobbleLfo = this.audioCtx.createOscillator();
                                const wobbleGain = this.audioCtx.createGain();
                                wobbleLfo.frequency.value = DISASTERPEACE_CONFIG.tapeWobble.rate * 
                                    (1 + (Math.random() - 0.5) * DISASTERPEACE_CONFIG.tapeWobble.randomness);
                                wobbleGain.gain.value = DISASTERPEACE_CONFIG.tapeWobble.depth;
                                wobbleLfo.connect(wobbleGain);
                                wobbleGain.connect(osc.detune);
                                wobbleLfo.start(now);
                                osc._wobbleLfo = wobbleLfo;
                                cleanupNodes.push(wobbleLfo, wobbleGain);
                            }
                            
                            // Per-harmonic gain
                            const harmonicGain = this.audioCtx.createGain();
                            const ampWithDetune = harmonicAmp / numOscs;
                            harmonicGain.gain.value = ampWithDetune;
                            osc.connect(harmonicGain);
                            
                            oscillators.push({ osc, gain: harmonicGain, harmonic: harmonicNum });
                            cleanupNodes.push(osc, harmonicGain);
                        }
                    }
                    
                    // Add noise component for attack/texture
                    if (profile.noiseType && profile.noiseAmount > 0) {
                        const noiseDuration = (profile.noiseType === 'breath' || profile.noiseType === 'bow') 
                            ? noteDuration : Math.min(0.5, attack * 2);
                        const noiseSource = createNoiseNode(this.audioCtx, profile.noiseType, noiseDuration);
                        
                        // Filter noise to match instrument character
                        const noiseFilter = this.audioCtx.createBiquadFilter();
                        noiseFilter.type = 'bandpass';
                        noiseFilter.frequency.value = freq * 2;
                        noiseFilter.Q.value = 1;
                        
                        const noiseGain = this.audioCtx.createGain();
                        noiseGain.gain.value = profile.noiseAmount;
                        
                        noiseSource.connect(noiseFilter);
                        noiseFilter.connect(noiseGain);
                        
                        oscillators.push({ noise: noiseSource, gain: noiseGain });
                        cleanupNodes.push(noiseSource, noiseFilter, noiseGain);
                    }
                }
                
                // Fallback if no oscillators were created
                if (oscillators.length === 0) {
                    const osc = this.audioCtx.createOscillator();
                    osc.type = this.config.waveform || 'triangle';
                    
                    if (useGlide) {
                        osc.frequency.setValueAtTime(startFreq, now);
                        osc.frequency.exponentialRampToValueAtTime(freq, now + glideTime);
                    } else {
                        osc.frequency.setValueAtTime(freq, now);
                    }
                    
                    const oscGain = this.audioCtx.createGain();
                    oscGain.gain.value = 1;
                    osc.connect(oscGain);
                    
                    oscillators.push({ osc, gain: oscGain });
                    cleanupNodes.push(osc, oscGain);
                }

                // Get current channel effects (all parameters drift)
                const fx = channelEffects[this.config.synthType];
                
                // Weather: Presence affects volume ("The Note You Almost Missed")
                const baseVolume = Math.max(0.05, this.config.volume);
                const weatherVolume = baseVolume * wx.volumeMultiplier;
                
                // ═══ DYNAMIC ARC & BREATH: Apply macro-level dynamics ═══
                const dynamicLevel = getDynamicIntensity();
                const breathMod = getBreathModifier();
                const macroVolume = weatherVolume * (0.5 + dynamicLevel * 0.5) * breathMod;
                
                // Volume scaling based on number of oscillators
                const totalOscillators = oscillators.filter(item => item.osc).length || 1;
                const volumeScale = isOctaveDouble ? 0.4 : (totalOscillators > 1 ? 1 / Math.sqrt(totalOscillators) : 1);

                // Dynamic swell: Eno-style breathing envelope
                const useSwell = canSwell && !isOctaveDouble && Math.random() < disasterpeaceChances.dynamicSwell;
                
                // Weather: Low presence + low breath = "breath entrance" (fade in from nothing)
                const useBreathEntrance = canSwell && !isOctaveDouble && weather.presence < 0.4 && weather.breath < 0.3;
                let breathInTime = 0;
                if (useBreathEntrance) {
                    breathInTime = 3 + Math.random() * 4; // 3-7 seconds fade in
                }
                const envelopeEnd = now + noteDuration + breathInTime;
                const envelopeTail = 0.02;

                // Vibrato: Weather drift affects intensity (apply to oscillators that have .osc)
                oscillators.forEach(item => {
                    if (item.osc && canVibrato && fx.vibratoDepth > 0 && fx.vibratoAmount > 0) {
                        const vibratoLfo = this.audioCtx.createOscillator();
                        const vibratoGain = this.audioCtx.createGain();
                        vibratoLfo.frequency.value = fx.vibratoSpeed;
                        const baseFreq = item.harmonic ? freq * item.harmonic : freq;
                        const vibratoIntensity = baseFreq * fx.vibratoDepth * fx.vibratoAmount * wx.vibratoMultiplier;
                        vibratoGain.gain.value = vibratoIntensity;
                        vibratoLfo.connect(vibratoGain);
                        vibratoGain.connect(item.osc.frequency);
                        vibratoLfo.start(now);
                        vibratoLfo.stop(envelopeEnd + 0.1);
                        cleanupNodes.push(vibratoLfo, vibratoGain);
                    }
                });

                // Envelope - with optional dynamic swell
                const gainNode = this.audioCtx.createGain();
                cleanupNodes.push(gainNode);
                const volume = macroVolume * volumeScale;
                
                if (useBreathEntrance) {
                    // Breath entrance: ultra-slow fade in ("The Note You Almost Missed")
                    gainNode.gain.setValueAtTime(0.0001, now);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.7, now + breathInTime);
                    gainNode.gain.setValueAtTime(volume * 0.7, now + breathInTime + 1);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, envelopeEnd);
                    streamLog(this.config.synthType, 'effect', '~breath~');
                } else if (useSwell) {
                    // Swell envelope: slow rise, peak, slow fall
                    const swellPeak = 0.3 + Math.random() * 0.4; // Peak at 30-70% through note
                    const peakTime = now + (noteDuration * swellPeak);
                    const peakVolume = volume * (1.2 + Math.random() * 0.5); // 20-70% louder at peak
                    
                    gainNode.gain.setValueAtTime(0.001, now);
                    // Slow fade in to peak
                    gainNode.gain.exponentialRampToValueAtTime(peakVolume, peakTime);
                    // Slow fade out
                    gainNode.gain.exponentialRampToValueAtTime(0.001, envelopeEnd);
                    
                    streamLog(this.config.synthType, 'effect', '~swell~');
                } else {
                    // Standard ADSR envelope
                    gainNode.gain.setValueAtTime(0.001, now);
                    gainNode.gain.exponentialRampToValueAtTime(volume, now + attack);
                    
                    const sustainLevel = Math.max(0.001, volume * this.config.sustain);
                    const decayEnd = now + attack + decay;
                    gainNode.gain.exponentialRampToValueAtTime(sustainLevel, decayEnd);
                    
                    // Make sure sustain hold and release don't overlap
                    const sustainEnd = Math.max(decayEnd + 0.1, now + noteDuration - release);
                    gainNode.gain.setValueAtTime(sustainLevel, sustainEnd);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, envelopeEnd);
                }
                gainNode.gain.linearRampToValueAtTime(0, envelopeEnd + envelopeTail);

                // Tremolo: all parameters from channel effects
                let tremoloNode = null;
                if (canTremolo && fx.tremoloDepth > 0 && fx.tremoloAmount > 0) {
                    tremoloNode = this.audioCtx.createGain();
                    const tremoloLfo = this.audioCtx.createOscillator();
                    const tremoloGainMod = this.audioCtx.createGain();
                    tremoloLfo.frequency.value = fx.tremoloSpeed;
                    const effectiveDepth = fx.tremoloDepth * fx.tremoloAmount;
                    tremoloGainMod.gain.value = effectiveDepth;
                    tremoloLfo.connect(tremoloGainMod);
                    tremoloGainMod.connect(tremoloNode.gain);
                    tremoloNode.gain.value = 1 - effectiveDepth / 2;
                    tremoloLfo.start(now);
                    tremoloLfo.stop(envelopeEnd + 0.1);
                    cleanupNodes.push(tremoloNode, tremoloLfo, tremoloGainMod);
                }

                // Filter - use channel's sweeping filter value
                const filter = this.audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                const filterFreq = Math.min(this.config.filterFreq, fx.filterSweep || 4000);
                filter.frequency.setValueAtTime(filterFreq, now);
                filter.Q.setValueAtTime(0.7, now);
                cleanupNodes.push(filter);

                // Panner - use channel pan position with slight random variation
                const panner = this.audioCtx.createStereoPanner();
                const panVariation = (Math.random() - 0.5) * 0.15;
                const finalPan = Math.max(-1, Math.min(1, fx.pan + panVariation));
                panner.pan.setValueAtTime(finalPan, now);
                cleanupNodes.push(panner);
                
                // ═══ FORMANT FILTERING (for realistic timbres) ═══
                let formantMixer = null;
                
                if (profile && profile.formants && profile.formants.length > 0) {
                    // Create parallel formant filters
                    formantMixer = this.audioCtx.createGain();
                    formantMixer.gain.value = 1 / profile.formants.length;
                    cleanupNodes.push(formantMixer);
                    
                    const formantFilters = createFormantFilters(this.audioCtx, profile.formants, profile.formantQ || 5);
                    formantFilters.forEach(f => {
                        filter.connect(f);
                        f.connect(formantMixer);
                        cleanupNodes.push(f);
                    });
                }

                // Connect all oscillators through per-channel effect chains
                oscillators.forEach(item => {
                    // Each item has either {osc, gain} or {noise, gain}
                    if (item.gain) {
                        item.gain.connect(gainNode);
                    }
                });
                
                if (tremoloNode) {
                    gainNode.connect(tremoloNode);
                    tremoloNode.connect(filter);
                } else {
                    gainNode.connect(filter);
                }
                
                // Route through formants or direct to panner
                if (formantMixer) {
                    // Mix formant output with some direct signal for presence
                    const directMix = this.audioCtx.createGain();
                    directMix.gain.value = 0.3;
                    filter.connect(directMix);
                    directMix.connect(panner);
                    formantMixer.connect(panner);
                    cleanupNodes.push(directMix);
                } else {
                    filter.connect(panner);
                }
                
                // ═══ WEATHER: Intimacy affects wet/dry balance ═══
                // "The Room Is Playing" - low intimacy = more reverb, distant
                // "Tenderness at Distance" - sound from another room
                const dryLevel = 0.3 + weather.intimacy * 0.7; // 0.3-1.0
                const reverbBoost = wx.reverbMixMultiplier;
                const delayBoost = wx.delayFeedbackMultiplier;
                
                // Create per-note gain nodes to apply weather adjustments
                const dryOut = this.audioCtx.createGain();
                dryOut.gain.value = dryLevel;
                
                const reverbOut = this.audioCtx.createGain();
                reverbOut.gain.value = reverbBoost;
                
                const delayOut = this.audioCtx.createGain();
                delayOut.gain.value = delayBoost;
                cleanupNodes.push(dryOut, reverbOut, delayOut);
                
                // Weather: Pre-delay for distant notes ("Tenderness at Distance")
                if (wx.preDelay > 0.05) {
                    const preDelayNode = this.audioCtx.createDelay(1.0);
                    preDelayNode.delayTime.value = wx.preDelay;
                    panner.connect(preDelayNode);
                    preDelayNode.connect(dryOut);
                    preDelayNode.connect(reverbOut);
                    preDelayNode.connect(delayOut);
                    cleanupNodes.push(preDelayNode);
                    
                    if (wx.preDelay > 0.2) {
                        streamLog(this.config.synthType, 'effect', `distant`);
                    }
                } else {
                    panner.connect(dryOut);
                    panner.connect(reverbOut);
                    panner.connect(delayOut);
                }
                
                // Route to effect chains
                dryOut.connect(this.eqLow);
                delayOut.connect(this.delaySend);
                reverbOut.connect(this.reverbSend);

                const oscStopTime = envelopeEnd + 0.5;
                let cleaned = false;
                const cleanup = () => {
                    if (cleaned) return;
                    cleaned = true;
                    cleanupNodes.forEach(node => {
                        try {
                            node.disconnect();
                        } catch (e) {}
                    });
                };
                
                const cleanupDelayMs = Math.max(0, (oscStopTime - now + 0.2) * 1000);
                setTimeout(cleanup, cleanupDelayMs);

                // Start and stop all oscillators
                oscillators.forEach(item => {
                    try {
                        if (item.osc) {
                            item.osc.start(now);
                            item.osc.stop(oscStopTime);
                            if (item.osc._wobbleLfo) {
                                item.osc._wobbleLfo.stop(oscStopTime);
                            }
                        } else if (item.noise) {
                            item.noise.start(now);
                            item.noise.stop(oscStopTime);
                        }
                    } catch (e) {
                        console.error('Oscillator error:', e);
                    }
                });
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // SYNTH CONFIG GENERATION
        // ═══════════════════════════════════════════════════════════════
        
        function generateSynthConfig(index, chordNotes, forceType = null) {
            const synthType = forceType || INSTRUMENT_ORDER[index] || 'piano';
            
            const naturalRanges = {
                violins: { low: 48, high: 100 },
                cello: { low: 36, high: 81 },
                bass: { low: 28, high: 67 },
                harp: { low: 24, high: 103 },
                piano: { low: 21, high: 108 },
                guitar: { low: 40, high: 88 },
                celeste: { low: 60, high: 96 },
                rhodes: { low: 40, high: 88 },
                vibraphone: { low: 53, high: 89 },
                whistle: { low: 62, high: 96 },
                flute: { low: 72, high: 108 },
                oboe: { low: 52, high: 91 },
                clarinet: { low: 34, high: 96 },
                bassoon: { low: 34, high: 76 },
                woodwinds: { low: 50, high: 92 },
                horns: { low: 41, high: 84 },
                trumpet: { low: 54, high: 88 },
                lowbrass: { low: 26, high: 77 },
                brass: { low: 40, high: 84 }
            };
            
            const range = naturalRanges[synthType];
            const possibleOctaves = [];
            for (let oct = Math.floor(range.low / 12) * 12; oct <= range.high - 12; oct += 12) {
                if (oct >= range.low - 6 && oct + 12 <= range.high + 6) {
                    possibleOctaves.push(oct);
                }
            }
            const baseOctave = possibleOctaves.length > 0 ? randomChoice(possibleOctaves) : Math.floor((range.low + range.high) / 2);
            
            const scaleNotesInRange = getScaleNotesInRange(range.low, range.high);
            const chordNotesInRange = (chordNotes || []).filter(n => n >= range.low && n <= range.high);
            const motifSourceNotes = scaleNotesInRange.length > 0 ? scaleNotesInRange : chordNotesInRange;
            const rootNotes = motifSourceNotes.filter(n => n >= baseOctave - 6 && n <= baseOctave + 12);
            const rootFallback = motifSourceNotes.length > 0 ? randomChoice(motifSourceNotes) : Math.floor((range.low + range.high) / 2);
            const rootNote = rootNotes.length > 0 ? randomChoice(rootNotes) : rootFallback;
            
            const melodyChance = 0.4;
            const isMelody = Math.random() < melodyChance;
            
            log('decision', `${synthType}: ${isMelody ? 'MELODY' : 'CHORD'} mode, base octave ${baseOctave}`);
            
            let selectedNotes = [];
            let motifBase = null;
            
            if (isMelody) {
                const patternLength = randomInt(motifSettings.length.min, motifSettings.length.max);
                let currentNote = rootNote;
                for (let i = 0; i < patternLength; i++) {
                    selectedNotes.push(currentNote);
                    const nearbyNotes = motifSourceNotes.filter(n => Math.abs(n - currentNote) <= 7 && n !== currentNote);
                    if (nearbyNotes.length > 0) currentNote = randomChoice(nearbyNotes);
                }
                log('decision', `${synthType}: Pattern [${selectedNotes.map(midiToNoteName).join(' → ')}]`);
                motifBase = selectedNotes.slice();
                seedMotifState(synthType, motifBase);
            } else {
                // Select voicing based on weather expansiveness
                const wxExpansiveness = channelWeather[synthType]?.expansiveness ?? weather.expansiveness ?? 0.5;
                const voicing = selectVoicingByExpansiveness(wxExpansiveness);
                const chordSourceNotes = chordNotesInRange.length > 0 ? chordNotesInRange : motifSourceNotes;
                selectedNotes = voicing.map(interval => {
                    const targetNote = rootNote + interval;
                    return chordSourceNotes.reduce((prev, curr) => 
                        Math.abs(curr - targetNote) < Math.abs(prev - targetNote) ? curr : prev
                    , chordSourceNotes[0] || targetNote);
                });
                selectedNotes = [...new Set(selectedNotes)];
                log('decision', `${synthType}: Voicing [${selectedNotes.map(midiToNoteName).join(' ')}] (exp: ${wxExpansiveness.toFixed(2)})`);
            }

            const configs = {
                violins: {
                    attack: random(0.15, 0.8), decay: random(1, 3), sustain: random(0.6, 0.9),
                    release: random(2.5, 6), loopLength: random(6, 24), volume: random(0.08, 0.13),
                    filterFreq: random(1200, 5000), waveform: 'sawtooth',
                    silenceChance: random(0.05, 0.2)
                },
                cello: {
                    attack: random(0.4, 1.6), decay: random(1, 3), sustain: random(0.6, 0.9),
                    release: random(2.5, 6), loopLength: random(8, 28), volume: random(0.1, 0.18),
                    filterFreq: random(350, 1800), waveform: 'triangle',
                    silenceChance: random(0.05, 0.2)
                },
                bass: {
                    attack: random(0.4, 1.8), decay: random(1.5, 3.5), sustain: random(0.6, 0.9),
                    release: random(3, 7), loopLength: random(8, 28), volume: random(0.08, 0.14),
                    filterFreq: random(300, 1200), waveform: 'triangle',
                    silenceChance: random(0.1, 0.3)
                },
                harp: {
                    attack: random(0.001, 0.02), decay: random(1, 3), sustain: random(0.15, 0.35),
                    release: random(2, 6), loopLength: random(4, 20), volume: random(0.1, 0.18),
                    filterFreq: random(2000, 8000), waveform: 'triangle',
                    silenceChance: random(0.05, 0.2)
                },
                piano: {
                    attack: random(0.001, 0.02), decay: random(1, 3), sustain: random(0.1, 0.3),
                    release: random(2, 5), loopLength: random(4, 18), volume: random(0.08, 0.13),
                    filterFreq: random(1200, 4000), waveform: 'triangle',
                    silenceChance: random(0.1, 0.25)
                },
                guitar: {
                    attack: random(0.001, 0.02), decay: random(0.8, 2.5), sustain: random(0.1, 0.25),
                    release: random(1.5, 4), loopLength: random(4, 18), volume: random(0.07, 0.12),
                    filterFreq: random(1800, 5000), waveform: 'triangle',
                    silenceChance: random(0.1, 0.3)
                },
                celeste: {
                    attack: random(0.001, 0.01), decay: random(2, 5), sustain: random(0.1, 0.2),
                    release: random(3, 8), loopLength: random(5, 25), volume: random(0.09, 0.14),
                    filterFreq: random(4000, 12000), waveform: 'sine',
                    silenceChance: random(0.1, 0.25)
                },
                rhodes: {
                    attack: random(0.001, 0.015), decay: random(1, 3), sustain: random(0.2, 0.5),
                    release: random(2, 5), loopLength: random(6, 25), volume: random(0.1, 0.16),
                    filterFreq: random(1500, 5000), waveform: 'sine',
                    silenceChance: random(0.1, 0.25)
                },
                vibraphone: {
                    attack: random(0.001, 0.01), decay: random(2, 6), sustain: random(0.25, 0.55),
                    release: random(3, 10), loopLength: random(6, 30), volume: random(0.1, 0.16),
                    filterFreq: random(3000, 9000), waveform: 'sine',
                    silenceChance: random(0.1, 0.25)
                },
                whistle: {
                    attack: random(0.05, 0.4), decay: random(1, 2.5), sustain: random(0.4, 0.75),
                    release: random(1.5, 4), loopLength: random(6, 20), volume: random(0.05, 0.1),
                    filterFreq: random(3000, 8000), waveform: 'sine',
                    silenceChance: random(0.15, 0.35)
                },
                flute: {
                    attack: random(0.05, 0.35), decay: random(1, 2.2), sustain: random(0.4, 0.8),
                    release: random(1.5, 4), loopLength: random(6, 20), volume: random(0.05, 0.1),
                    filterFreq: random(3500, 9000), waveform: 'sine',
                    silenceChance: random(0.15, 0.35)
                },
                oboe: {
                    attack: random(0.08, 0.4), decay: random(1, 2.5), sustain: random(0.4, 0.8),
                    release: random(1.5, 4), loopLength: random(6, 22), volume: random(0.05, 0.1),
                    filterFreq: random(1200, 3500), waveform: 'triangle',
                    silenceChance: random(0.15, 0.35)
                },
                clarinet: {
                    attack: random(0.08, 0.4), decay: random(1, 2.5), sustain: random(0.4, 0.85),
                    release: random(1.5, 4.5), loopLength: random(6, 22), volume: random(0.05, 0.1),
                    filterFreq: random(1000, 3000), waveform: 'square',
                    silenceChance: random(0.15, 0.35)
                },
                bassoon: {
                    attack: random(0.15, 0.6), decay: random(1.2, 2.8), sustain: random(0.45, 0.8),
                    release: random(2, 5), loopLength: random(7, 24), volume: random(0.06, 0.11),
                    filterFreq: random(600, 2000), waveform: 'triangle',
                    silenceChance: random(0.15, 0.35)
                },
                woodwinds: {
                    attack: random(0.1, 0.5), decay: random(1, 2.5), sustain: random(0.5, 0.85),
                    release: random(2, 5), loopLength: random(7, 24), volume: random(0.06, 0.12),
                    filterFreq: random(1000, 4000), waveform: 'triangle',
                    silenceChance: random(0.1, 0.3)
                },
                horns: {
                    attack: random(0.15, 0.6), decay: random(1, 2.8), sustain: random(0.55, 0.85),
                    release: random(2.5, 6), loopLength: random(8, 26), volume: random(0.06, 0.11),
                    filterFreq: random(800, 2600), waveform: 'sawtooth',
                    silenceChance: random(0.1, 0.3)
                },
                trumpet: {
                    attack: random(0.03, 0.3), decay: random(0.8, 2.2), sustain: random(0.45, 0.75),
                    release: random(1.5, 4), loopLength: random(6, 20), volume: random(0.05, 0.1),
                    filterFreq: random(1500, 4500), waveform: 'sawtooth',
                    silenceChance: random(0.15, 0.35)
                },
                lowbrass: {
                    attack: random(0.15, 0.7), decay: random(1.5, 3.5), sustain: random(0.6, 0.85),
                    release: random(3, 7), loopLength: random(8, 28), volume: random(0.06, 0.12),
                    filterFreq: random(500, 1800), waveform: 'sawtooth',
                    silenceChance: random(0.1, 0.3)
                },
                brass: {
                    attack: random(0.1, 0.6), decay: random(1, 2.5), sustain: random(0.55, 0.85),
                    release: random(2.5, 6), loopLength: random(8, 26), volume: random(0.06, 0.12),
                    filterFreq: random(900, 3000), waveform: 'sawtooth',
                    silenceChance: random(0.1, 0.3)
                }
            };

            const baseConfig = configs[synthType];
            const adjustedConfig = {
                ...baseConfig,
                loopLength: baseConfig.loopLength * 1.2,
                silenceChance: Math.min(0.9, baseConfig.silenceChance + 0.08)
            };
            const capabilities = INSTRUMENT_CAPABILITIES[synthType] || {};
            const canVibrato = !!capabilities.canVibrato;
            const canTremolo = !!capabilities.canTremolo;
            
            // Randomize starting values - vintage amp style ranges
            channelEffects[synthType] = {
                // Vibrato - subtle Fender-style pitch wobble
                vibratoDepth: canVibrato ? random(0.003, 0.012) : 0,    // Subtle pitch deviation
                vibratoAmount: canVibrato ? random(0.2, 0.7) : 0,       // Intensity
                vibratoSpeed: canVibrato ? random(2, 8) : 0,            // Classic 2-8 Hz range
                
                // Tremolo - Silvertone/Fender throb
                tremoloDepth: canTremolo ? random(0.1, 0.6) : 0,        // How deep the pulse
                tremoloAmount: canTremolo ? random(0.2, 0.6) : 0,       // Intensity
                tremoloSpeed: canTremolo ? random(2, 8) : 0,            // Slow surf to medium chop
                
                // Delay - tape echo character
                delayTime: random(0.1, 0.5),           // 100-500ms tape delay range
                delayAmount: random(0.15, 0.5),        // Mix
                delayFeedback: random(0.2, 0.6),       // Repeats
                
                // Reverb - spring tank warmth
                reverbAmount: random(0.3, 0.7),        // Mix
                reverbDecay: random(1.5, 3.5),         // Spring tank decay
                reverbTone: random(1200, 4000),        // Midrange spring character
                
                // 3-band EQ - vintage amp tone controls
                eqLow: random(-6, 6),                  // Bass boost/cut
                eqMid: random(-4, 4),                  // Mid scoop/boost
                eqHigh: random(-6, 6),                 // Treble boost/cut
                
                // Pan - orchestral seating positions (audience perspective)
                // Add slight variation to prevent static stereo image
                pan: getOrchestraPan(synthType),
                filterSweep: random(2000, 6000)        // Lowpass sweep start
            };

            return {
                notes: selectedNotes,
                motifBase: motifBase,
                isMelody: isMelody,
                isOff: false,
                melodySpeed: isMelody ? random(0.45, 1.4) : 0,
                synthType: synthType,
                range: [range.low, range.high],
                baseOctave: baseOctave,
                ...adjustedConfig
            };
        }

        // ═══════════════════════════════════════════════════════════════
        // ═══════════════════════════════════════════════════════════════
        // NOISE LAYER (Living, breathing background texture)
        // ═══════════════════════════════════════════════════════════════
        
        function createBrownNoise() {
            // Brown noise: lower frequencies, warmer than pink
            const bufferSize = audioCtx.sampleRate * 4; // 4 seconds of noise
            const buffer = audioCtx.createBuffer(2, bufferSize, audioCtx.sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const data = buffer.getChannelData(channel);
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    // Brown noise filter: integrate white noise
                    lastOut = (lastOut + (0.02 * white)) / 1.02;
                    data[i] = lastOut * 3.5; // Compensate for volume loss
                }
            }
            return buffer;
        }
        
        function setupNoiseLayer() {
            // Create brown noise buffer
            const noiseBuffer = createBrownNoise();
            
            // Noise source (looping)
            noiseSource = audioCtx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;
            
            // Gain for fading in/out (breathing amplitude)
            noiseGain = audioCtx.createGain();
            noiseGain.gain.value = 0; // Start silent
            
            // Primary filter - bandpass that sweeps for movement
            noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = 200 + Math.random() * 300;
            noiseFilter.Q.value = 0.4;
            
            // Secondary filter - lowpass that opens/closes
            noiseFilter2 = audioCtx.createBiquadFilter();
            noiseFilter2.type = 'lowpass';
            noiseFilter2.frequency.value = 600;
            noiseFilter2.Q.value = 0.5;
            
            // Resonant peak filter - adds character/shimmer that evolves
            noiseResonance = audioCtx.createBiquadFilter();
            noiseResonance.type = 'peaking';
            noiseResonance.frequency.value = 300 + Math.random() * 400;
            noiseResonance.Q.value = 2 + Math.random() * 3;
            noiseResonance.gain.value = 3 + Math.random() * 6;
            
            // Stereo widener via slight channel delay
            const noisePanner = audioCtx.createStereoPanner();
            noisePanner.pan.value = (Math.random() - 0.5) * 0.6;
            
            // Connect chain
            noiseSource.connect(noiseFilter);
            noiseFilter.connect(noiseFilter2);
            noiseFilter2.connect(noiseResonance);
            noiseResonance.connect(noisePanner);
            noisePanner.connect(noiseGain);
            noiseGain.connect(dryGain);
            
            noiseSource.start();
            log('system', 'Living noise layer ready');
        }
        
        function startNoiseLayerDrift() {
            // Clear any existing timeouts
            noiseEvolveTimeouts.forEach(t => clearTimeout(t));
            noiseEvolveTimeouts = [];
            
            // === BREATHING: Amplitude swells (integrated with weather) ===
            function scheduleBreathing() {
                if (!isPlaying) return;
                const now = audioCtx.currentTime;
                
                // Weather affects noise level
                // Low intimacy = more ambient noise (distant room)
                // High presence = slightly more noise too
                const weatherNoiseBoost = (1 - weather.intimacy) * 0.5 + weather.presence * 0.2;
                const baseLevel = 0.01 * (1 + weatherNoiseBoost);
                
                const roll = Math.random();
                let targetVol, fadeTime;
                
                if (roll < 0.4) {
                    // Inhale - fade in (always gradual)
                    targetVol = baseLevel + Math.random() * 0.03;
                    fadeTime = 12 + Math.random() * 30; // Minimum 12s fade
                } else if (roll < 0.75) {
                    // Exhale - fade down (not out, always gradual)
                    targetVol = baseLevel * 0.3 + Math.random() * 0.01;
                    fadeTime = 15 + Math.random() * 35;
                } else {
                    // Rest - fade to near-silence (never abrupt)
                    targetVol = 0.001; // Not zero, just very quiet
                    fadeTime = 20 + Math.random() * 50; // Long fade to silence
                }
                
                // Always use linearRamp for smooth transitions
                noiseGain.gain.linearRampToValueAtTime(targetVol, now + fadeTime);
                
                const nextTime = 15000 + Math.random() * 45000;
                noiseEvolveTimeouts.push(setTimeout(scheduleBreathing, nextTime));
            }
            
            // === MOVEMENT: Filter sweeps ===
            function scheduleFilterSweep() {
                if (!isPlaying) return;
                const now = audioCtx.currentTime;
                
                // Primary bandpass sweep
                const newBandFreq = 100 + Math.random() * 600;
                const sweepTime = 10 + Math.random() * 40;
                noiseFilter.frequency.linearRampToValueAtTime(newBandFreq, now + sweepTime);
                
                // Occasionally change Q for width
                if (Math.random() < 0.3) {
                    const newQ = 0.2 + Math.random() * 0.8;
                    noiseFilter.Q.linearRampToValueAtTime(newQ, now + sweepTime);
                }
                
                const nextTime = 20000 + Math.random() * 50000;
                noiseEvolveTimeouts.push(setTimeout(scheduleFilterSweep, nextTime));
            }
            
            // === OPENING: Lowpass opens/closes ===
            function scheduleLowpassSweep() {
                if (!isPlaying) return;
                const now = audioCtx.currentTime;
                
                const newCutoff = 300 + Math.random() * 1200;
                const sweepTime = 15 + Math.random() * 45;
                noiseFilter2.frequency.linearRampToValueAtTime(newCutoff, now + sweepTime);
                
                const nextTime = 25000 + Math.random() * 60000;
                noiseEvolveTimeouts.push(setTimeout(scheduleLowpassSweep, nextTime));
            }
            
            // === CHARACTER: Resonant peak shifts ===
            function scheduleResonanceShift() {
                if (!isPlaying) return;
                const now = audioCtx.currentTime;
                
                const roll = Math.random();
                const shiftTime = 8 + Math.random() * 30;
                
                if (roll < 0.5) {
                    // Move the resonant frequency
                    const newFreq = 200 + Math.random() * 800;
                    noiseResonance.frequency.linearRampToValueAtTime(newFreq, now + shiftTime);
                } else if (roll < 0.8) {
                    // Change resonance amount (shimmer)
                    const newGain = 2 + Math.random() * 10;
                    noiseResonance.gain.linearRampToValueAtTime(newGain, now + shiftTime);
                } else {
                    // Change Q (width of resonance)
                    const newQ = 1 + Math.random() * 6;
                    noiseResonance.Q.linearRampToValueAtTime(newQ, now + shiftTime);
                }
                
                const nextTime = 12000 + Math.random() * 35000;
                noiseEvolveTimeouts.push(setTimeout(scheduleResonanceShift, nextTime));
            }
            
            // Start all evolution threads with staggered delays
            setTimeout(scheduleBreathing, 2000 + Math.random() * 5000);
            setTimeout(scheduleFilterSweep, 5000 + Math.random() * 10000);
            setTimeout(scheduleLowpassSweep, 8000 + Math.random() * 15000);
            setTimeout(scheduleResonanceShift, 3000 + Math.random() * 8000);
            
            log('effect', 'Noise layer breathing started');
        }
        
        function stopNoiseLayer() {
            if (noiseFadeTimeout) {
                clearTimeout(noiseFadeTimeout);
                noiseFadeTimeout = null;
            }
            noiseEvolveTimeouts.forEach(t => clearTimeout(t));
            noiseEvolveTimeouts = [];
            if (noiseGain && audioCtx) {
                const now = audioCtx.currentTime;
                noiseGain.gain.cancelScheduledValues(now);
                noiseGain.gain.setValueAtTime(noiseGain.gain.value, now);
                noiseGain.gain.linearRampToValueAtTime(0, now + 0.5);
            }
        }

        // Drift a parameter toward a new random value within its range
        // Speed is now randomized each call for organic movement
        function driftParam(current, range, baseSpeed = 0.1) {
            // Randomize the speed - sometimes tiny, sometimes bigger movements
            const speedVariation = Math.random();
            let speed;
            if (speedVariation < 0.3) {
                // 30% chance: very subtle drift
                speed = baseSpeed * (0.1 + Math.random() * 0.3);
            } else if (speedVariation > 0.9) {
                // 10% chance: larger drift
                speed = baseSpeed * (1.5 + Math.random() * 1.5);
            } else {
                // 60% chance: normal range with variation
                speed = baseSpeed * (0.5 + Math.random() * 1.0);
            }
            
            const drift = (Math.random() - 0.5) * speed * (range.max - range.min);
            return Math.max(range.min, Math.min(range.max, current + drift));
        }
        
        // Get a random transition duration for fluid, organic UI movement
        function getRandomTransitionDuration() {
            const roll = Math.random();
            if (roll < 0.2) {
                // 20%: quick transition (1-2s)
                return 1 + Math.random() * 1;
            } else if (roll > 0.85) {
                // 15%: very slow transition (5-10s)
                return 5 + Math.random() * 5;
            } else {
                // 65%: medium transition (2-5s)
                return 2 + Math.random() * 3;
            }
        }
        
        // Store individual drift timeouts for each channel/parameter group
        let driftTimeouts = {};
        
        // Update UI for a single instrument with randomized transition speeds
        function updateEffectUI(inst) {
            const fx = channelEffects[inst];
            const dom = effectDomCache[inst];
            if (!fx || !dom) return;
            
            // Helper to normalize value to percentage
            const norm = (val, range) => ((val - range.min) / (range.max - range.min)) * 100;
            
            // Helper to set fill bars with random transition duration via CSS variable
            const setFillWithTransition = (el, value) => {
                if (!el) return;
                const duration = getRandomTransitionDuration();
                el.style.setProperty('--fx-duration', `${duration}s`);
                const level = Math.max(0, Math.min(1, value / 100));
                el.style.setProperty('--fx-level', level.toFixed(3));
            };
            
            // Helper for pan/eq markers
            const setMarkerWithTransition = (el, value, varName) => {
                if (!el) return;
                const duration = getRandomTransitionDuration();
                el.style.setProperty(varName, `${duration}s`);
                el.style.left = value + '%';
            };
            
            // Vibrato bars
            const vibDepthEl = dom.vibDepthEl;
            setFillWithTransition(vibDepthEl, norm(fx.vibratoDepth, effectRanges.vibratoDepth));
            const vibEl = dom.vibEl;
            setFillWithTransition(vibEl, fx.vibratoAmount * 100);
            const vibSpeedEl = dom.vibSpeedEl;
            setFillWithTransition(vibSpeedEl, norm(fx.vibratoSpeed, effectRanges.vibratoSpeed));
            
            // Tremolo bars
            const trmDepthEl = dom.trmDepthEl;
            setFillWithTransition(trmDepthEl, norm(fx.tremoloDepth, effectRanges.tremoloDepth));
            const trmEl = dom.trmEl;
            setFillWithTransition(trmEl, fx.tremoloAmount * 100);
            const trmSpeedEl = dom.trmSpeedEl;
            setFillWithTransition(trmSpeedEl, norm(fx.tremoloSpeed, effectRanges.tremoloSpeed));
            
            // Delay bars
            const delayTimeEl = dom.delayTimeEl;
            setFillWithTransition(delayTimeEl, norm(fx.delayTime, effectRanges.delayTime));
            const echoEl = dom.echoEl;
            setFillWithTransition(echoEl, norm(fx.delayAmount, effectRanges.delayAmount));
            const delayFbEl = dom.delayFbEl;
            setFillWithTransition(delayFbEl, norm(fx.delayFeedback, effectRanges.delayFeedback));
            
            // Reverb bars
            const reverbEl = dom.reverbEl;
            setFillWithTransition(reverbEl, norm(fx.reverbAmount, effectRanges.reverbAmount));
            const reverbDecayEl = dom.reverbDecayEl;
            setFillWithTransition(reverbDecayEl, norm(fx.reverbDecay, effectRanges.reverbDecay));
            const reverbToneEl = dom.reverbToneEl;
            setFillWithTransition(reverbToneEl, norm(fx.reverbTone, effectRanges.reverbTone));
            
            // EQ markers (centered at 50%, range -12 to +12 dB)
            const eqToPercent = (val) => ((val + 12) / 24) * 100;
            const eqLowEl = dom.eqLowEl;
            setMarkerWithTransition(eqLowEl, eqToPercent(fx.eqLow), '--eq-duration');
            const eqMidEl = dom.eqMidEl;
            setMarkerWithTransition(eqMidEl, eqToPercent(fx.eqMid), '--eq-duration');
            const eqHighEl = dom.eqHighEl;
            setMarkerWithTransition(eqHighEl, eqToPercent(fx.eqHigh), '--eq-duration');
            
            // Pan marker (full -1 to +1 range)
            const panEl = dom.panEl;
            if (panEl) {
                const panPercent = ((fx.pan + 1) / 2) * 100;
                setMarkerWithTransition(panEl, panPercent, '--pan-duration');
            }
        }
        
        const pendingEffectUpdates = new Set();
        let effectUiRaf = null;
        
        function queueEffectUI(inst) {
            pendingEffectUpdates.add(inst);
            if (effectUiRaf) return;
            
            effectUiRaf = requestAnimationFrame(() => {
                effectUiRaf = null;
                pendingEffectUpdates.forEach((id) => updateEffectUI(id));
                pendingEffectUpdates.clear();
            });
        }
        
        // Schedule a random drift for a specific parameter group
        function scheduleDrift(inst, paramGroup, synth) {
            const key = `${inst}_${paramGroup}`;
            
            // Truly random interval: pick random min (1-8s) and random max (10-45s) each time
            const randomMin = 1000 + Math.random() * 7000;
            const randomMax = 10000 + Math.random() * 35000;
            // Additional chaos: sometimes very short, sometimes very long
            let nextTime;
            const roll = Math.random();
            if (roll < 0.15) {
                // 15% chance: quick change (0.5-3s)
                nextTime = 500 + Math.random() * 2500;
            } else if (roll > 0.9) {
                // 10% chance: very slow change (30-60s)
                nextTime = 30000 + Math.random() * 30000;
            } else {
                // 75% chance: normal random range
                nextTime = randomMin + Math.random() * (randomMax - randomMin);
            }
            
            driftTimeouts[key] = setTimeout(() => {
                if (!isPlaying) return;
                
                const fx = channelEffects[inst];
                const capabilities = INSTRUMENT_CAPABILITIES[inst] || {};
                
                // Drift only this parameter group
                switch (paramGroup) {
                    case 'vibrato':
                        if (!capabilities.canVibrato) {
                            fx.vibratoDepth = 0;
                            fx.vibratoAmount = 0;
                            fx.vibratoSpeed = 0;
                            break;
                        }
                        fx.vibratoDepth = driftParam(fx.vibratoDepth, effectRanges.vibratoDepth, 0.12);
                        fx.vibratoAmount = driftParam(fx.vibratoAmount, effectRanges.vibratoAmount, 0.15);
                        fx.vibratoSpeed = driftParam(fx.vibratoSpeed, effectRanges.vibratoSpeed, 0.1);
                        break;
                    case 'tremolo':
                        if (!capabilities.canTremolo) {
                            fx.tremoloDepth = 0;
                            fx.tremoloAmount = 0;
                            fx.tremoloSpeed = 0;
                            break;
                        }
                        fx.tremoloDepth = driftParam(fx.tremoloDepth, effectRanges.tremoloDepth, 0.12);
                        fx.tremoloAmount = driftParam(fx.tremoloAmount, effectRanges.tremoloAmount, 0.15);
                        fx.tremoloSpeed = driftParam(fx.tremoloSpeed, effectRanges.tremoloSpeed, 0.1);
                        break;
                    case 'delay':
                        fx.delayTime = driftParam(fx.delayTime, effectRanges.delayTime, 0.08);
                        fx.delayAmount = driftParam(fx.delayAmount, effectRanges.delayAmount, 0.12);
                        fx.delayFeedback = driftParam(fx.delayFeedback, effectRanges.delayFeedback, 0.1);
                        break;
                    case 'reverb':
                        fx.reverbAmount = driftParam(fx.reverbAmount, effectRanges.reverbAmount, 0.12);
                        fx.reverbDecay = driftParam(fx.reverbDecay, effectRanges.reverbDecay, 0.08);
                        fx.reverbTone = driftParam(fx.reverbTone, effectRanges.reverbTone, 0.1);
                        break;
                    case 'eq':
                        fx.eqLow = driftParam(fx.eqLow, effectRanges.eqLow, 0.1);
                        fx.eqMid = driftParam(fx.eqMid, effectRanges.eqMid, 0.1);
                        fx.eqHigh = driftParam(fx.eqHigh, effectRanges.eqHigh, 0.1);
                        break;
                    case 'pan':
                        // Pan drifts within ±0.25 of orchestral position
                        const basePan = ORCHESTRAL_PAN[inst] || 0;
                        const panRange = { min: Math.max(-1, basePan - 0.25), max: Math.min(1, basePan + 0.25) };
                        fx.pan = driftParam(fx.pan, panRange, 0.06);
                        break;
                    case 'filterSweep':
                        // Very slow filter sweep - Disasterpeace style
                        fx.filterSweep = driftParam(fx.filterSweep, effectRanges.filterSweep, 0.15);
                        break;
                }
                
                // Update audio nodes
                if (synth) synth.updateEffects();
                
                // Update UI for this instrument
                queueEffectUI(inst);
                
                // Schedule next drift for this parameter group
                scheduleDrift(inst, paramGroup, synth);
                
            }, nextTime);
        }
        
        function startEffectsEbb() {
            // Clear any existing timeouts
            stopEffectsEbb();
            
            const paramGroups = ['vibrato', 'tremolo', 'delay', 'reverb', 'eq', 'pan', 'filterSweep'];
            const instruments = [...INSTRUMENT_ORDER];
            
            // Start independent drift timers for each instrument and parameter group
            instruments.forEach((inst, i) => {
                const synth = synths[i];
                
                paramGroups.forEach(group => {
                    // Stagger initial start times randomly
                    const initialDelay = Math.random() * 5000;
                    setTimeout(() => {
                        if (isPlaying) scheduleDrift(inst, group, synth);
                    }, initialDelay);
                });
            });
            
            log('effect', 'Independent parameter drift started');
        }
        
        function stopEffectsEbb() {
            // Clear all drift timeouts
            Object.values(driftTimeouts).forEach(timeout => clearTimeout(timeout));
            driftTimeouts = {};
        }
        
        // Random mode changes (CHD/MEL/OFF)
        function startModeChanges() {
            if (modeChangeInterval) clearInterval(modeChangeInterval);
            modeChangeInterval = setInterval(() => {
                if (!isPlaying) return;
                
                // Pick a random synth to potentially change
                const synthIndex = randomInt(0, synths.length - 1);
                const synth = synths[synthIndex];
                if (!synth) return;
                
                // 30% chance to change mode
                if (Math.random() < 0.3) {
                    const modes = ['melody', 'melody', 'chord', 'melody', 'chord', 'off'];
                    const newMode = randomChoice(modes);
                    const oldMode = synth.config.isOff ? 'off' : (synth.config.isMelody ? 'melody' : 'chord');
                    
                    if (newMode !== oldMode) {
                        if (newMode === 'off') {
                            synth.config.isOff = true;
                            synth.config.isMelody = false;
                            log('decision', `${synth.config.synthType}: Mode → OFF`);
                            streamLog(synth.config.synthType, 'decision', '■ OFF');
                        } else if (newMode === 'melody') {
                            synth.config.isOff = false;
                            synth.config.isMelody = true;
                            const range = synth.config.range || [24, 108];
                            const scaleNotes = getScaleNotesInRange(range[0], range[1]);
                            const sourceNotes = scaleNotes.length > 0
                                ? scaleNotes
                                : currentChordNotes.filter(n => n >= range[0] && n <= range[1]);
                            const motifLength = randomInt(motifSettings.length.min, motifSettings.length.max);
                            const rootNote = sourceNotes.length > 0 ? randomChoice(sourceNotes) : (synth.config.notes[0] || 60);
                            const motifBase = buildMotifBase(rootNote, sourceNotes, motifLength);
                            synth.config.motifBase = motifBase;
                            synth.config.notes = motifBase.slice();
                            seedMotifState(synth.config.synthType, motifBase);
                            synth.config.melodySpeed = random(0.45, 1.4);
                            log('decision', `${synth.config.synthType}: Mode → MELODY`);
                            streamLog(synth.config.synthType, 'decision', '▶ MEL');
                        } else {
                            synth.config.isOff = false;
                            synth.config.isMelody = false;
                            // Regenerate chord voicing using weather expansiveness
                            const inst = synth.config.synthType;
                            const wxExpansiveness = channelWeather[inst]?.expansiveness ?? weather.expansiveness ?? 0.5;
                            const voicing = selectVoicingByExpansiveness(wxExpansiveness);
                            const rootNote = synth.config.notes[0] || 60;
                            synth.config.notes = voicing.map(interval => {
                                const targetNote = rootNote + interval;
                                return currentChordNotes.reduce((prev, curr) => 
                                    Math.abs(curr - targetNote) < Math.abs(prev - targetNote) ? curr : prev
                                , currentChordNotes[0] || targetNote);
                            });
                            synth.config.notes = [...new Set(synth.config.notes)];
                            log('decision', `${synth.config.synthType}: Mode → CHORD`);
                            streamLog(synth.config.synthType, 'decision', '▶ CHD');
                        }
                        updateStreamMode(synth.config.synthType, synth.config.isMelody, synth.config.isOff);
                    }
                }
            }, 10000); // Check every 10 seconds
        }
        
        function stopModeChanges() {
            if (modeChangeInterval) {
                clearInterval(modeChangeInterval);
                modeChangeInterval = null;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // CHORD TRANSITIONS
        // ═══════════════════════════════════════════════════════════════
        
        // Legacy chord advance - now wraps motif-based harmony
        function advanceChord() {
            // Use motif-based harmony instead of random chords
            advanceMotifHarmony();
        }
        
        // Voice leading for harmony transitions
        function graduallyTransitionSynth(synth, newChordNotes) {
            if (synth.config.isMelody) {
                refreshMotifForInstrument(synth.config.synthType, synth.config);
                return;
            }
            const baseOctave = synth.config.baseOctave || 48;
            const [rangeLow, rangeHigh] = synth.config.range || [24, 108];
            const lowBound = Math.max(rangeLow, baseOctave - 12);
            const highBound = Math.min(rangeHigh, baseOctave + 24);
            const availableNotes = newChordNotes.filter(n => 
                n >= lowBound && n <= highBound
            );
            
            if (availableNotes.length === 0) return;
            
            const oldNotes = [...synth.config.notes];
            const newNotes = oldNotes.map(oldNote => findNearestChordTone(oldNote, availableNotes));
            synth.config.notes = [...new Set(newNotes)];
            
            log('decision', `${synth.config.synthType}: Voice led to [${synth.config.notes.map(midiToNoteName).join(' ')}]`);
            streamLog(synth.config.synthType, 'chord', `→ ${synth.config.notes.map(midiToNoteName).join(' ')}`);
        }

        // ═══════════════════════════════════════════════════════════════
        // INITIALIZE & PLAYBACK
        // ═══════════════════════════════════════════════════════════════
        
        async function initialize() {
            if (isPlaying) {
                stopPlayback();
            }
            log('system', '═══════════════════════════════════════');
            log('system', 'INITIALIZING DRIFT v3');
            log('system', '═══════════════════════════════════════');
            
            if (audioCtx) {
                try {
                    await audioCtx.close();
                } catch (e) {
                    console.warn('Error closing old audio context:', e);
                }
            }
            if (chordChangeInterval) {
                clearTimeout(chordChangeInterval);
                chordChangeInterval = null;
            }
            chordHistory = [];
            resetMotifState();

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            // Resume audio context (required by browsers after user gesture)
            // Must await this before creating any audio nodes
            try {
                await audioCtx.resume();
                log('system', `Audio context state: ${audioCtx.state}`);
            } catch (e) {
                console.error('Failed to resume audio context:', e);
            }
            
            if (audioCtx.state !== 'running') {
                console.error('AudioContext failed to start! State:', audioCtx.state);
                log('system', 'ERROR: Audio context not running');
                return;
            }
            
            masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            
            // Simplified master chain - per-channel effects handle delay/reverb
            log('system', 'Building audio chain...');
            
            dryGain = audioCtx.createGain();
            dryGain.gain.value = 0.8;
            dryGain.connect(audioCtx.destination);
            
            // Noise layer (Disasterpeace style)
            log('system', 'Building noise layer...');
            setupNoiseLayer();

            log('effect', 'Per-channel delay & reverb enabled');

            // Choose scale (Major or Minor only)
            globalScale = Math.random() < 0.5 ? 'Major' : 'Minor';
            globalScaleIntervals = SCALES[globalScale];
            globalRoot = randomInt(0, 11);

            log('system', `Key: ${NOTE_NAMES[globalRoot]} ${globalScale}`);

            // First chord
            currentChord = generateRandomChord();
            currentChordNotes = getChordNotes(currentChord);

            // Generate central motif
            log('system', 'Generating central motif...');
            generateCentralMotif();

            const rootMidi = 36 + globalRoot;
            const scaleNotes = generateScaleNotes(rootMidi, globalScaleIntervals, 5);

            // Create instruments (each has its own delay/reverb chain)
            log('system', 'Creating instruments with per-channel effects...');
            synths = [];
            for (let i = 0; i < INSTRUMENT_ORDER.length; i++) {
                const config = generateSynthConfig(i, currentChordNotes);
                synths.push(new AmbientSynth(audioCtx, masterGain, i, config));
            }

            // Generate ticket ID
            document.getElementById('ticketId').textContent = Math.random().toString(36).substring(2, 10).toUpperCase();

            updateDisplay();
            log('system', 'Initialization complete. Ready to play.');
        }

        function updateDisplay() {
            // Update select values (not textContent)
            const rootSelect = document.getElementById('rootSelect');
            const qualitySelect = document.getElementById('qualitySelect');
            const chordSelect = document.getElementById('chordSelect');
            
            if (rootSelect && globalRoot !== undefined) rootSelect.value = globalRoot;
            if (qualitySelect && globalScale) qualitySelect.value = globalScale;
            if (chordSelect && currentChord) chordSelect.value = currentChord.name;

            // Update stream column modes
            synths.forEach((synth) => {
                updateStreamMode(synth.config.synthType, synth.config.isMelody);
            });
        }
        
        function initializeDropdowns() {
            const rootSelect = document.getElementById('rootSelect');
            const qualitySelect = document.getElementById('qualitySelect');
            const chordSelect = document.getElementById('chordSelect');
            
            // Populate root notes
            rootSelect.innerHTML = '';
            NOTE_NAMES.forEach((name, index) => {
                const opt = document.createElement('option');
                opt.value = index;
                opt.textContent = name;
                rootSelect.appendChild(opt);
            });
            
            // Populate chords
            chordSelect.innerHTML = '';
            const allChords = getAllChords();
            allChords.forEach(chord => {
                const opt = document.createElement('option');
                opt.value = chord.name;
                opt.textContent = chord.name;
                chordSelect.appendChild(opt);
            });
            
            // Event listeners
            rootSelect.addEventListener('change', (e) => {
                setKey(parseInt(e.target.value), globalScale);
            });
            
            qualitySelect.addEventListener('change', (e) => {
                setKey(globalRoot, e.target.value);
            });
            
            chordSelect.addEventListener('change', (e) => {
                setChordByName(e.target.value);
            });
        }

        function startPlayback() {
            if (isPlaying) return;
            
            log('system', '▶ PLAYBACK STARTED');
            isPlaying = true;
            startTime = Date.now();
            synths.forEach(synth => synth.start());
            startEffectsEbb();
            startModeChanges();
            startNoiseLayerDrift();
            startWeatherSystem();  // Per-channel atmospheric parameters
            startKeyModulation();  // Complementary key transitions every ~3min
            
            // Assign initial melody section
            assignMelodySection();
            motifPlaybackIndex = 0;
            
            // ═══ START NEW MUSICAL INTELLIGENCE SYSTEMS ═══
            
            // Initialize phrase system
            phraseStartTime = Date.now();
            currentPhrase = 1;
            currentPhraseLength = randomChoice(PHRASE_LENGTHS);
            log('system', `━━━ Phrase 1 (${currentPhraseLength} beats) ━━━`);
            
            // Schedule phrase advances
            const schedulePhraseAdvance = () => {
                const phraseDuration = currentPhraseLength * BEAT_DURATION * getTempoMultiplier();
                setTimeout(() => {
                    if (isPlaying) {
                        advancePhrase();
                        schedulePhraseAdvance();
                    }
                }, phraseDuration);
            };
            schedulePhraseAdvance();
            
            // Initialize dynamic arc
            dynamicArc.startTime = Date.now();
            dynamicArc.phase = 'building';
            dynamicArc.intensity = 0.3;
            dynamicArc.targetIntensity = 0.7;
            dynamicArc.duration = ARC_PHASES.building.minDuration + 
                Math.random() * (ARC_PHASES.building.maxDuration - ARC_PHASES.building.minDuration);
            log('system', `◆ Dynamic arc: BUILDING (${(dynamicArc.duration/1000).toFixed(0)}s)`);
            setTimeout(() => { if (isPlaying) advanceDynamicArc(); }, dynamicArc.duration);
            
            // Initialize pedal point
            updatePedalPoint();
            const schedulePedalUpdate = () => {
                setTimeout(() => {
                    if (isPlaying) {
                        updatePedalPoint();
                        schedulePedalUpdate();
                    }
                }, 30000 + Math.random() * 30000); // Check every 30-60s
            };
            schedulePedalUpdate();
            
            // Initialize breath cycle
            breathPhase = 'normal';
            breathStartTime = Date.now();
            const firstBreathDelay = BREATH_CYCLE.normalDuration.min + 
                Math.random() * (BREATH_CYCLE.normalDuration.max - BREATH_CYCLE.normalDuration.min);
            setTimeout(() => { if (isPlaying) advanceBreathCycle(); }, firstBreathDelay);
            
            // ═══ MOTIF-BASED HARMONY (replaces random chord changes) ═══
            // Analyze motif and create chord progression
            analyzeMotifHarmony();
            
            // ═══ DISASTERPEACE SIDECHAIN PUMPING ═══
            if (DISASTERPEACE_CONFIG.sidechain.enabled) {
                const startSidechainPump = () => {
                    if (!isPlaying || !audioCtx) return;
                    
                    const now = audioCtx.currentTime;
                    const config = DISASTERPEACE_CONFIG.sidechain;
                    const tempo = parseInt(document.getElementById('bpmSlider')?.value || 60);
                    const beatMs = (60000 / tempo) / 2; // Half beat for pumping
                    
                    // Apply pump to all synths
                    synths.forEach(synth => {
                        if (synth.masterGain) {
                            const currentVol = synth.masterGain.gain.value;
                            synth.masterGain.gain.setValueAtTime(currentVol, now);
                            synth.masterGain.gain.linearRampToValueAtTime(currentVol * config.ratio, now + config.attackTime);
                            synth.masterGain.gain.linearRampToValueAtTime(currentVol, now + config.attackTime + config.releaseTime);
                        }
                    });
                    
                    setTimeout(startSidechainPump, beatMs);
                };
                // Start after a short delay to let things settle
                setTimeout(startSidechainPump, 2000);
                log('system', '◐ Sidechain pumping enabled');
            }
            
            // ═══ END NEW SYSTEMS ═══
            
            // Update time display
            if (timeDisplayInterval) clearInterval(timeDisplayInterval);
            timeDisplayInterval = setInterval(() => {
                if (isPlaying && startTime) {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const secs = (elapsed % 60).toString().padStart(2, '0');
                    document.getElementById('timeDisplay').textContent = `${mins}:${secs}`;
                }
            }, 1000);
        }

        function stopPlayback() {
            log('system', '■ PLAYBACK STOPPED');
            isPlaying = false;
            synths.forEach(synth => synth.stop());
            stopEffectsEbb();
            stopModeChanges();
            stopNoiseLayer();
            stopWeatherSystem();
            stopKeyModulation();
            
            if (timeDisplayInterval) {
                clearInterval(timeDisplayInterval);
                timeDisplayInterval = null;
            }

            if (chordChangeInterval) {
                clearTimeout(chordChangeInterval);
                chordChangeInterval = null;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // EVENT HANDLERS
        // ═══════════════════════════════════════════════════════════════
        
        // Initialize dropdowns on page load
        initializeDropdowns();
        
        // BPM Slider
        document.getElementById('bpmSlider').addEventListener('input', (e) => {
            globalBPM = parseInt(e.target.value);
            document.getElementById('bpmValue').textContent = globalBPM;
            log('system', `BPM: ${globalBPM} (${(BASE_BPM / globalBPM).toFixed(2)}x speed)`);
        });
        
        // Motif regenerate button
        document.getElementById('motifRegenerate').addEventListener('click', () => {
            if (globalRoot !== null && globalScaleIntervals) {
                generateCentralMotif();
                motifPlaybackIndex = 0;
            }
        });
        
        // Motif clear button
        document.getElementById('motifClear').addEventListener('click', () => {
            centralMotif = [];
            motifPlaybackIndex = 0;
            updateStaveDisplay();
            log('system', '♪ Motif cleared');
        });
        
        // Prevent context menu on stave for right-click delete
        document.getElementById('staveContainer').addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        document.getElementById('startBtn').addEventListener('click', async () => {
            await initialize();
            startPlayback();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('randomizeBtn').disabled = false;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
            document.getElementById('recordBtn').disabled = false;
        });

        document.getElementById('stopBtn').addEventListener('click', stopPlayback);

        document.getElementById('randomizeBtn').addEventListener('click', async () => {
            log('system', '↻ RANDOMIZING...');
            await initialize();
            if (isPlaying) {
                stopPlayback();
                startPlayback();
            }
        });

        // Initial log
        log('system', 'DRIFT v3 loaded');
        log('system', 'Click [▶] INIT to begin');
        
        // Initialize empty stave display
        updateStaveDisplay();

    </script>
</body>
</html>
