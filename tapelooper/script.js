// Generative Tape Loop MIDI Mobile
// Author: Auto-generated by Copilot agent
// Core concept: multiple independent rotating loops with adjustable length (in beats), playback rate multiplier, and note events.
// Each loop displays (1) a visual circular mobile and (2) an ASCII ring simulation with a moving playhead.
// Audio: Synthesized Rhodes-esque tone built via layered sines + soft triangle + noise through filtering & chorus-like modulation.

class ToneEngine {
  constructor(context){
    this.ctx = context || new AudioContext();
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.7;
    this.master.connect(this.ctx.destination);
    this.fx = this._buildFX();
    this.fx.out.connect(this.master);
  }
  setMaster(v){ this.master.gain.value = v; }
  _buildFX(){
    const out = this.ctx.createGain();
    const verb = this.ctx.createConvolver();
    verb.buffer = this._makeImpulse(2.5, 2.5);
    const wet = this.ctx.createGain(); wet.gain.value = 0.25;
    const dry = this.ctx.createGain(); dry.gain.value = 0.75;
    const chorusDelay = this.ctx.createDelay(); chorusDelay.delayTime.value = 0.02;
    const chorusLFO = this.ctx.createOscillator(); chorusLFO.frequency.value = 0.15;
    const chorusDepth = this.ctx.createGain(); chorusDepth.gain.value = 0.008;
    chorusLFO.connect(chorusDepth).connect(chorusDelay.delayTime); chorusLFO.start();
    const chorusMix = this.ctx.createGain(); chorusMix.gain.value = 0.4;

    const noiseHP = this.ctx.createBiquadFilter(); noiseHP.type='highpass'; noiseHP.frequency.value=800;

    // Routing: source -> (dry, verb, chorus) -> out
    return { out, verb, wet, dry, chorusDelay, chorusMix, noiseHP };
  }
  _makeImpulse(duration=2,lenDecay=2){
    const rate = this.ctx.sampleRate; const length = rate*duration; const impulse = this.ctx.createBuffer(2,length,rate);
    for(let ch=0; ch<2; ch++){
      const data = impulse.getChannelData(ch);
      for(let i=0;i<length;i++){
        data[i]=(Math.random()*2-1)*Math.pow(1-i/length,lenDecay);
      }
    }
    return impulse;
  }
  playNote(note, velocity=0.6, duration=1){
    const t = this.ctx.currentTime;
    const freq = ToneEngine.midiToFreq(note);
    const env = this.ctx.createGain(); env.gain.setValueAtTime(0,t);
    env.gain.linearRampToValueAtTime(velocity, t+0.01);
    env.gain.exponentialRampToValueAtTime(0.0005, t+duration*1.2);

    const fundamental = this.ctx.createOscillator(); fundamental.type='sine'; fundamental.frequency.value=freq;
    const third = this.ctx.createOscillator(); third.type='sine'; third.frequency.value=freq*2.01;
    const fifth = this.ctx.createOscillator(); fifth.type='triangle'; fifth.frequency.value=freq*3.0;
    const slight = this.ctx.createOscillator(); slight.type='sine'; slight.frequency.value=freq*0.5;

    const gainFund = this.ctx.createGain(); gainFund.gain.value=0.8;
    const gainThird = this.ctx.createGain(); gainThird.gain.value=0.35;
    const gainFifth = this.ctx.createGain(); gainFifth.gain.value=0.15;
    const gainSlight = this.ctx.createGain(); gainSlight.gain.value=0.25;

    const lp = this.ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2400; lp.Q.value=0.3;

    // gentle trem
    const trem = this.ctx.createGain(); trem.gain.value=0.4 * velocity;
    const tremLFO = this.ctx.createOscillator(); tremLFO.frequency.value=5.5; const tremDepth = this.ctx.createGain(); tremDepth.gain.value=0.25 * velocity; tremLFO.connect(tremDepth).connect(trem.gain); tremLFO.start();

    fundamental.connect(gainFund).connect(lp);
    third.connect(gainThird).connect(lp);
    fifth.connect(gainFifth).connect(lp);
    slight.connect(gainSlight).connect(lp);

    lp.connect(trem).connect(env).connect(this.fx.dry);
    env.connect(this.fx.verb);

    fundamental.start(t); third.start(t); fifth.start(t); slight.start(t);
    fundamental.stop(t+duration*1.25); third.stop(t+duration*1.25); fifth.stop(t+duration*1.25); slight.stop(t+duration*1.25);
  }
  static midiToFreq(m){ return 440 * Math.pow(2,(m-69)/12); }
}

class Loop {
  constructor(id,{lengthBeats=8, rate=1, notes=[]}={}){
    this.id=id; this.lengthBeats=lengthBeats; this.rate=rate; this.notes=notes; // notes: [{beat:Float, midi:Int, vel:0-1, dur:beats}]
  this.lengthSeconds = null; // optional explicit seconds length (UI convenience)
    this.enabled=true;
    this.rotation=0; // 0..1 fractional around circle
    this.dom=null; this.asciiDom=null;
  }
}

class Scheduler {
  constructor(engine){
    this.engine = engine;
    this.loops = [];
    this.isRunning=false;
    this.lookahead=0.1; // schedule window seconds
    this.scheduleInterval=null;
    this.nextBeatTime = null;
    this.beatIndex=0;
    this.bpm=80; this.swing=0; // swing percent (delay every other 8th)
  }
  setParams({bpm,swing}){ if(bpm) this.bpm=bpm; if(swing!==undefined) this.swing=swing; }
  addLoop(loop){ this.loops.push(loop); return loop; }
  removeLoop(id){ this.loops = this.loops.filter(l=>l.id!==id); }
  start(){
    if(this.isRunning) return; if(this.engine.ctx.state==='suspended') this.engine.ctx.resume();
    this.isRunning=true;
    this.nextBeatTime=this.engine.ctx.currentTime+0.05; // slight offset
    this.beatIndex=0;
    this.scheduleInterval=setInterval(()=>this._tick(), 25);
    this.lastAnim=performance.now(); requestAnimationFrame(ts=>this._animate(ts));
  }
  stop(){
    this.isRunning=false; clearInterval(this.scheduleInterval); this.scheduleInterval=null;
  }
  beatDuration(){ return 60/this.bpm; }
  _tick(){
    if(!this.isRunning) return;
    const now = this.engine.ctx.currentTime;
    while(this.nextBeatTime < now + this.lookahead){
      this._scheduleBeat(this.beatIndex, this.nextBeatTime);
      const bd = this.beatDuration();
      const swingAdj = (this.beatIndex%2===1) ? bd * (this.swing/100)*0.5 : 0; // lighten
      this.nextBeatTime += bd + swingAdj;
      this.beatIndex++;
    }
  }
  _scheduleBeat(index, time){
    const beatFloat=index; // treat each beat as integer index; note positions are relative within loop length
    for(const loop of this.loops){
      if(!loop.enabled) continue;
      const loopPosBeat = (beatFloat * loop.rate) % loop.lengthBeats; // position within loop
      // schedule notes whose beat is within this beat window (t tolerance half beat?)
      for(const n of loop.notes){
        const distance = (n.beat - loopPosBeat);
        if(Math.abs(distance) < 0.0001){
          const durSec = n.dur * this.beatDuration();
            this.engine.playNote(n.midi, n.vel, n.dur * this.beatDuration());
        }
      }
    }
  }
  _animate(ts){
    if(!this.isRunning) return;
    const bd = this.beatDuration();
    const now = this.engine.ctx.currentTime;
    for(const loop of this.loops){
      // compute fractional progress of loop using current time vs scheduling origin
      const totalBeatsElapsed = (now - (this.nextBeatTime - (this.beatIndex * bd)))/bd; // approximate
      const loopBeatsElapsed = totalBeatsElapsed * loop.rate;
      loop.rotation = (loopBeatsElapsed % loop.lengthBeats)/loop.lengthBeats;
      updateLoopVisual(loop);
    }
    requestAnimationFrame(ts2=>this._animate(ts2));
  }
}

// UI Management
let engine = new ToneEngine();
let scheduler = new Scheduler(engine);
let loopCounter=0;

const loopList = document.getElementById('loopList');
const mobile = document.getElementById('mobile');
const ascii = document.getElementById('ascii');

function createLoopCard(loop){
  const card=document.createElement('div'); card.className='loopCard'; card.dataset.id=loop.id;
  const estSeconds = loop.lengthSeconds || +(loop.lengthBeats * (60/scheduler.bpm)).toFixed(2);
  card.innerHTML=`<div class="loopHeader">Loop ${loop.id}<div><button class="speedDec secondary" title="Slow Down">-</button> <button class="speedInc secondary" title="Speed Up">+</button> <button class="toggleBtn">On</button> <button class="delBtn secondary">X</button></div></div>
  <div class="loopRow">
    <label>Length (beats)<input class="lenInput" type="number" min="1" value="${loop.lengthBeats}"></label>
    <label>Length (sec)<input class="lenSecInput" type="number" min="0.5" step="0.1" value="${estSeconds}"></label>
    <label>Rate <input class="rateInput" type="number" step="0.01" value="${loop.rate}"></label>
    <label>Transp <input class="transpInput" type="number" value="0"></label>
  </div>
  <div class="noteList"></div>
  <div class="addNoteRow"><input class="noteInput" placeholder="Beat Midi Vel Dur (e.g. 0 60 .7 .75)"><button class="addNoteBtn">Add</button></div>`;

  const noteList = card.querySelector('.noteList');
  function renderNotes(){
    noteList.innerHTML='';
    loop.notes.sort((a,b)=>a.beat-b.beat).forEach((n,i)=>{
      const tag=document.createElement('div'); tag.className='noteTag'; tag.textContent=`b${n.beat}: ${n.midi}`; tag.title=`Vel ${n.vel} Dur ${n.dur}`;
      tag.addEventListener('click',()=>{ if(confirm('Remove note?')){ loop.notes.splice(i,1); renderNotes(); buildAscii(loop); }});
      noteList.appendChild(tag);
    });
  }
  renderNotes();

  card.querySelector('.lenInput').addEventListener('change',e=>{ loop.lengthBeats= +e.target.value; buildAscii(loop); });
  card.querySelector('.lenSecInput').addEventListener('change',e=>{ const secs= +e.target.value; loop.lengthSeconds=secs; loop.lengthBeats = +(secs * (scheduler.bpm/60)).toFixed(2); card.querySelector('.lenInput').value=loop.lengthBeats; buildAscii(loop); });
  card.querySelector('.rateInput').addEventListener('change',e=>{ loop.rate= +e.target.value; });
  card.querySelector('.transpInput').addEventListener('change',e=>{ loop.transpose= +e.target.value; });
  card.querySelector('.addNoteBtn').addEventListener('click',()=>{
    const val = card.querySelector('.noteInput').value.trim();
    if(!val) return;
    const parts = val.split(/\s+/);
    if(parts.length<4) return alert('Need 4 fields: beat midi vel dur');
    const [beat,midi,vel,dur]=parts.map(Number);
    loop.notes.push({beat,midi,vel,dur});
    card.querySelector('.noteInput').value='';
    renderNotes(); buildAscii(loop);
  });
  card.querySelector('.toggleBtn').addEventListener('click',e=>{ loop.enabled=!loop.enabled; e.target.textContent= loop.enabled? 'On':'Off'; e.target.style.background = loop.enabled? '#6e40c9':'#30363d';});
  card.querySelector('.speedInc').addEventListener('click',()=>{ loop.rate= +(loop.rate + 0.05).toFixed(2); card.querySelector('.rateInput').value=loop.rate; });
  card.querySelector('.speedDec').addEventListener('click',()=>{ loop.rate= Math.max(0.05, +(loop.rate - 0.05).toFixed(2)); card.querySelector('.rateInput').value=loop.rate; });
  card.querySelector('.delBtn').addEventListener('click',()=>{ if(confirm('Delete loop?')){ scheduler.removeLoop(loop.id); card.remove(); removeVisual(loop); }});
  return card;
}

function addLoop(preset){
  const loop = new Loop(++loopCounter, preset||{});
  scheduler.addLoop(loop);
  const card = createLoopCard(loop); loopList.appendChild(card); loop.domCard=card;
  createVisual(loop); buildAscii(loop);
  return loop;
}

function createVisual(loop){
  const ring=document.createElement('div'); ring.className='ring'; ring.style.width='120px'; ring.style.height='120px'; ring.dataset.id=loop.id;
  const playhead=document.createElement('div'); playhead.className='playhead'; ring.appendChild(playhead);
  mobile.appendChild(ring); loop.dom=ring;
}
function removeVisual(loop){ if(loop.dom){ loop.dom.remove(); } if(loop.asciiDom){ loop.asciiDom.remove(); } }

function updateLoopVisual(loop){
  if(!loop.dom) return;
  const radius = 55;
  const dotsExisting = loop.dom.querySelectorAll('.dot'); dotsExisting.forEach(d=>d.remove());
  for(const n of loop.notes){
    const frac = n.beat/loop.lengthBeats;
    const angle = frac * Math.PI*2 - Math.PI/2; // start top
    const x = radius + Math.cos(angle)*radius;
    const y = radius + Math.sin(angle)*radius;
    const dot=document.createElement('div'); dot.className='dot';
    dot.style.transform=`translate(${x-4}px,${y-4}px)`;
    loop.dom.appendChild(dot);
  }
  const rotationDeg = loop.rotation*360;
  loop.dom.style.setProperty('--rot', rotationDeg+'deg');
  const playhead = loop.dom.querySelector('.playhead');
  playhead.style.transform=`translateX(-50%) rotate(${rotationDeg}deg)`;
  updateAscii(loop);
}

function buildAscii(loop){
  if(!loop.asciiDom){
    loop.asciiDom=document.createElement('div'); loop.asciiDom.className='asciiRing'; ascii.appendChild(loop.asciiDom);
    // Click to insert note on tape at position
    loop.asciiDom.addEventListener('click',e=>{
      // ignore if selecting text
      const rect = loop.asciiDom.getBoundingClientRect();
      const lineOffsetY = e.clientY - rect.top; // basic guard: only if inside main tape body (approx second line)
      // compute fraction along width ignoring padding (monospace assumption)
      const fraction = (e.clientX - rect.left) / rect.width; if(fraction < 0 || fraction > 1) return;
      const beat = +(fraction * loop.lengthBeats).toFixed(2);
      const input = prompt('Add note (format NOTE[oct]|midi [vel dur], e.g. D3 0.6 0.5):','C4 0.5 0.75');
      if(!input) return;
      const parts = input.trim().split(/\s+/);
      if(!parts.length) return;
      let midiPart = parts[0];
      let midi = parseInt(midiPart,10);
      if(isNaN(midi)) midi = noteNameToMidi(midiPart);
      if(midi==null){ alert('Could not parse note'); return; }
      const vel = parts[1] ? parseFloat(parts[1]) : 0.5;
      const dur = parts[2] ? parseFloat(parts[2]) : 0.75;
      loop.notes.push({beat,midi,vel,dur});
      // refresh card note tags
      if(loop.domCard){ const noteList = loop.domCard.querySelector('.noteList'); if(noteList){
        // rebuild minimal (reuse existing render function by triggering change)
        const evt = new Event('change'); loop.domCard.querySelector('.lenInput').dispatchEvent(evt); // triggers buildAscii indirectly
      }}
      buildAscii(loop);
    });
  }
  updateAscii(loop);
}

function updateAscii(loop){
  if(!loop.asciiDom) return;
  const cols = 72; // wider tape resolution
  // Build underscore tape
  const tapeChars = new Array(cols).fill('_');
  // Insert notes (use letter part of note name)
  const sortedNotes = [...loop.notes].sort((a,b)=>a.beat-b.beat);
  for(const n of sortedNotes){
    const idx = Math.max(0, Math.min(cols-1, Math.round((n.beat/loop.lengthBeats)*cols)));
    const label = midiToNoteName(n.midi); // e.g., C4
    for(let i=0;i<label.length && (idx+i)<cols;i++){
      tapeChars[idx+i]=label[i];
    }
  }
  // Playhead marker '(__)' inserted
  let headIdx = Math.round(loop.rotation*cols)%cols; if(headIdx>cols-4) headIdx=cols-4;
  tapeChars[headIdx]='(';
  tapeChars[headIdx+1]='_';
  tapeChars[headIdx+2]='_';
  tapeChars[headIdx+3]=')';
  const top = '_'.repeat(cols+2);
  const body = '|' + tapeChars.join('') + '|';
  const seconds = loop.lengthSeconds || +(loop.lengthBeats * (60/scheduler.bpm)).toFixed(2);
  const meta = `Len: ${seconds}s  Beats: ${loop.lengthBeats}  Rate: ${loop.rate}x  Notes: ${loop.notes.length}`;
  loop.asciiDom.textContent=`Loop ${loop.id}\n${top}\n${body}\n${top}\n${meta}`;
}

// Preset + Randomization
function randomLoop(){
  const lengthBeats = [5,7,9,11,13,8,12][Math.floor(Math.random()*7)];
  const rate = parseFloat((Math.random()*1.5+0.5).toFixed(2));
  const noteCount = Math.ceil(Math.random()*4+2);
  const scale = [60,62,63,65,67,70,72];
  const notes=[];
  for(let i=0;i<noteCount;i++){
    const beat = parseFloat((Math.random()*lengthBeats).toFixed(2));
    const midi = scale[Math.floor(Math.random()*scale.length)] + (Math.random()<0.2?12:0);
    const vel = parseFloat((Math.random()*0.4+0.4).toFixed(2));
    const dur = parseFloat((Math.random()*0.8+0.3).toFixed(2));
    notes.push({beat,midi,vel,dur});
  }
  return {lengthBeats, rate, notes, lengthSeconds: +(lengthBeats * (60/scheduler.bpm)).toFixed(2)};
}

// Export / Import
function exportPreset(){
  const data = { bpm:scheduler.bpm, swing:scheduler.swing, loops:scheduler.loops.map(l=>({lengthBeats:l.lengthBeats, rate:l.rate, notes:l.notes})) };
  const blob = new Blob([JSON.stringify(data,null,2)],{type:'application/json'});
  const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='tape-loops-preset.json'; a.click();
}
function importPreset(obj){
  resetAll();
  scheduler.setParams({bpm:obj.bpm,swing:obj.swing});
  document.getElementById('tempo').value=obj.bpm;
  document.getElementById('swing').value=obj.swing;
  for(const lp of obj.loops){ addLoop(lp); }
}
function resetAll(){
  loopList.innerHTML=''; mobile.innerHTML=''; ascii.innerHTML=''; scheduler.loops=[]; loopCounter=0;
}

// Event wiring
const startBtn=document.getElementById('startBtn');
const stopBtn=document.getElementById('stopBtn');
startBtn.addEventListener('click',()=>{ scheduler.setParams({bpm:+tempo.value,swing:+swing.value}); scheduler.start(); startBtn.disabled=true; stopBtn.disabled=false; });
stopBtn.addEventListener('click',()=>{ scheduler.stop(); startBtn.disabled=false; stopBtn.disabled=true; });

document.getElementById('tempo').addEventListener('change',e=>{ scheduler.setParams({bpm:+e.target.value}); });
document.getElementById('swing').addEventListener('change',e=>{ scheduler.setParams({swing:+e.target.value}); });
document.getElementById('masterVol').addEventListener('input',e=>engine.setMaster(+e.target.value));

document.getElementById('addLoopBtn').addEventListener('click',()=>addLoop(randomLoop()));
document.getElementById('randomizeBtn').addEventListener('click',()=>{ resetAll(); const count=4; for(let i=0;i<count;i++) addLoop(randomLoop()); });
document.getElementById('exportBtn').addEventListener('click',exportPreset);
const importFile=document.getElementById('importFile');
const importBtn=document.getElementById('importBtn');
importBtn.addEventListener('click',()=>importFile.click());
importFile.addEventListener('change',e=>{ const file=e.target.files[0]; if(!file) return; file.text().then(txt=>{ try{ const obj=JSON.parse(txt); importPreset(obj);}catch(err){ alert('Invalid preset'); } }); });

// Initial loops
addLoop({lengthBeats:8, rate:1, notes:[{beat:0,midi:60,vel:0.5,dur:1},{beat:2,midi:64,vel:0.5,dur:1},{beat:4,midi:67,vel:0.5,dur:1},{beat:6,midi:72,vel:0.5,dur:1}]});
addLoop({lengthBeats:12, rate:0.75, notes:[{beat:0,midi:55,vel:0.4,dur:2.5},{beat:5.5,midi:50,vel:0.35,dur:3}]});
addLoop({lengthBeats:10, rate:1.33, notes:[{beat:1,midi:72,vel:0.35,dur:.8},{beat:5.2,midi:74,vel:0.35,dur:.8}]});

// Utility for mobile friendly resume/resume audio
window.addEventListener('click',()=>{ if(engine.ctx.state==='suspended') engine.ctx.resume(); }, {once:true});

console.log('Tape loop generator ready');

// --- Utility: Note name <-> MIDI ---
const NOTE_INDEX = {C:0,'C#':1,Db:1,D:2,'D#':3,Eb:3,E:4,F:5,'F#':6,Gb:6,G:7,'G#':8,Ab:8,A:9,'A#':10,Bb:10,B:11};
function noteNameToMidi(name){
  name = name.trim();
  const m = name.match(/^([A-Ga-g])([#b]?)(-?\d)$/);
  if(!m) return null;
  let letter = m[1].toUpperCase();
  let acc = m[2];
  const oct = parseInt(m[3],10);
  const key = letter + acc;
  if(NOTE_INDEX[key]==null) return null;
  return (oct+1)*12 + NOTE_INDEX[key];
}
function midiToNoteName(midi){
  const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  const n = names[midi%12];
  const oct = Math.floor(midi/12)-1;
  return n+oct;
}
